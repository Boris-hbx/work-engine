<!DOCTYPE html>
<html lang="zh-CN" data-theme="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Boris Life">
    <title>{% block title %}Boris Life{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/assets/icons/icon-192.png">
    <script>
    // æ—©æœŸæ‰§è¡Œï¼šåœ¨é¡µé¢æ¸²æŸ“å‰åº”ç”¨ä¸»é¢˜å’Œä¾§è¾¹æ çŠ¶æ€ï¼Œé¿å…é—ªçƒ
    (function() {
        var theme = localStorage.getItem('theme');
        if (theme) {
            document.documentElement.setAttribute('data-theme', theme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.setAttribute('data-theme', 'dark');
        }
        // é€šè¿‡ CSS ç±»æå‰æ ‡è®°ä¾§è¾¹æ çŠ¶æ€
        if (localStorage.getItem('sidebarCollapsed') === 'true') {
            document.documentElement.classList.add('sidebar-will-collapse');
        }
    })();
    </script>
    <style>
    /* é˜²æ­¢ä¾§è¾¹æ çŠ¶æ€åˆ‡æ¢æ—¶é—ªçƒ */
    html.sidebar-will-collapse .sidebar {
        transform: translateX(-100%);
        opacity: 0;
    }
    html.sidebar-will-collapse .main-content {
        margin-left: 0;
    }
    html.sidebar-will-collapse .sidebar-hint {
        opacity: 1;
    }
    /* ç”¨æˆ·ä¿¡æ¯å’Œç™»å‡ºæŒ‰é’®æ ·å¼ */
    .header-user {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-right: 16px;
    }
    .user-name {
        color: var(--text-color, #e5e7eb);
        font-size: 14px;
        font-weight: 500;
    }
    .logout-btn {
        padding: 6px 12px;
        background: rgba(255,255,255,0.1);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 6px;
        color: var(--text-color, #e5e7eb);
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
    }
    .logout-btn:hover {
        background: rgba(255,255,255,0.2);
    }
    /* æœåŠ¡ç¦»çº¿è­¦å‘Šæ¨ªå¹… */
    .service-offline-banner {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(90deg, #ef4444, #dc2626);
        color: white;
        padding: 12px 20px;
        text-align: center;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        transform: translateY(-100%);
        transition: transform 0.3s ease;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    .service-offline-banner.visible {
        transform: translateY(0);
    }
    .service-offline-banner .banner-content {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
    }
    .service-offline-banner .pulse-dot {
        width: 8px;
        height: 8px;
        background: white;
        border-radius: 50%;
        animation: pulse-offline 1.5s infinite;
    }
    @keyframes pulse-offline {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.5; transform: scale(0.8); }
    }
    .service-offline-banner button {
        background: rgba(255,255,255,0.2);
        border: 1px solid rgba(255,255,255,0.3);
        color: white;
        padding: 4px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        margin-left: 15px;
    }
    .service-offline-banner button:hover {
        background: rgba(255,255,255,0.3);
    }
    /* Prompt ä¸­å¿ƒå¯¼èˆªç»„æ ·å¼ */
    .nav-group {
        margin: 8px 0;
    }
    .nav-group-header {
        display: flex;
        align-items: center;
        padding: 10px 16px;
        cursor: pointer;
        color: var(--sidebar-text, #e5e7eb);
        border-radius: 8px;
        transition: background 0.2s;
        gap: 8px;
    }
    .nav-group-header:hover {
        background: rgba(255,255,255,0.1);
    }
    .nav-group-icon {
        font-size: 16px;
    }
    .nav-group-title {
        flex: 1;
        font-weight: 500;
        font-size: 14px;
    }
    .nav-group-arrow {
        font-size: 10px;
        transition: transform 0.3s;
    }
    .nav-group.expanded .nav-group-arrow {
        transform: rotate(180deg);
    }
    .nav-group-items {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        padding-left: 12px;
    }
    .nav-group.expanded .nav-group-items {
        max-height: 200px;
    }
    .nav-link.sub-link {
        padding: 8px 12px;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 2px 0;
        border-radius: 6px;
        color: var(--sidebar-text, #c5c7cb);
        text-decoration: none;
        transition: all 0.2s;
    }
    .nav-link.sub-link:hover {
        background: rgba(255,255,255,0.08);
        color: white;
    }
    .nav-link.sub-link.active {
        background: var(--primary-color, #667eea);
        color: white;
    }
    .sub-icon {
        font-size: 14px;
    }
    </style>
</head>
<body>
    <!-- æœåŠ¡ç¦»çº¿è­¦å‘Šæ¨ªå¹… -->
    <div class="service-offline-banner" id="service-offline-banner">
        <div class="banner-content">
            <span class="pulse-dot"></span>
            <span>æœåŠ¡æœªå¯åŠ¨æˆ–è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥åç«¯æœåŠ¡æ˜¯å¦æ­£åœ¨è¿è¡Œ</span>
            <button onclick="retryConnection()">é‡è¯•è¿æ¥</button>
        </div>
    </div>

    <!-- ç²’å­åŠ¨ç”»ç”»å¸ƒï¼ˆè¦†ç›–é¡¶æ +ä¾§è¾¹æ çš„Lå½¢åŒºåŸŸï¼‰ -->
    <canvas id="header-particles" class="particles-canvas-extended"></canvas>

    <!-- GitHubé£æ ¼é¡¶éƒ¨å¯¼èˆªæ  -->
    <header class="top-header" id="top-header">
        <div class="header-left">
            <button class="header-menu-btn" id="header-menu-btn" title="èœå•">
                <span class="menu-icon">â˜°</span>
            </button>
            <span class="header-logo" id="header-logo" title="ç‚¹å‡»è®¾ç½®å°çƒæ•°é‡" style="cursor:pointer;">âš¡</span>
            <span class="header-title">Boris Life</span>
        </div>
        <div class="header-right">
            <div class="header-user" id="header-user" style="display:none;">
                <span class="user-name" id="user-display-name"></span>
                <button class="logout-btn" onclick="handleLogout()" title="ç™»å‡º">é€€å‡º</button>
            </div>
            <div class="header-avatar" id="header-avatar" onclick="nextAvatarQuote()">
                <span class="avatar-text">B</span>
                <div class="avatar-quote-tooltip" id="avatar-quote-tooltip">
                    <div class="quote-content" id="avatar-quote-content">Loading...</div>
                    <div class="quote-hint">ç‚¹å‡»æ¢ä¸€å¥</div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- å·¦ä¾§æç¤ºæ¡ - ä¾§è¾¹æ æ”¶èµ·æ—¶æ˜¾ç¤º -->
        <div class="sidebar-hint" id="sidebar-hint">
            <div class="hint-glow"></div>
        </div>

        <!-- å°å® ç‰© - å§‹ç»ˆå¯è§ -->
        <div class="pet" id="pet">
            <div class="pet-eye"></div>
            <div class="pet-eye"></div>
            <div class="pet-eye"></div>
        </div>


        <!-- Left Sidebar -->
        <nav class="sidebar" id="sidebar">
            <div class="nav-links">
                <a href="{{ url_for('main') }}" class="nav-link {% if current_page == 'main' %}active{% endif %}">ä¸»é¡µ</a>
                <a href="{{ url_for('todo') }}" class="nav-link {% if current_page == 'todo' %}active{% endif %}">Todo</a>
                <a href="{{ url_for('motivation') }}" class="nav-link {% if current_page == 'motivation' %}active{% endif %}">ç¨‹åºå‘˜é¼“åŠ±å¤§å¸ˆ</a>
                <a href="{{ url_for('toolbox') }}" class="nav-link {% if current_page == 'toolbox' %}active{% endif %}">å·¥å…·ç®±</a>
                <a href="{{ url_for('game') }}" class="nav-link {% if current_page == 'game' %}active{% endif %}">æ¾å¼€ä½ çš„å¤§è„‘</a>
                <a href="{{ url_for('leader') }}" class="nav-link {% if current_page == 'leader' %}active{% endif %}">é¢†è¢–åŸ¹è®­ç­</a>
                <a href="{{ url_for('english') }}" class="nav-link {% if current_page == 'english' %}active{% endif %}">è‹±æ–‡å­¦ä¹ å¤©åœ°</a>
                <a href="{{ url_for('aichat') }}" class="nav-link ai-link {% if current_page == 'aichat' %}active{% endif %}">
                    <span class="ai-glow"></span>
                    æ™ºè„‘ä¸­æ¢
                </a>

                <!-- ç‰ˆæœ¬ç®¡ç† -->
                <div class="nav-group {% if current_page in ['version', 'prompt_todo', 'prompts', 'learning'] %}expanded{% endif %}">
                    <div class="nav-group-header" onclick="toggleNavGroup(this)">
                        <span class="nav-group-icon">ğŸ”§</span>
                        <span class="nav-group-title">ç‰ˆæœ¬ç®¡ç†</span>
                        <span class="nav-group-arrow">â–¼</span>
                    </div>
                    <div class="nav-group-items">
                        <a href="{{ url_for('version') }}" class="nav-link sub-link {% if current_page == 'version' %}active{% endif %}">
                            <span class="sub-icon">ğŸ“‹</span>ç‰¹æ€§éªŒæ”¶
                        </a>
                        <a href="{{ url_for('prompt_todo') }}" class="nav-link sub-link {% if current_page == 'prompt_todo' %}active{% endif %}">
                            <span class="sub-icon">ğŸ“</span>å¾…æ‰§è¡Œ Prompt
                        </a>
                        <a href="{{ url_for('prompts') }}" class="nav-link sub-link {% if current_page == 'prompts' %}active{% endif %}">
                            <span class="sub-icon">ğŸ“œ</span>Prompt å†å²
                        </a>
                        <a href="{{ url_for('learning') }}" class="nav-link sub-link {% if current_page == 'learning' %}active{% endif %}">
                            <span class="sub-icon">ğŸ“š</span>å­¦ä¹ æ€»ç»“
                        </a>
                    </div>
                </div>

            </div>

            <!-- åº•éƒ¨åŒºåŸŸï¼šæ—¶åŒº -->
            <div class="sidebar-bottom">
                <div class="sidebar-divider"></div>
            </div>

            <!-- æ—¶åŒºæ˜¾ç¤º - ä¾§è¾¹æ åº•éƒ¨ -->
            <div class="timezone-panel" id="timezone-panel">
                <div class="timezone-item">
                    <span class="tz-city">åŒ—äº¬</span>
                    <div class="tz-info">
                        <span class="tz-datetime" id="tz-beijing-date"></span>
                        <span class="tz-time" id="tz-beijing-time"></span>
                    </div>
                </div>
                <div class="timezone-item">
                    <span class="tz-city">æ»‘é“å¢</span>
                    <div class="tz-info">
                        <span class="tz-datetime" id="tz-waterloo-date"></span>
                        <span class="tz-time" id="tz-waterloo-time"></span>
                    </div>
                </div>
                <div class="timezone-item">
                    <span class="tz-city">æ¸©å“¥å</span>
                    <div class="tz-info">
                        <span class="tz-datetime" id="tz-vancouver-date"></span>
                        <span class="tz-time" id="tz-vancouver-time"></span>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Right Main Content -->
        <main class="main-content" id="main-content">
            {% block content %}{% endblock %}
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="theme-toggle" title="åˆ‡æ¢ä¸»é¢˜ (D)">
        <span class="icon-sun">â˜€ï¸</span>
        <span class="icon-moon">ğŸŒ™</span>
    </button>

    <!-- Sync Status Indicator -->
    <div class="sync-status" id="sync-status">
        <span class="sync-dot"></span>
        <span class="sync-text">å·²ä¿å­˜</span>
    </div>

    <!-- Focus Mode Indicator -->
    <div class="focus-mode-indicator" id="focus-indicator">
        ğŸ¯ ä¸“æ³¨æ¨¡å¼ Â· æŒ‰ Esc é€€å‡º
    </div>

    <!-- Weather Effect Toggle -->
    <button class="weather-toggle-fab" id="weather-toggle-fab" title="å¤©æ°”ç‰¹æ•ˆå¼€å…³ (W)">
        <span class="weather-toggle-icon">â„ï¸</span>
        <span class="weather-toggle-status"></span>
    </button>

    <!-- Pomodoro Timer FAB -->
    <button class="pomodoro-fab" id="pomodoro-fab" title="ç•ªèŒ„é’Ÿ (P)">ğŸ…</button>
    <div class="pomodoro-panel" id="pomodoro-panel">
        <div class="pomodoro-time" id="pomodoro-time">25:00</div>
        <div class="pomodoro-label" id="pomodoro-label">ä¸“æ³¨æ—¶é—´</div>
        <div class="pomodoro-controls">
            <button class="pomodoro-btn pomodoro-btn-start" id="pomodoro-start">å¼€å§‹</button>
            <button class="pomodoro-btn pomodoro-btn-reset" id="pomodoro-reset">é‡ç½®</button>
        </div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="shortcuts-modal" id="shortcuts-modal">
        <div class="shortcuts-content">
            <div class="shortcuts-title">âŒ¨ï¸ é”®ç›˜å¿«æ·é”®</div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>N</kbd></span>
                <span class="shortcut-desc">æ–°å»ºä»»åŠ¡</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>S</kbd></span>
                <span class="shortcut-desc">æœç´¢ä»»åŠ¡</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd></span>
                <span class="shortcut-desc">åˆ‡æ¢æ ‡ç­¾é¡µ</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>D</kbd></span>
                <span class="shortcut-desc">åˆ‡æ¢æ·±è‰²æ¨¡å¼</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>F</kbd></span>
                <span class="shortcut-desc">ä¸“æ³¨æ¨¡å¼</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>P</kbd></span>
                <span class="shortcut-desc">ç•ªèŒ„é’Ÿ</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>W</kbd></span>
                <span class="shortcut-desc">å¤©æ°”ç‰¹æ•ˆ</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>?</kbd></span>
                <span class="shortcut-desc">æ˜¾ç¤ºå¿«æ·é”®</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>Esc</kbd></span>
                <span class="shortcut-desc">å…³é—­å¼¹çª—</span>
            </div>
        </div>
    </div>

    <!-- Gesture Hint -->
    <div class="gesture-hint" id="gesture-hint"></div>

    <script>
    // ============================================
    // Global Feature Scripts
    // ============================================

    // æœåŠ¡çŠ¶æ€ç›‘æ§
    (function() {
        var banner = document.getElementById('service-offline-banner');
        var isOffline = false;
        var checkInterval = 10000; // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
        var retryCount = 0;
        var maxRetries = 3;

        function checkServiceStatus() {
            fetch('/api/health', {
                method: 'GET',
                cache: 'no-cache'
            })
            .then(function(response) {
                if (response.ok) {
                    // æœåŠ¡æ­£å¸¸
                    if (isOffline) {
                        isOffline = false;
                        banner.classList.remove('visible');
                        retryCount = 0;
                        // åˆ·æ–°é¡µé¢ä»¥æ¢å¤çŠ¶æ€
                        if (document.hidden === false) {
                            window.location.reload();
                        }
                    }
                } else {
                    showOfflineBanner();
                }
            })
            .catch(function() {
                showOfflineBanner();
            });
        }

        function showOfflineBanner() {
            if (!isOffline) {
                isOffline = true;
                banner.classList.add('visible');
            }
        }

        window.retryConnection = function() {
            retryCount++;
            var btn = banner.querySelector('button');
            btn.textContent = 'æ­£åœ¨é‡è¯•...';
            btn.disabled = true;

            fetch('/api/health', { method: 'GET', cache: 'no-cache' })
                .then(function(response) {
                    if (response.ok) {
                        isOffline = false;
                        banner.classList.remove('visible');
                        window.location.reload();
                    } else {
                        btn.textContent = 'é‡è¯•è¿æ¥';
                        btn.disabled = false;
                    }
                })
                .catch(function() {
                    btn.textContent = 'é‡è¯•è¿æ¥';
                    btn.disabled = false;
                });
        };

        // é¦–æ¬¡æ£€æŸ¥ï¼ˆå»¶è¿Ÿ2ç§’ï¼Œé¿å…é¡µé¢åˆšåŠ è½½æ—¶è¯¯æŠ¥ï¼‰
        setTimeout(checkServiceStatus, 2000);

        // å®šæœŸæ£€æŸ¥
        setInterval(checkServiceStatus, checkInterval);

        // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶æ£€æŸ¥
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                checkServiceStatus();
            }
        });
    })();

    // ç”¨æˆ·è®¤è¯çŠ¶æ€æ£€æŸ¥
    (function() {
        fetch('/api/auth/status')
            .then(function(r) { return r.json(); })
            .then(function(data) {
                if (data.logged_in && data.user) {
                    var userEl = document.getElementById('header-user');
                    var nameEl = document.getElementById('user-display-name');
                    if (userEl && nameEl) {
                        nameEl.textContent = data.user.display_name;
                        userEl.style.display = 'flex';
                    }
                }
            })
            .catch(function() {});
    })();

    // ç™»å‡ºå¤„ç†
    function handleLogout() {
        window.AppUtils.showConfirm('ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿ', function() {
            fetch('/api/auth/logout', { method: 'POST' })
                .then(function(r) { return r.json(); })
                .then(function(data) {
                    if (data.success) {
                        window.location.href = '/login';
                    }
                })
                .catch(function() {
                    window.AppUtils.showToast('ç™»å‡ºå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'error');
                });
        }, { confirmText: 'é€€å‡º' });
    }

    // Nav Group å±•å¼€/æŠ˜å åŠŸèƒ½
    function toggleNavGroup(header) {
        var navGroup = header.parentElement;
        navGroup.classList.toggle('expanded');
        // ä¿å­˜å±•å¼€çŠ¶æ€åˆ° localStorage
        var groupTitle = header.querySelector('.nav-group-title').textContent;
        var expandedGroups = JSON.parse(localStorage.getItem('expandedNavGroups') || '{}');
        expandedGroups[groupTitle] = navGroup.classList.contains('expanded');
        localStorage.setItem('expandedNavGroups', JSON.stringify(expandedGroups));
    }

    // åˆå§‹åŒ– Nav Group çŠ¶æ€
    (function() {
        var expandedGroups = JSON.parse(localStorage.getItem('expandedNavGroups') || '{}');
        document.querySelectorAll('.nav-group').forEach(function(group) {
            var title = group.querySelector('.nav-group-title');
            if (title && expandedGroups[title.textContent] !== undefined) {
                if (expandedGroups[title.textContent]) {
                    group.classList.add('expanded');
                } else {
                    group.classList.remove('expanded');
                }
            }
        });
    })();

    // å…¨å±€é¼ æ ‡ä½ç½®è·Ÿè¸ªï¼ˆç”¨äº toast åœ¨é¼ æ ‡é™„è¿‘æ˜¾ç¤ºï¼‰
    window._mousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    document.addEventListener('mousemove', function(e) {
        window._mousePos = { x: e.clientX, y: e.clientY };
    });
    document.addEventListener('click', function(e) {
        window._mousePos = { x: e.clientX, y: e.clientY };
    });

    // Shared utilities
    window.AppUtils = {
        formatDate: function(isoString) {
            var date = new Date(isoString);
            var y = date.getFullYear();
            var m = (date.getMonth() + 1).toString().padStart(2, '0');
            var d = date.getDate().toString().padStart(2, '0');
            var h = date.getHours().toString().padStart(2, '0');
            var min = date.getMinutes().toString().padStart(2, '0');
            return y + '-' + m + '-' + d + ' ' + h + ':' + min;
        },
        escapeHtml: function(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/\n/g, '<br>');
        },
        showToast: function(message, type) {
            type = type || 'success';
            // åˆ›å»º toast å…ƒç´ 
            var toast = document.createElement('div');
            toast.className = 'toast toast-' + type + ' toast-at-mouse';
            toast.textContent = message;
            document.body.appendChild(toast);

            // è®¡ç®—ä½ç½®ï¼ˆé¼ æ ‡é™„è¿‘ï¼Œç¨å¾®åç§»é¿å…é®æŒ¡ï¼‰
            var mouseX = window._mousePos.x;
            var mouseY = window._mousePos.y;
            var offsetX = 15;
            var offsetY = -40;

            // è·å– toast å°ºå¯¸åè°ƒæ•´ä½ç½®
            var rect = toast.getBoundingClientRect();
            var posX = mouseX + offsetX;
            var posY = mouseY + offsetY;

            // è¾¹ç•Œæ£€æµ‹ï¼Œç¡®ä¿ä¸è¶…å‡ºå±å¹•
            if (posX + rect.width > window.innerWidth - 10) {
                posX = mouseX - rect.width - offsetX;
            }
            if (posY < 10) {
                posY = mouseY + 20;
            }
            if (posY + rect.height > window.innerHeight - 10) {
                posY = window.innerHeight - rect.height - 10;
            }

            toast.style.left = posX + 'px';
            toast.style.top = posY + 'px';

            setTimeout(function() {
                toast.classList.add('toast-hide');
                setTimeout(function() { toast.remove(); }, 300);
            }, 2000);
        },

        // è‡ªå®šä¹‰ç¡®è®¤å¼¹çª—ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼Œæ›¿ä»£æµè§ˆå™¨åŸç”Ÿ confirmï¼‰
        showConfirm: function(message, onConfirm, options) {
            options = options || {};
            var confirmText = options.confirmText || 'ç¡®å®š';
            var cancelText = options.cancelText || 'å–æ¶ˆ';
            var danger = options.danger || false;

            // åˆ›å»ºå¼¹çª—
            var overlay = document.createElement('div');
            overlay.className = 'confirm-overlay';
            overlay.innerHTML = '<div class="confirm-dialog">' +
                '<div class="confirm-body">' + message + '</div>' +
                '<div class="confirm-actions">' +
                    '<button class="confirm-btn cancel-btn">' + cancelText + '</button>' +
                    '<button class="confirm-btn ok-btn' + (danger ? ' danger' : '') + '">' + confirmText + '</button>' +
                '</div>' +
            '</div>';

            document.body.appendChild(overlay);

            // ç»‘å®šäº‹ä»¶
            var closeDialog = function(confirmed) {
                overlay.classList.add('confirm-hide');
                setTimeout(function() {
                    overlay.remove();
                    if (confirmed && onConfirm) {
                        onConfirm();
                    }
                }, 200);
            };

            overlay.querySelector('.cancel-btn').onclick = function() { closeDialog(false); };
            overlay.querySelector('.ok-btn').onclick = function() { closeDialog(true); };

            // ç‚¹å‡»é®ç½©å…³é—­
            overlay.onclick = function(e) {
                if (e.target === overlay) { closeDialog(false); }
            };

            // ESC é”®å…³é—­
            var escHandler = function(e) {
                if (e.key === 'Escape') {
                    closeDialog(false);
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);

            // èšç„¦ç¡®è®¤æŒ‰é’®
            overlay.querySelector('.ok-btn').focus();
        }
    };

    // Theme Management
    (function() {
        var themeToggle = document.getElementById('theme-toggle');
        var html = document.documentElement;

        // Load saved theme or detect system preference
        function initTheme() {
            var saved = localStorage.getItem('theme');
            if (saved) {
                html.setAttribute('data-theme', saved);
            } else {
                // Check system preference
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    html.setAttribute('data-theme', 'dark');
                }
            }
        }

        function toggleTheme() {
            var current = html.getAttribute('data-theme');
            var newTheme = current === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        themeToggle.addEventListener('click', toggleTheme);
        initTheme();

        // Expose for keyboard shortcut
        window.toggleTheme = toggleTheme;
    })();

    // å¤´åƒåè¨€åŠŸèƒ½
    (function() {
        var avatarQuotes = [
            "ä»£ç å¦‚è¯—ï¼Œä¼˜é›…è€Œç®€æ´ã€‚",
            "ä»Šå¤©çš„bugï¼Œæ˜¯æ˜å¤©çš„featureã€‚",
            "å…ˆè®©å®ƒå·¥ä½œï¼Œå†è®©å®ƒä¼˜é›…ã€‚",
            "ç®€å•æ˜¯æœ€ç»ˆçš„å¤æ‚ã€‚",
            "å¥½çš„ä»£ç æ˜¯è‡ªå·±çš„æœ€ä½³æ–‡æ¡£ã€‚",
            "è°ƒè¯•æ˜¯å†™ä»£ç æ—¶æ²¡åšçš„äº‹ã€‚",
            "ä¿æŒå­¦ä¹ ï¼Œä¿æŒè°¦é€Šã€‚",
            "ä¸€æ¬¡åªåšä¸€ä»¶äº‹ï¼Œåšåˆ°æè‡´ã€‚",
            "è½¯ä»¶å¼€å‘æ˜¯ä¸€åœºé©¬æ‹‰æ¾ï¼Œä¸æ˜¯çŸ­è·‘ã€‚",
            "æœ€å¥½çš„é”™è¯¯å¤„ç†æ˜¯ä¸è®©é”™è¯¯å‘ç”Ÿã€‚",
            "é‡æ„æ˜¯å¼€å‘è€…çš„æ—¥å¸¸ä¿®è¡Œã€‚",
            "æµ‹è¯•ä¸æ˜¯æ‰¾bugï¼Œæ˜¯è¯æ˜ä»£ç æ­£ç¡®ã€‚",
            "ä»£ç å†™ç»™äººçœ‹ï¼Œé¡ºä¾¿è®©æœºå™¨æ‰§è¡Œã€‚",
            "æ°¸è¿œä¸è¦ç›¸ä¿¡ç”¨æˆ·è¾“å…¥ã€‚",
            "æå‰ä¼˜åŒ–æ˜¯ä¸‡æ¶ä¹‹æºã€‚",
            "å¤åˆ¶ç²˜è´´æ˜¯æŠ€æœ¯å€ºçš„å¼€å§‹ã€‚"
        ];
        var currentQuoteIndex = Math.floor(Math.random() * avatarQuotes.length);
        var quoteContent = document.getElementById('avatar-quote-content');

        function updateQuote() {
            if (quoteContent) {
                quoteContent.textContent = '"' + avatarQuotes[currentQuoteIndex] + '"';
            }
        }

        window.nextAvatarQuote = function() {
            currentQuoteIndex = (currentQuoteIndex + 1) % avatarQuotes.length;
            updateQuote();
        };

        updateQuote();
    })();

    // Top Header - æ»šåŠ¨éšè—
    (function() {
        var header = document.getElementById('top-header');
        var menuBtn = document.getElementById('header-menu-btn');
        var lastScrollTop = 0;
        var scrollThreshold = 60;

        // æ»šåŠ¨æ—¶éšè—/æ˜¾ç¤ºé¡¶éƒ¨æ 
        window.addEventListener('scroll', function() {
            var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > lastScrollTop && scrollTop > scrollThreshold) {
                // å‘ä¸‹æ»šåŠ¨ï¼Œéšè—
                header.classList.add('hidden');
            } else {
                // å‘ä¸Šæ»šåŠ¨æˆ–æ¥è¿‘é¡¶éƒ¨ï¼Œæ˜¾ç¤º
                header.classList.remove('hidden');
            }

            lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
        }, { passive: true });

        // èœå•æŒ‰é’®ç‚¹å‡» - åˆ‡æ¢ä¾§è¾¹æ 
        if (menuBtn) {
            menuBtn.addEventListener('click', function() {
                var pet = document.getElementById('pet');
                if (pet) pet.click();
            });
        }
    })();

    // Header Particles Animation (å®Œæ•´ç‰ˆï¼šå°¾å·´+æ’æ–¥+ææƒ§+çˆ†ç‚¸+æ±‡åˆ+ä¾§è¾¹æ è´¯é€š)
    (function() {
        var canvas = document.getElementById('header-particles');
        if (!canvas) return;
        var ctx = canvas.getContext('2d');
        var header = document.getElementById('top-header');
        var sidebar = document.getElementById('sidebar');
        var logo = document.getElementById('header-logo');

        // åŒºåŸŸé…ç½® - Lå½¢åŒºåŸŸï¼šé¡¶æ å…¨å®½ + ä¾§è¾¹æ 
        var headerHeight = 48;
        var sidebarWidth = 220;

        // ç²’å­é…ç½®
        var particles = [];
        var fragments = []; // çˆ†ç‚¸ç¢ç‰‡
        var fishes = [];
        var fishFragments = [];
        var particleCount = parseInt(localStorage.getItem('particleCount')) || 6;
        var fishCount = 0; // å°é±¼åŠŸèƒ½å·²éšè—
        var maxTailLength = 12;
        var colors = ['#60a5fa', '#34d399', '#f87171', '#fbbf24', '#a78bfa', '#f472b6'];
        var fishColors = ['#ff9966', '#66ccff', '#99ff99'];

        // ===== å°çƒå¯è°ƒå‚æ•° =====
        window.ballConfig = {
            repelRadius: 180,    // é¼ æ ‡æ„Ÿåº”åŠå¾„
            repelForce: 12,      // æ’æ–¥åŠ›åº¦ (1-15)
            maxSpeed: 10,        // æœ€å¤§é€Ÿåº¦
            friction: 0.97,      // æ‘©æ“¦åŠ› (0.9-0.999)
            tailLength: 5        // å°¾å·´é•¿åº¦
        };

        // é¼ æ ‡ä½ç½®
        var mouse = { x: -1000, y: -1000 };

        // ææƒ§ä¸çˆ†ç‚¸é…ç½®
        var fearThreshold = 15;      // æ›´å¿«å¼€å§‹é¢¤æŠ–
        var explodeThreshold = 45;   // æ›´å¿«åˆ†è£‚
        var reuniteDelay = 60;       // æ›´å¿«åˆæˆ

        // ä»é—ªç”µç”Ÿæˆçš„å°çƒé˜Ÿåˆ—
        var spawningParticles = [];
        var spawnCheckInterval = 30;
        var spawnCheckCounter = 0;

        // å¤©æ°”æ•ˆæœé…ç½®
        var weatherEffects = {
            sunny: { speedMult: 1.2, colorShift: 0, brightness: 1.1 },
            cloudy: { speedMult: 1.0, colorShift: 0, brightness: 0.9 },
            rainy: { speedMult: 0.7, colorShift: 30, brightness: 0.8 },
            snowy: { speedMult: 0.4, colorShift: 60, brightness: 1.0 },
            stormy: { speedMult: 1.5, colorShift: -20, brightness: 0.7 }
        };
        var raindrops = []; // é›¨æ»´æ•ˆæœ
        var snowflakes = []; // é›ªèŠ±æ•ˆæœ

        // å¤©æ°”ç‰¹æ•ˆå¼€å…³çŠ¶æ€ï¼ˆä» localStorage è¯»å–ï¼‰
        var weatherEffectEnabled = localStorage.getItem('weatherEffectEnabled') !== 'false';

        function getWeatherEffect() {
            var type = (window.currentWeather && window.currentWeather.type) || 'cloudy';
            return weatherEffects[type] || weatherEffects.cloudy;
        }

        // è°ƒæ•´é¢œè‰²è‰²ç›¸
        function adjustColor(hexColor, hueShift, brightness) {
            // ç®€å•çš„é¢œè‰²è°ƒæ•´
            var r = parseInt(hexColor.slice(1, 3), 16);
            var g = parseInt(hexColor.slice(3, 5), 16);
            var b = parseInt(hexColor.slice(5, 7), 16);

            // åº”ç”¨äº®åº¦
            r = Math.min(255, Math.floor(r * brightness));
            g = Math.min(255, Math.floor(g * brightness));
            b = Math.min(255, Math.floor(b * brightness));

            // è‰²ç›¸åç§»ï¼ˆç®€åŒ–ç‰ˆï¼šåè“=å¢åŠ bå‡å°‘rï¼Œåæš–=å¢åŠ rå‡å°‘bï¼‰
            if (hueShift > 0) { // åå†·è‰²
                b = Math.min(255, b + hueShift);
                r = Math.max(0, r - hueShift / 2);
            } else if (hueShift < 0) { // åæš–è‰²
                r = Math.min(255, r - hueShift);
                b = Math.max(0, b + hueShift / 2);
            }

            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }

        // åˆ›å»ºé›¨æ»´
        function createRaindrop() {
            return {
                x: Math.random() * canvas.width,
                y: -10,
                speed: 8 + Math.random() * 6,
                length: 10 + Math.random() * 15
            };
        }

        // åˆ›å»ºé›ªèŠ±
        function createSnowflake() {
            return {
                x: Math.random() * canvas.width,
                y: -5,
                speed: 1 + Math.random() * 2,
                size: 2 + Math.random() * 3,
                drift: (Math.random() - 0.5) * 0.5
            };
        }

        // æ›´æ–°å¤©æ°”ç²’å­
        function updateWeatherParticles() {
            // å¦‚æœå¤©æ°”ç‰¹æ•ˆå…³é—­ï¼Œæ¸…ç©ºæ‰€æœ‰ç²’å­
            if (!weatherEffectEnabled) {
                raindrops = [];
                snowflakes = [];
                return;
            }

            var weatherType = (window.currentWeather && window.currentWeather.type) || 'cloudy';

            // é›¨å¤©æ•ˆæœ
            if (weatherType === 'rainy' || weatherType === 'stormy') {
                if (Math.random() < 0.3) raindrops.push(createRaindrop());
                for (var i = raindrops.length - 1; i >= 0; i--) {
                    raindrops[i].y += raindrops[i].speed;
                    if (raindrops[i].y > canvas.height) raindrops.splice(i, 1);
                }
            } else {
                raindrops = [];
            }

            // é›ªå¤©æ•ˆæœ
            if (weatherType === 'snowy') {
                if (Math.random() < 0.1) snowflakes.push(createSnowflake());
                for (var i = snowflakes.length - 1; i >= 0; i--) {
                    snowflakes[i].y += snowflakes[i].speed;
                    snowflakes[i].x += snowflakes[i].drift;
                    if (snowflakes[i].y > canvas.height) snowflakes.splice(i, 1);
                }
            } else {
                snowflakes = [];
            }
        }

        // ç»˜åˆ¶å¤©æ°”ç²’å­
        function drawWeatherParticles() {
            // ç»˜åˆ¶é›¨æ»´
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.6)';
            ctx.lineWidth = 1;
            raindrops.forEach(function(drop) {
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x, drop.y + drop.length);
                ctx.stroke();
            });

            // ç»˜åˆ¶é›ªèŠ±
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            snowflakes.forEach(function(flake) {
                ctx.beginPath();
                ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function resizeCanvas() {
            // å…¨å±å®½åº¦ä»¥æ”¯æŒLå½¢åŒºåŸŸ
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨Lå½¢åŒºåŸŸå†…
        function isInLShape(x, y) {
            return y <= headerHeight || x <= sidebarWidth;
        }

        // è·å–Lå½¢åŒºåŸŸçš„æœ‰æ•ˆè¾¹ç•Œ
        function getLShapeBounds(y) {
            if (y <= headerHeight) {
                return { minX: 0, maxX: canvas.width };
            } else {
                return { minX: 0, maxX: sidebarWidth };
            }
        }

        function createParticle(index, x, y, radius) {
            var baseAngle = Math.random() < 0.5 ? 0 : Math.PI;
            var angle = baseAngle + (Math.random() - 0.5) * Math.PI / 3;
            var speed = 1.5 + Math.random() * 1.0; // æ›´å¼ºçš„åˆå§‹é€Ÿåº¦ï¼Œä¿è¯ä¸ä¼šé™æ­¢
            // å¤§éƒ¨åˆ†ç²’å­ç”Ÿæˆåœ¨é¡¶æ åŒºåŸŸï¼ˆ80%æ¦‚ç‡ï¼‰
            var spawnInHeader = Math.random() < 0.8;
            var spawnX = x !== undefined ? x : (spawnInHeader ? Math.random() * canvas.width : Math.random() * sidebarWidth);
            var spawnY = y !== undefined ? y : (spawnInHeader ? Math.random() * headerHeight : headerHeight + Math.random() * (canvas.height - headerHeight));
            return {
                x: spawnX, y: spawnY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius || (4 + Math.random() * 3),
                color: colors[index % colors.length],
                alpha: 0.7 + Math.random() * 0.2,
                trail: [],
                stuckTime: 0,
                isShaking: false,
                shakeOffset: { x: 0, y: 0 },
                targetAngle: angle,
                turnSpeed: 0.015 + Math.random() * 0.015,
                nextTurnTime: 100 + Math.floor(Math.random() * 150)
            };
        }

        function initParticles() {
            particles = [];
            fragments = [];
            fishes = [];
            fishFragments = [];
            spawningParticles = [];
            for (var i = 0; i < particleCount; i++) {
                particles.push(createParticle(i));
            }
            for (var i = 0; i < fishCount; i++) {
                fishes.push(createFish(i));
            }
        }

        // ä»é—ªç”µå›¾æ ‡ç”Ÿæˆæ–°å°çƒï¼ˆèºæ—‹é£å‡ºæ•ˆæœï¼‰
        function spawnFromLightning() {
            var logo = document.getElementById('app-logo');
            var logoRect = logo ? logo.getBoundingClientRect() : { left: 30, top: 24, width: 24, height: 24 };
            var centerX = logoRect.left + logoRect.width / 2;
            var centerY = logoRect.top + logoRect.height / 2;

            var index = particles.length + spawningParticles.length;
            var sp = {
                x: centerX,
                y: centerY,
                centerX: centerX,
                centerY: centerY,
                angle: Math.random() * Math.PI * 2,
                radius: 5,
                spiralSpeed: 0.15 + Math.random() * 0.05,
                expandSpeed: 0.8,
                rotations: 0,
                maxRotations: 2,
                color: colors[index % colors.length],
                size: 4 + Math.random() * 2,
                alpha: 0.9,
                trail: []
            };
            spawningParticles.push(sp);
        }

        function updateSpawningParticle(sp) {
            sp.trail.push({ x: sp.x, y: sp.y });
            if (sp.trail.length > 10) sp.trail.shift();

            sp.angle += sp.spiralSpeed;
            sp.radius += sp.expandSpeed;
            sp.rotations += sp.spiralSpeed / (Math.PI * 2);

            sp.x = sp.centerX + Math.cos(sp.angle) * sp.radius;
            sp.y = sp.centerY + Math.sin(sp.angle) * sp.radius;

            if (sp.rotations >= sp.maxRotations) {
                var newP = createParticle(particles.length, sp.x, sp.y);
                newP.vx = Math.cos(sp.angle) * 3;
                newP.vy = Math.sin(sp.angle) * 3;
                newP.color = sp.color;
                newP.trail = sp.trail.slice();
                particles.push(newP);
                return false;
            }
            return true;
        }

        function drawSpawningParticle(sp) {
            for (var i = 0; i < sp.trail.length; i++) {
                var t = sp.trail[i];
                var progress = (i + 1) / sp.trail.length;
                ctx.beginPath();
                ctx.arc(t.x, t.y, sp.size * progress * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = sp.color;
                ctx.globalAlpha = sp.alpha * progress * 0.5;
                ctx.fill();
            }
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, sp.size, 0, Math.PI * 2);
            ctx.fillStyle = sp.color;
            ctx.globalAlpha = sp.alpha;
            ctx.shadowColor = sp.color;
            ctx.shadowBlur = 12;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function checkParticleCount() {
            var totalActive = particles.length + spawningParticles.length;
            if (totalActive < particleCount) {
                spawnFromLightning();
            }
        }

        function createFish(index, x, y, size) {
            var direction = Math.random() < 0.5 ? 1 : -1;
            var facingAngle = direction > 0 ? 0 : Math.PI;
            var spawnInHeader = Math.random() < 0.8;
            var spawnX = x !== undefined ? x : (spawnInHeader ? Math.random() * canvas.width : Math.random() * sidebarWidth);
            var spawnY = y !== undefined ? y : (spawnInHeader ? 8 + Math.random() * (headerHeight - 16) : headerHeight + Math.random() * (canvas.height - headerHeight - 16));
            var fishSize = size || (6 + Math.random() * 3);
            return {
                x: spawnX, y: spawnY,
                vx: direction * (0.4 + Math.random() * 0.3),
                vy: (Math.random() - 0.5) * 0.1,
                size: fishSize,
                color: fishColors[index % fishColors.length],
                tailPhase: Math.random() * Math.PI * 2,
                direction: direction,
                facingAngle: facingAngle,
                angle: facingAngle,
                backwardTime: 0,
                turnSpeed: 0.15,
                isEscaping: false,
                escapePhase: 0,
                stuckTime: 0,
                isShaking: false,
                shakeOffset: { x: 0, y: 0 }
            };
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= Math.PI * 2;
            while (angle < -Math.PI) angle += Math.PI * 2;
            return angle;
        }

        // æ£€æµ‹é±¼æ˜¯å¦è¢«å›°
        function isFishStuckAtEdge(f) {
            var edgeMargin = f.size + 5;
            var bounds = getLShapeBounds(f.y);
            var nearEdge = f.x < edgeMargin || f.x > bounds.maxX - edgeMargin ||
                           f.y < edgeMargin || f.y > canvas.height - edgeMargin;
            var dx = f.x - mouse.x;
            var dy = f.y - mouse.y;
            var nearMouse = Math.sqrt(dx * dx + dy * dy) < window.ballConfig.repelRadius + 20;
            return nearEdge && nearMouse;
        }

        // å°é±¼çˆ†ç‚¸
        function explodeFish(f, index) {
            for (var i = 0; i < 3; i++) {
                var angle = (Math.PI * 2 / 3) * i + Math.random() * 0.5;
                var speed = 2 + Math.random() * 1.5;
                fishFragments.push({
                    x: f.x, y: f.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: f.size * 0.5,
                    color: f.color,
                    tailPhase: Math.random() * Math.PI * 2,
                    angle: angle,
                    life: reuniteDelay,
                    parentIndex: index,
                    ignoreMouseTime: 40
                });
            }
            fishes.splice(index, 1);
        }

        // å°é±¼æ±‡åˆ
        function reuniteFishFragments() {
            var groups = {};
            fishFragments.forEach(function(f, i) {
                if (!groups[f.parentIndex]) groups[f.parentIndex] = [];
                groups[f.parentIndex].push({ fragment: f, index: i });
            });
            var toRemove = [];
            for (var parentIndex in groups) {
                var group = groups[parentIndex];
                if (group.length > 0 && group[0].fragment.life <= 0) {
                    var cx = 0, cy = 0;
                    group.forEach(function(g) { cx += g.fragment.x; cy += g.fragment.y; });
                    cx /= group.length; cy /= group.length;
                    var newFish = createFish(parseInt(parentIndex), cx, cy);
                    newFish.vx = (Math.random() - 0.5) * 1.5;
                    newFish.vy = (Math.random() - 0.5) * 1.5;
                    fishes.push(newFish);
                    group.forEach(function(g) { toRemove.push(g.index); });
                }
            }
            toRemove.sort(function(a, b) { return b - a; });
            toRemove.forEach(function(i) { fishFragments.splice(i, 1); });
        }

        function updateFish(f, index) {
            var weatherEffect = getWeatherEffect();
            var speedMult = weatherEffect.speedMult;

            f.tailPhase += 0.15 * speedMult;
            var dx = f.x - mouse.x;
            var dy = f.y - mouse.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var escapeAngle = Math.atan2(dy, dx);
            var velocityAngle = Math.atan2(f.vy, f.vx);

            // é¼ æ ‡æ’æ–¥ä¸æ™ºèƒ½é€ƒé€¸
            if (dist < window.ballConfig.repelRadius && dist > 0) {
                f.isEscaping = true;
                var angleDiff = normalizeAngle(escapeAngle - f.facingAngle);
                var isFacingAway = Math.abs(angleDiff) < Math.PI / 2;

                if (isFacingAway) {
                    f.escapePhase = 0;
                    var force = (window.ballConfig.repelRadius - dist) / window.ballConfig.repelRadius * 6;
                    f.vx += (dx / dist) * force;
                    f.vy += (dy / dist) * force;
                } else {
                    if (f.escapePhase === 0) {
                        f.escapePhase = 1;
                        f.backwardTime = 0;
                    }
                    if (f.escapePhase === 1) {
                        f.backwardTime++;
                        var backwardForce = (window.ballConfig.repelRadius - dist) / window.ballConfig.repelRadius * 3;
                        f.vx += (dx / dist) * backwardForce;
                        f.vy += (dy / dist) * backwardForce;
                        if (f.backwardTime > 15 || dist < window.ballConfig.repelRadius * 0.5) {
                            f.escapePhase = 2;
                        }
                    }
                    if (f.escapePhase === 2) {
                        var turnAmount = normalizeAngle(escapeAngle - f.facingAngle) * 0.3;
                        f.facingAngle = normalizeAngle(f.facingAngle + turnAmount);
                        var force = (window.ballConfig.repelRadius - dist) / window.ballConfig.repelRadius * 5;
                        f.vx += (dx / dist) * force;
                        f.vy += (dy / dist) * force;
                        if (Math.abs(normalizeAngle(escapeAngle - f.facingAngle)) < Math.PI / 4) {
                            f.escapePhase = 0;
                        }
                    }
                }
            } else {
                f.isEscaping = false;
                f.escapePhase = 0;
                f.backwardTime = 0;
            }

            if (isFishStuckAtEdge(f)) {
                f.stuckTime++;
                if (f.stuckTime > fearThreshold) {
                    f.isShaking = true;
                    f.shakeOffset = { x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3 };
                }
                if (f.stuckTime > explodeThreshold) {
                    explodeFish(f, index);
                    return false;
                }
            } else {
                f.stuckTime = Math.max(0, f.stuckTime - 2);
                f.isShaking = false;
                f.shakeOffset = { x: 0, y: 0 };
            }

            var inHeader = f.y <= headerHeight;
            if (inHeader) {
                f.vy += (Math.random() - 0.5) * 0.02;
                f.vy *= 0.95;
            } else {
                f.vx += (Math.random() - 0.5) * 0.03;
                f.vy += (Math.random() - 0.5) * 0.03;
            }
            f.x += f.vx;
            f.y += f.vy;

            var speed = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
            var minSpeed = 0.3 * speedMult;
            if (speed < minSpeed) {
                var angle = inHeader ? (Math.random() < 0.5 ? 0 : Math.PI) : Math.random() * Math.PI * 2;
                f.vx = Math.cos(angle) * 0.5 * speedMult;
                f.vy = Math.sin(angle) * 0.5 * speedMult;
            }
            var maxSpeed = 4 * speedMult;
            if (speed > maxSpeed) {
                f.vx = (f.vx / speed) * maxSpeed;
                f.vy = (f.vy / speed) * maxSpeed;
            }
            f.vx *= 0.995;
            f.vy *= 0.995;

            // Lå½¢æ‹è§’å¤„ç†
            if (f.y > headerHeight && f.x > sidebarWidth - f.size) {
                var overY = f.y - headerHeight;
                var overX = f.x - (sidebarWidth - f.size);
                if (overY < overX) {
                    f.y = headerHeight - f.size;
                    f.vy = -Math.abs(f.vy);
                } else {
                    f.x = sidebarWidth - f.size;
                    f.vx = -Math.abs(f.vx);
                }
            }
            var bounds = getLShapeBounds(f.y);
            if (f.x < f.size) { f.x = f.size; f.vx = Math.abs(f.vx); }
            else if (f.x > bounds.maxX - f.size) { f.x = bounds.maxX - f.size; f.vx = -Math.abs(f.vx); }
            if (f.y < f.size) { f.y = f.size; f.vy = Math.abs(f.vy); }
            else if (f.y > canvas.height - f.size) { f.y = canvas.height - f.size; f.vy = -Math.abs(f.vy); }

            // æ›´æ–°é±¼å¤´æœå‘
            velocityAngle = Math.atan2(f.vy, f.vx);
            if (!f.isEscaping || f.escapePhase === 0) {
                var targetAngle = velocityAngle;
                var angleDiff = normalizeAngle(targetAngle - f.facingAngle);
                var isBackward = Math.abs(angleDiff) > Math.PI / 2;
                if (isBackward) {
                    f.backwardTime++;
                    if (f.backwardTime > 30) {
                        f.facingAngle = normalizeAngle(f.facingAngle + angleDiff * 0.2);
                    }
                } else {
                    f.backwardTime = Math.max(0, f.backwardTime - 1);
                    f.facingAngle = normalizeAngle(f.facingAngle + angleDiff * f.turnSpeed);
                }
            }

            f.angle = f.facingAngle;
            f.direction = Math.cos(f.angle) >= 0 ? 1 : -1;
            return true;
        }

        function updateFishFragment(ff) {
            ff.tailPhase += 0.2;
            if (ff.ignoreMouseTime > 0) ff.ignoreMouseTime--;
            else {
                var dx = ff.x - mouse.x;
                var dy = ff.y - mouse.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < window.ballConfig.repelRadius && dist > 0) {
                    var force = (window.ballConfig.repelRadius - dist) / window.ballConfig.repelRadius * 0.5;
                    ff.vx += (dx / dist) * force;
                    ff.vy += (dy / dist) * force;
                }
            }
            ff.vx *= 0.98; ff.vy *= 0.98;
            ff.x += ff.vx; ff.y += ff.vy;
            ff.life--;
            ff.angle = Math.atan2(ff.vy, ff.vx);
            // Lå½¢æ‹è§’å¤„ç†
            if (ff.y > headerHeight && ff.x > sidebarWidth - ff.size) {
                var overY = ff.y - headerHeight;
                var overX = ff.x - (sidebarWidth - ff.size);
                if (overY < overX) {
                    ff.y = headerHeight - ff.size;
                    ff.vy = -Math.abs(ff.vy);
                } else {
                    ff.x = sidebarWidth - ff.size;
                    ff.vx = -Math.abs(ff.vx);
                }
            }
            var bounds = getLShapeBounds(ff.y);
            if (ff.x < ff.size || ff.x > bounds.maxX - ff.size) {
                ff.vx = -ff.vx;
                ff.x = Math.max(ff.size, Math.min(bounds.maxX - ff.size, ff.x));
            }
            if (ff.y < ff.size || ff.y > canvas.height - ff.size) {
                ff.vy = -ff.vy;
                ff.y = Math.max(ff.size, Math.min(canvas.height - ff.size, ff.y));
            }
        }

        function drawFish(f) {
            var weatherEffect = getWeatherEffect();
            var transMult = getTransparencyMultiplier(f.y);
            var drawX = f.x + (f.shakeOffset ? f.shakeOffset.x : 0);
            var drawY = f.y + (f.shakeOffset ? f.shakeOffset.y : 0);
            ctx.save();
            ctx.translate(drawX, drawY);
            var angle = f.angle || 0;
            var flipY = Math.abs(angle) > Math.PI / 2;
            if (flipY) { ctx.rotate(angle + Math.PI); ctx.scale(1, -1); }
            else { ctx.rotate(angle); }
            var s = f.size;
            var tailSwing = Math.sin(f.tailPhase) * 0.3;

            // æ ¹æ®å¤©æ°”è°ƒæ•´é¢œè‰²
            var fishColor = adjustColor(f.color, weatherEffect.colorShift, weatherEffect.brightness);

            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.2, s * 0.6, 0, 0, Math.PI * 2);
            ctx.fillStyle = fishColor;
            ctx.globalAlpha = 0.85 * transMult;
            if (f.isShaking) { ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15; }
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.moveTo(-s * 1.1, 0);
            ctx.lineTo(-s * 2, -s * 0.5 + tailSwing * s);
            ctx.lineTo(-s * 2, s * 0.5 + tailSwing * s);
            ctx.closePath();
            ctx.fillStyle = fishColor;
            ctx.globalAlpha = 0.7 * transMult;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.5, -s * 0.1, s * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 1 * transMult;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.55, -s * 0.1, s * 0.08, 0, Math.PI * 2);
            ctx.fillStyle = '#333333';
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function drawFishFragment(ff) {
            var transMult = getTransparencyMultiplier(ff.y) * (ff.life / reuniteDelay);
            ctx.save();
            ctx.translate(ff.x, ff.y);
            var angle = ff.angle || 0;
            var flipY = Math.abs(angle) > Math.PI / 2;
            if (flipY) { ctx.rotate(angle + Math.PI); ctx.scale(1, -1); }
            else { ctx.rotate(angle); }
            var s = ff.size;
            var tailSwing = Math.sin(ff.tailPhase) * 0.4;
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.2, s * 0.6, 0, 0, Math.PI * 2);
            ctx.fillStyle = ff.color;
            ctx.globalAlpha = 0.8 * transMult;
            ctx.shadowColor = ff.color;
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.moveTo(-s * 1.1, 0);
            ctx.lineTo(-s * 2, -s * 0.5 + tailSwing * s);
            ctx.lineTo(-s * 2, s * 0.5 + tailSwing * s);
            ctx.closePath();
            ctx.globalAlpha = 0.6 * transMult;
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function isStuckAtEdge(p) {
            var edgeMargin = p.radius + 5;
            var bounds = getLShapeBounds(p.y);
            var nearEdge = p.x < edgeMargin || p.x > bounds.maxX - edgeMargin ||
                           p.y < edgeMargin || p.y > canvas.height - edgeMargin;
            var dx = p.x - mouse.x;
            var dy = p.y - mouse.y;
            var nearMouse = Math.sqrt(dx * dx + dy * dy) < window.ballConfig.repelRadius + 20;
            return nearEdge && nearMouse;
        }

        // çˆ†ç‚¸åˆ†è£‚
        function explodeParticle(p, index) {
            var fragmentColors = [colors[(index) % colors.length], colors[(index + 2) % colors.length], colors[(index + 4) % colors.length]];
            for (var i = 0; i < 3; i++) {
                var angle = (Math.PI * 2 / 3) * i + Math.random() * 0.5;
                var speed = 3 + Math.random() * 2;
                fragments.push({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: p.radius * 0.5,
                    color: fragmentColors[i],
                    alpha: 0.9,
                    trail: [],
                    life: reuniteDelay,
                    parentIndex: index,
                    ignoreMouseTime: 40 // æ— è§†é¼ æ ‡çš„æ—¶é—´
                });
            }
            // ç§»é™¤åŸç²’å­
            particles.splice(index, 1);
        }

        // ç¢ç‰‡æ±‡åˆé‡ç»„
        function reuniteFragments() {
            var groups = {};
            fragments.forEach(function(f, i) {
                if (!groups[f.parentIndex]) groups[f.parentIndex] = [];
                groups[f.parentIndex].push({ fragment: f, index: i });
            });

            var toRemove = [];
            for (var parentIndex in groups) {
                var group = groups[parentIndex];
                if (group.length > 0 && group[0].fragment.life <= 0) {
                    // è®¡ç®—æ±‡åˆä¸­å¿ƒ
                    var cx = 0, cy = 0;
                    group.forEach(function(g) { cx += g.fragment.x; cy += g.fragment.y; });
                    cx /= group.length;
                    cy /= group.length;

                    // åˆ›å»ºæ–°ç²’å­ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„åˆå§‹é€Ÿåº¦
                    var newP = createParticle(particles.length, cx, cy);
                    var angle = Math.random() * Math.PI * 2;
                    var speed = 1.5 + Math.random() * 1.0;
                    newP.vx = Math.cos(angle) * speed;
                    newP.vy = Math.sin(angle) * speed;
                    particles.push(newP);

                    // æ ‡è®°ç§»é™¤ç¢ç‰‡
                    group.forEach(function(g) { toRemove.push(g.index); });
                }
            }
            // ä»åå¾€å‰ç§»é™¤
            toRemove.sort(function(a, b) { return b - a; });
            toRemove.forEach(function(i) { fragments.splice(i, 1); });
        }

        function updateParticle(p, index) {
            // è®¡ç®—å½“å‰é€Ÿåº¦
            var speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);

            // å°¾å·´é•¿åº¦ï¼šåŸºç¡€é•¿åº¦ + é€Ÿåº¦åŠ æˆï¼Œä½¿ç”¨å¯è°ƒå‚æ•°
            var dynamicTailLength = Math.floor(5 + speed * 2);
            dynamicTailLength = Math.max(5, Math.min(window.ballConfig.tailLength, dynamicTailLength));

            p.trail.push({ x: p.x, y: p.y });
            while (p.trail.length > dynamicTailLength) p.trail.shift();

            // æ£€æµ‹æ˜¯å¦è¢«å›°
            if (isStuckAtEdge(p)) {
                p.stuckTime++;
                if (p.stuckTime > fearThreshold) {
                    p.isShaking = true;
                    p.shakeOffset.x = (Math.random() - 0.5) * 3;
                    p.shakeOffset.y = (Math.random() - 0.5) * 3;
                }
                if (p.stuckTime > explodeThreshold) {
                    explodeParticle(p, index);
                    return false; // ç²’å­å·²ç§»é™¤
                }
            } else {
                p.stuckTime = Math.max(0, p.stuckTime - 2);
                p.isShaking = false;
                p.shakeOffset.x = 0;
                p.shakeOffset.y = 0;
            }

            var cfg = window.ballConfig;
            var inHeader = p.y <= headerHeight;

            // ===== é¼ æ ‡æ’æ–¥ - æœ€é«˜ä¼˜å…ˆçº§ =====
            var dx = p.x - mouse.x;
            var dy = p.y - mouse.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var isEscaping = false;

            if (dist < cfg.repelRadius && dist > 0) {
                isEscaping = true;
                // è·ç¦»è¶Šè¿‘ï¼ŒåŠ›è¶Šå¤§ï¼ˆäºŒæ¬¡æ–¹å…³ç³»ï¼Œæ›´æ•æ„Ÿï¼‰
                var ratio = 1 - dist / cfg.repelRadius;
                var force = ratio * ratio * cfg.repelForce * 1.5;
                p.vx += (dx / dist) * force;
                p.vy += (dy / dist) * force;
            }

            // è‡ªç”±æ¸¸åŠ¨ï¼ˆä»…åœ¨ä¸é€ƒè·‘æ—¶ç”Ÿæ•ˆï¼‰
            if (!isEscaping) {
                p.nextTurnTime--;
                if (p.nextTurnTime <= 0) {
                    var currentAngle = Math.atan2(p.vy, p.vx);
                    if (inHeader) {
                        // é¡¶æ ï¼šä¸»è¦å·¦å³æ¸¸åŠ¨ï¼Œå¶å°”è½¬å‘
                        if (Math.random() < 0.6) {
                            var baseAngle = Math.cos(currentAngle) > 0 ? 0 : Math.PI;
                            if (Math.random() < 0.2) baseAngle += Math.PI; // 20%æ¦‚ç‡æ‰å¤´
                            p.targetAngle = baseAngle + (Math.random() - 0.5) * Math.PI / 2;
                        } else {
                            p.targetAngle = currentAngle + (Math.random() - 0.5) * Math.PI * 0.6;
                        }
                    } else {
                        // ä¾§è¾¹æ ï¼šè‡ªç”±æ–¹å‘
                        p.targetAngle = Math.random() * Math.PI * 2;
                    }
                    // æ›´é¢‘ç¹åœ°æ”¹å˜æ–¹å‘ï¼Œè®©è¿åŠ¨æ›´æ´»æ³¼
                    p.nextTurnTime = 40 + Math.floor(Math.random() * 80);
                }

                var currentAngle = Math.atan2(p.vy, p.vx);
                var angleDiff = p.targetAngle - currentAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                // æ›´å¿«çš„è½¬å‘é€Ÿåº¦
                var newAngle = currentAngle + angleDiff * p.turnSpeed * 1.5;
                // ä¿æŒä¸€å®šçš„æ¸¸åŠ¨é€Ÿåº¦
                var targetSpeed = 1.0 + Math.random() * 1.0;
                var newSpeed = Math.max(speed, targetSpeed);
                p.vx = Math.cos(newAngle) * newSpeed;
                p.vy = Math.sin(newAngle) * newSpeed;
            }

            if (inHeader && !isEscaping) p.vy *= 0.92; // ç¨å¾®é™åˆ¶å‚ç›´è¿åŠ¨

            // é€Ÿåº¦æ§åˆ¶
            speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            var maxSpeed = isEscaping ? cfg.maxSpeed * 1.5 : cfg.maxSpeed;
            var minSpeed = 1.0; // æé«˜æœ€ä½é€Ÿåº¦ï¼Œä¿æŒæ´»è·ƒ
            if (speed > maxSpeed) {
                p.vx = (p.vx / speed) * maxSpeed;
                p.vy = (p.vy / speed) * maxSpeed;
            } else if (speed < minSpeed) {
                // é€Ÿåº¦å¤ªæ…¢æ—¶ï¼Œç»™ä¸€ä¸ªéšæœºæ¨åŠ›
                var angle = inHeader ? (Math.random() < 0.5 ? 0 : Math.PI) + (Math.random() - 0.5) * 0.5 : Math.random() * Math.PI * 2;
                var boost = minSpeed + Math.random() * 0.5;
                p.vx = Math.cos(angle) * boost;
                p.vy = Math.sin(angle) * boost;
            }

            // æ‘©æ“¦åŠ›ï¼ˆé€ƒè·‘æ—¶å‡å°‘æ‘©æ“¦ï¼Œå¹³æ—¶ä¹Ÿä¿æŒè¾ƒä½æ‘©æ“¦è®©è¿åŠ¨æ›´æµç•…ï¼‰
            var friction = isEscaping ? 0.96 : 0.995;
            p.vx *= friction;
            p.vy *= friction;

            // ===== å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿é€Ÿåº¦æœ‰æ•ˆ =====
            if (isNaN(p.vx) || isNaN(p.vy) || !isFinite(p.vx) || !isFinite(p.vy)) {
                var safeAngle = Math.random() * Math.PI * 2;
                p.vx = Math.cos(safeAngle) * 1.5;
                p.vy = Math.sin(safeAngle) * 1.5;
            }

            // è¾¹ç•Œå®‰å…¨è·ç¦»
            var margin = p.radius + 2;

            // ===== é¢„æµ‹å¼è¾¹ç•Œæ£€æŸ¥ - åœ¨ç§»åŠ¨å‰æ£€æŸ¥ç›®æ ‡ä½ç½® =====
            var nextX = p.x + p.vx;
            var nextY = p.y + p.vy;

            // æ£€æŸ¥æ˜¯å¦ä¼šè¿›å…¥Lå½¢ç¦åŒºï¼ˆä¸»å†…å®¹åŒºåŸŸï¼‰
            var wouldEnterForbidden = nextY > headerHeight - margin && nextX > sidebarWidth - margin;
            var currentlyInHeader = p.y <= headerHeight;
            var currentlyInSidebar = p.x <= sidebarWidth;

            if (wouldEnterForbidden) {
                if (currentlyInHeader && nextY > headerHeight - margin) {
                    // ä»é¡¶æ å‘ä¸‹ç§»åŠ¨ï¼Œé˜»æ­¢
                    p.vy = -Math.abs(p.vy) * 0.5;
                    nextY = headerHeight - margin;
                }
                if (currentlyInSidebar && nextX > sidebarWidth - margin) {
                    // ä»ä¾§è¾¹æ å‘å³ç§»åŠ¨ï¼Œé˜»æ­¢
                    p.vx = -Math.abs(p.vx) * 0.5;
                    nextX = sidebarWidth - margin;
                }
            }

            // å¤–è¾¹ç•Œæ£€æŸ¥
            if (nextX < margin) { nextX = margin; p.vx = Math.abs(p.vx) * 0.8; }
            if (nextY < margin) { nextY = margin; p.vy = Math.abs(p.vy) * 0.8; }

            // æ ¹æ®å½“å‰åŒºåŸŸæ£€æŸ¥å³è¾¹ç•Œå’Œåº•è¾¹ç•Œ
            if (nextY <= headerHeight) {
                // åœ¨é¡¶æ åŒºåŸŸ
                if (nextX > canvas.width - margin) { nextX = canvas.width - margin; p.vx = -Math.abs(p.vx) * 0.8; }
            } else {
                // åœ¨ä¾§è¾¹æ åŒºåŸŸ
                if (nextX > sidebarWidth - margin) { nextX = sidebarWidth - margin; p.vx = -Math.abs(p.vx) * 0.8; }
                if (nextY > canvas.height - margin) { nextY = canvas.height - margin; p.vy = -Math.abs(p.vy) * 0.8; }
            }

            // åº”ç”¨ä½ç½®
            p.x = nextX;
            p.y = nextY;

            // ===== æœ€ç»ˆå®‰å…¨æ£€æŸ¥ - å¼ºåˆ¶å°†ä»»ä½•è¶Šç•Œç²’å­æ¨å› =====
            if (p.y > headerHeight && p.x > sidebarWidth) {
                // å·²ç»åœ¨ç¦åŒºå†…ï¼Œç«‹å³æ¨å›
                if (p.y - headerHeight < p.x - sidebarWidth) {
                    p.y = headerHeight - margin;
                    p.vy = -Math.abs(p.vy);
                } else {
                    p.x = sidebarWidth - margin;
                    p.vx = -Math.abs(p.vx);
                }
            }

            p.targetAngle = Math.atan2(p.vy, p.vx);
            return true;
        }

        function updateFragment(f) {
            f.trail.push({ x: f.x, y: f.y });
            if (f.trail.length > 8) f.trail.shift();

            if (f.ignoreMouseTime > 0) {
                f.ignoreMouseTime--;
            } else {
                var dx = f.x - mouse.x;
                var dy = f.y - mouse.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < window.ballConfig.repelRadius && dist > 0) {
                    var force = (window.ballConfig.repelRadius - dist) / window.ballConfig.repelRadius * 0.5;
                    f.vx += (dx / dist) * force;
                    f.vy += (dy / dist) * force;
                }
            }

            f.vx *= 0.98;
            f.vy *= 0.98;
            f.x += f.vx;
            f.y += f.vy;
            f.life--;

            // Lå½¢æ‹è§’å¤„ç†
            if (f.y > headerHeight && f.x > sidebarWidth - f.radius) {
                var overY = f.y - headerHeight;
                var overX = f.x - (sidebarWidth - f.radius);
                if (overY < overX) {
                    f.y = headerHeight - f.radius;
                    f.vy = -Math.abs(f.vy);
                } else {
                    f.x = sidebarWidth - f.radius;
                    f.vx = -Math.abs(f.vx);
                }
            }

            // Lå½¢è¾¹ç•Œ
            var bounds = getLShapeBounds(f.y);
            if (f.x - f.radius < 0 || f.x + f.radius > bounds.maxX) {
                f.vx = -f.vx;
                f.x = Math.max(f.radius, Math.min(bounds.maxX - f.radius, f.x));
            }
            if (f.y - f.radius < 0 || f.y + f.radius > canvas.height) {
                f.vy = -f.vy;
                f.y = Math.max(f.radius, Math.min(canvas.height - f.radius, f.y));
            }
        }

        // è®¡ç®—é€æ˜åº¦ç³»æ•°ï¼ˆåœ¨ä¾§è¾¹æ åŒºåŸŸæ—¶å˜é€æ˜ï¼‰
        function getTransparencyMultiplier(y) {
            if (y <= headerHeight) return 1; // é¡¶æ åŒºåŸŸï¼šå®Œå…¨ä¸é€æ˜
            // ä¾§è¾¹æ åŒºåŸŸï¼šæ¸å˜åˆ°50%é€æ˜
            var fadeStart = headerHeight;
            var fadeEnd = headerHeight + 50;
            if (y < fadeEnd) {
                return 1 - 0.5 * ((y - fadeStart) / (fadeEnd - fadeStart));
            }
            return 0.5; // ä¾§è¾¹æ æ·±å¤„ï¼š50%é€æ˜
        }

        function drawParticle(p) {
            var drawX = p.x + (p.shakeOffset ? p.shakeOffset.x : 0);
            var drawY = p.y + (p.shakeOffset ? p.shakeOffset.y : 0);
            var transMult = getTransparencyMultiplier(drawY);

            // å¹³æ»‘å½—æ˜Ÿå°¾å·´æ•ˆæœï¼šä½¿ç”¨æ¸å˜è·¯å¾„
            if (p.trail.length > 2) {
                // ä»å°¾éƒ¨åˆ°å¤´éƒ¨ç»˜åˆ¶å¹³æ»‘æ¸å˜
                for (var i = 1; i < p.trail.length; i++) {
                    var t0 = p.trail[i - 1];
                    var t1 = p.trail[i];
                    var progress = i / p.trail.length;

                    // çº¿æ¡å®½åº¦ï¼šä»ç»†åˆ°ç²—
                    var width0 = p.radius * 2 * (progress - 1/p.trail.length) * 0.9;
                    var width1 = p.radius * 2 * progress * 0.9;

                    // é€æ˜åº¦ï¼šä»æ·¡åˆ°æµ“ï¼Œä½¿ç”¨ä¸‰æ¬¡æ–¹è®©æ¸å˜æ›´å¹³æ»‘
                    var alpha = p.alpha * progress * progress * progress * 0.6;
                    var trailTrans = getTransparencyMultiplier((t0.y + t1.y) / 2);

                    // ç»˜åˆ¶æ¸å˜çº¿æ®µ
                    ctx.beginPath();
                    ctx.moveTo(t0.x, t0.y);
                    ctx.lineTo(t1.x, t1.y);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = Math.max(1, (width0 + width1) / 2);
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = alpha * trailTrans;
                    ctx.stroke();
                }

                // è¿æ¥å°¾å·´æœ«ç«¯åˆ°çƒä½“ï¼Œç¡®ä¿å¹³æ»‘è¿‡æ¸¡
                if (p.trail.length > 0) {
                    var lastTrail = p.trail[p.trail.length - 1];
                    ctx.beginPath();
                    ctx.moveTo(lastTrail.x, lastTrail.y);
                    ctx.lineTo(drawX, drawY);
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = p.radius * 1.6;
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = p.alpha * 0.5 * transMult;
                    ctx.stroke();
                }
            }

            // ä¸»çƒä½“ï¼ˆéœ‡åŠ¨æ—¶å¸¦çº¢è‰²å…‰æ™•ï¼‰
            ctx.beginPath();
            ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.alpha * transMult;
            ctx.shadowColor = p.isShaking ? '#ff0000' : p.color;
            ctx.shadowBlur = p.isShaking ? 15 : 10;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function drawFragment(f) {
            var transMult = getTransparencyMultiplier(f.y);
            // å°¾å·´
            for (var i = 0; i < f.trail.length; i++) {
                var t = f.trail[i];
                var progress = i / f.trail.length;
                var trailTrans = getTransparencyMultiplier(t.y);
                ctx.beginPath();
                ctx.arc(t.x, t.y, f.radius * progress * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = f.color;
                ctx.globalAlpha = f.alpha * progress * 0.4 * trailTrans;
                ctx.fill();
            }
            // ç¢ç‰‡
            ctx.beginPath();
            ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
            ctx.fillStyle = f.color;
            ctx.globalAlpha = f.alpha * (f.life / reuniteDelay) * transMult;
            ctx.shadowColor = f.color;
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function animate() {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ===== æ¯å¸§å¼€å§‹æ—¶ï¼šå¼ºåˆ¶éªŒè¯æ‰€æœ‰ç²’å­é€Ÿåº¦ =====
                for (var j = 0; j < particles.length; j++) {
                    var p = particles[j];
                    var spd = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    // ä¿®å¤æ— æ•ˆé€Ÿåº¦æˆ–é™æ­¢ç²’å­
                    if (isNaN(spd) || !isFinite(spd) || spd < 0.5) {
                        var angle = Math.random() * Math.PI * 2;
                        var newSpeed = 1.5 + Math.random() * 1.0;
                        p.vx = Math.cos(angle) * newSpeed;
                        p.vy = Math.sin(angle) * newSpeed;
                    }
                }

                // å®šæœŸæ£€æŸ¥å°çƒæ•°é‡
                spawnCheckCounter++;
                if (spawnCheckCounter >= spawnCheckInterval) {
                    spawnCheckCounter = 0;
                    checkParticleCount();
                }

                // èºæ—‹ç”Ÿæˆä¸­çš„å°çƒ
                for (var i = spawningParticles.length - 1; i >= 0; i--) {
                    if (updateSpawningParticle(spawningParticles[i])) {
                        drawSpawningParticle(spawningParticles[i]);
                    } else {
                        spawningParticles.splice(i, 1);
                    }
                }

                // æ›´æ–°å¹¶ç»˜åˆ¶å¤©æ°”æ•ˆæœï¼ˆé›¨æ»´/é›ªèŠ±ï¼‰
                updateWeatherParticles();
                drawWeatherParticles();

                // ç²’å­ - å¤åˆ¶æ•°ç»„é¿å…spliceé—®é¢˜
                var particlesToProcess = particles.slice();

                for (var i = 0; i < particlesToProcess.length; i++) {
                    var p = particlesToProcess[i];
                    // æ‰¾åˆ°å½“å‰å®é™…ç´¢å¼•
                    var actualIndex = particles.indexOf(p);
                    if (actualIndex === -1) continue; // å·²è¢«ç§»é™¤

                    if (updateParticle(p, actualIndex)) {
                        drawParticle(p);
                    }
                }

                // æ›´æ–°å¹¶ç»˜åˆ¶ç¢ç‰‡
                for (var i = 0; i < fragments.length; i++) {
                    updateFragment(fragments[i]);
                    drawFragment(fragments[i]);
                }

                // æ£€æŸ¥æ±‡åˆ
                reuniteFragments();

            } catch (e) {
                console.error('Animation error:', e);
            }

            requestAnimationFrame(animate);
        }

        resizeCanvas();
        initParticles();
        animate();

        window.addEventListener('resize', resizeCanvas);

        // é¼ æ ‡è¿½è¸ªï¼šåœ¨Lå½¢åŒºåŸŸï¼ˆé¡¶æ å…¨å®½ + ä¾§è¾¹æ ï¼‰å†…ç”Ÿæ•ˆ + æ‰©å±•æ£€æµ‹èŒƒå›´
        document.addEventListener('mousemove', function(e) {
            var extend = 120; // æ‰©å±•æ£€æµ‹èŒƒå›´ï¼Œè®©é¼ æ ‡æ›´å®¹æ˜“è§¦å‘å°çƒé€ƒé€¸
            var inLShape = (e.clientY <= headerHeight + extend) || (e.clientX <= sidebarWidth + extend);
            if (inLShape) {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            } else {
                mouse.x = -1000;
                mouse.y = -1000;
            }
        });

        document.addEventListener('mouseleave', function() {
            mouse.x = -1000;
            mouse.y = -1000;
        });

        // ç‚¹å‡»é—ªç”µè®¾ç½®å°çƒå‚æ•° - è¡¨æ ¼å½¢å¼
        if (logo) {
            logo.addEventListener('click', function(e) {
                e.stopPropagation();

                // åˆ›å»ºè®¾ç½®å¼¹çª—
                var overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10000;display:flex;align-items:center;justify-content:center;';

                var cfg = window.ballConfig;
                var dialog = document.createElement('div');
                dialog.style.cssText = 'background:#1a1a2e;border:1px solid #333;border-radius:8px;padding:16px;min-width:280px;color:#fff;font-size:14px;';
                dialog.innerHTML =
                    '<div style="font-size:16px;font-weight:bold;margin-bottom:12px;color:#fbbf24;">âš¡ å°çƒè®¾ç½®</div>' +
                    '<table style="width:100%;border-collapse:collapse;">' +
                    '<tr><td style="padding:6px 8px;color:#aaa;">æ•°é‡</td><td><input id="cfg-count" type="number" min="1" max="20" value="' + particleCount + '" style="width:60px;padding:4px;background:#2a2a3e;border:1px solid #444;color:#fff;border-radius:4px;"></td><td style="padding:6px 8px;color:#666;font-size:12px;">å»ºè®®: 6</td></tr>' +
                    '<tr><td style="padding:6px 8px;color:#aaa;">æ„Ÿåº”åŠå¾„</td><td><input id="cfg-radius" type="number" min="50" max="200" value="' + cfg.repelRadius + '" style="width:60px;padding:4px;background:#2a2a3e;border:1px solid #444;color:#fff;border-radius:4px;"></td><td style="padding:6px 8px;color:#666;font-size:12px;">å»ºè®®: 180</td></tr>' +
                    '<tr><td style="padding:6px 8px;color:#aaa;">æ’æ–¥åŠ›åº¦</td><td><input id="cfg-force" type="number" min="1" max="15" value="' + cfg.repelForce + '" style="width:60px;padding:4px;background:#2a2a3e;border:1px solid #444;color:#fff;border-radius:4px;"></td><td style="padding:6px 8px;color:#666;font-size:12px;">å»ºè®®: 12</td></tr>' +
                    '<tr><td style="padding:6px 8px;color:#aaa;">æœ€å¤§é€Ÿåº¦</td><td><input id="cfg-speed" type="number" min="3" max="12" value="' + cfg.maxSpeed + '" style="width:60px;padding:4px;background:#2a2a3e;border:1px solid #444;color:#fff;border-radius:4px;"></td><td style="padding:6px 8px;color:#666;font-size:12px;">å»ºè®®: 10</td></tr>' +
                    '<tr><td style="padding:6px 8px;color:#aaa;">æ‘©æ“¦åŠ›</td><td><input id="cfg-friction" type="number" min="0.9" max="0.999" step="0.01" value="' + cfg.friction + '" style="width:60px;padding:4px;background:#2a2a3e;border:1px solid #444;color:#fff;border-radius:4px;"></td><td style="padding:6px 8px;color:#666;font-size:12px;">å»ºè®®: 0.97</td></tr>' +
                    '<tr><td style="padding:6px 8px;color:#aaa;">å°¾å·´é•¿åº¦</td><td><input id="cfg-tail" type="number" min="3" max="25" value="' + cfg.tailLength + '" style="width:60px;padding:4px;background:#2a2a3e;border:1px solid #444;color:#fff;border-radius:4px;"></td><td style="padding:6px 8px;color:#666;font-size:12px;">å»ºè®®: 5</td></tr>' +
                    '</table>' +
                    '<div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end;">' +
                    '<button id="cfg-cancel" style="padding:6px 12px;background:#444;border:none;color:#fff;border-radius:4px;cursor:pointer;">å–æ¶ˆ</button>' +
                    '<button id="cfg-save" style="padding:6px 12px;background:#fbbf24;border:none;color:#000;border-radius:4px;cursor:pointer;font-weight:bold;">ä¿å­˜</button>' +
                    '</div>';

                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                // ç‚¹å‡»èƒŒæ™¯å…³é—­
                overlay.addEventListener('click', function(ev) {
                    if (ev.target === overlay) document.body.removeChild(overlay);
                });

                // å–æ¶ˆæŒ‰é’®
                document.getElementById('cfg-cancel').addEventListener('click', function() {
                    document.body.removeChild(overlay);
                });

                // ä¿å­˜æŒ‰é’®
                document.getElementById('cfg-save').addEventListener('click', function() {
                    var newCount = Math.max(1, Math.min(20, parseInt(document.getElementById('cfg-count').value) || 5));
                    cfg.repelRadius = Math.max(50, Math.min(200, parseInt(document.getElementById('cfg-radius').value) || 100));
                    cfg.repelForce = Math.max(1, Math.min(15, parseInt(document.getElementById('cfg-force').value) || 5));
                    cfg.maxSpeed = Math.max(3, Math.min(12, parseInt(document.getElementById('cfg-speed').value) || 5));
                    cfg.friction = Math.max(0.9, Math.min(0.999, parseFloat(document.getElementById('cfg-friction').value) || 0.99));
                    cfg.tailLength = Math.max(5, Math.min(25, parseInt(document.getElementById('cfg-tail').value) || 12));

                    if (newCount !== particleCount) {
                        particleCount = newCount;
                        localStorage.setItem('particleCount', newCount);
                        initParticles();
                    }

                    document.body.removeChild(overlay);
                });
            });
        }
    })();

    // Sync Status Indicator
    (function() {
        var syncStatus = document.getElementById('sync-status');
        var syncText = syncStatus.querySelector('.sync-text');
        var hideTimeout = null;

        window.showSyncStatus = function(status, message) {
            syncStatus.className = 'sync-status visible ' + status;
            syncText.textContent = message || (status === 'syncing' ? 'ä¿å­˜ä¸­...' : status === 'synced' ? 'å·²ä¿å­˜' : 'ä¿å­˜å¤±è´¥');

            if (hideTimeout) clearTimeout(hideTimeout);
            if (status !== 'syncing') {
                hideTimeout = setTimeout(function() {
                    syncStatus.classList.remove('visible');
                }, 2000);
            }
        };
    })();

    // Pomodoro Timer
    (function() {
        var fab = document.getElementById('pomodoro-fab');
        var panel = document.getElementById('pomodoro-panel');
        var timeDisplay = document.getElementById('pomodoro-time');
        var labelDisplay = document.getElementById('pomodoro-label');
        var startBtn = document.getElementById('pomodoro-start');
        var resetBtn = document.getElementById('pomodoro-reset');

        var WORK_TIME = 25 * 60;
        var BREAK_TIME = 5 * 60;
        var timeLeft = WORK_TIME;
        var isRunning = false;
        var isBreak = false;
        var interval = null;

        function formatTime(seconds) {
            var m = Math.floor(seconds / 60).toString().padStart(2, '0');
            var s = (seconds % 60).toString().padStart(2, '0');
            return m + ':' + s;
        }

        function updateDisplay() {
            timeDisplay.textContent = formatTime(timeLeft);
            labelDisplay.textContent = isBreak ? 'ä¼‘æ¯æ—¶é—´' : 'ä¸“æ³¨æ—¶é—´';
            fab.classList.toggle('active', isRunning);
        }

        function tick() {
            if (timeLeft > 0) {
                timeLeft--;
                updateDisplay();
            } else {
                // Timer finished
                clearInterval(interval);
                isRunning = false;

                // Notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification(isBreak ? 'ä¼‘æ¯ç»“æŸï¼' : 'ä¸“æ³¨æ—¶é—´ç»“æŸï¼', {
                        body: isBreak ? 'å¼€å§‹æ–°ä¸€è½®ä¸“æ³¨å§' : 'ä¼‘æ¯ä¸€ä¸‹å§',
                        icon: '/assets/icons/icon-192.png'
                    });
                }

                // Vibrate if supported
                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                // Switch mode
                isBreak = !isBreak;
                timeLeft = isBreak ? BREAK_TIME : WORK_TIME;
                updateDisplay();
                startBtn.textContent = 'å¼€å§‹';
            }
        }

        function toggleTimer() {
            if (isRunning) {
                clearInterval(interval);
                isRunning = false;
                startBtn.textContent = 'ç»§ç»­';
            } else {
                interval = setInterval(tick, 1000);
                isRunning = true;
                startBtn.textContent = 'æš‚åœ';
            }
            updateDisplay();
        }

        function resetTimer() {
            clearInterval(interval);
            isRunning = false;
            isBreak = false;
            timeLeft = WORK_TIME;
            startBtn.textContent = 'å¼€å§‹';
            updateDisplay();
        }

        fab.addEventListener('click', function() {
            panel.classList.toggle('visible');
        });

        startBtn.addEventListener('click', toggleTimer);
        resetBtn.addEventListener('click', resetTimer);

        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }

        updateDisplay();

        // Expose for keyboard shortcut
        window.togglePomodoro = function() {
            panel.classList.toggle('visible');
        };
    })();

    // Focus Mode
    (function() {
        window.toggleFocusMode = function() {
            document.body.classList.toggle('focus-mode');
        };
    })();

    // Keyboard Shortcuts
    (function() {
        var shortcutsModal = document.getElementById('shortcuts-modal');

        function isInputFocused() {
            var active = document.activeElement;
            return active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable);
        }

        document.addEventListener('keydown', function(e) {
            // Ignore if typing in input
            if (isInputFocused() && e.key !== 'Escape') return;

            switch(e.key.toLowerCase()) {
                case 'n':
                    e.preventDefault();
                    if (typeof showAddModal === 'function') showAddModal();
                    break;
                case 's':
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        var searchInput = document.getElementById('search-input');
                        if (searchInput) searchInput.focus();
                    }
                    break;
                case '1':
                    e.preventDefault();
                    if (typeof switchTab === 'function') switchTab('today');
                    break;
                case '2':
                    e.preventDefault();
                    if (typeof switchTab === 'function') switchTab('week');
                    break;
                case '3':
                    e.preventDefault();
                    if (typeof switchTab === 'function') switchTab('month');
                    break;
                case 'd':
                    e.preventDefault();
                    if (typeof toggleTheme === 'function') toggleTheme();
                    break;
                case 'f':
                    e.preventDefault();
                    if (typeof toggleFocusMode === 'function') toggleFocusMode();
                    break;
                case 'p':
                    e.preventDefault();
                    if (typeof togglePomodoro === 'function') togglePomodoro();
                    break;
                case 'w':
                    e.preventDefault();
                    if (typeof toggleWeatherEffect === 'function') toggleWeatherEffect();
                    break;
                case '?':
                    e.preventDefault();
                    shortcutsModal.classList.toggle('visible');
                    break;
                case 'escape':
                    // Close any open modal
                    shortcutsModal.classList.remove('visible');
                    document.body.classList.remove('focus-mode');
                    var addModal = document.getElementById('add-modal');
                    if (addModal) addModal.style.display = 'none';
                    break;
            }
        });

        // Close shortcuts modal on click outside
        shortcutsModal.addEventListener('click', function(e) {
            if (e.target === shortcutsModal) {
                shortcutsModal.classList.remove('visible');
            }
        });
    })();

    // Enhanced API wrapper with sync status
    (function() {
        var originalFetch = window.fetch;
        window.fetch = function(url, options) {
            // Only track mutating requests
            var method = options && options.method ? options.method.toUpperCase() : 'GET';
            var isMutating = ['POST', 'PUT', 'DELETE', 'PATCH'].indexOf(method) >= 0;

            if (isMutating && typeof showSyncStatus === 'function') {
                showSyncStatus('syncing');
            }

            return originalFetch.apply(this, arguments)
                .then(function(response) {
                    if (isMutating && typeof showSyncStatus === 'function') {
                        showSyncStatus(response.ok ? 'synced' : 'error');
                    }
                    return response;
                })
                .catch(function(error) {
                    if (isMutating && typeof showSyncStatus === 'function') {
                        showSyncStatus('error', 'ç½‘ç»œé”™è¯¯');
                    }
                    throw error;
                });
        };
    })();

    // Original sidebar/pet script
    (function() {
        var sidebar = document.getElementById('sidebar');
        var mainContent = document.getElementById('main-content');
        var pet = document.getElementById('pet');
        var navLinks = document.querySelector('.nav-links');
        var sidebarHint = document.getElementById('sidebar-hint');

        var isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';

        // å°å® ç‰©çŠ¶æ€
        var targetY = window.innerHeight / 2;
        var currentY = targetY;
        var petHeight = 80;
        var sidebarWidth = 220;
        var isFollowing = false;
        var returnTimer = null;
        var isReturning = false;

        // å‚æ•°
        var closeDistance = 20;
        var rushEasing = 0.3;      // å†²åˆºæ—¶æ¯å¸§ç§»åŠ¨30%çš„å‰©ä½™è·ç¦»
        var gentleEasing = 0.1;    // é è¿‘æ—¶æ¯å¸§ç§»åŠ¨10%çš„å‰©ä½™è·ç¦»

        // è·å–éœ€è¦é¿è®©çš„åŒºåŸŸï¼ˆå¯¼èˆªæŒ‰é’®åŒºåŸŸï¼‰
        function getAvoidZones() {
            var zones = [];
            if (navLinks && !isCollapsed) {
                var rect = navLinks.getBoundingClientRect();
                zones.push({ top: rect.top - 10, bottom: rect.bottom + 10 });
            }
            return zones;
        }

        // æ£€æŸ¥æ˜¯å¦åœ¨é¿è®©åŒºåŸŸ
        function isInAvoidZone(y) {
            var zones = getAvoidZones();
            var petTop = y - petHeight / 2;
            var petBottom = y + petHeight / 2;
            for (var i = 0; i < zones.length; i++) {
                if (petBottom > zones[i].top && petTop < zones[i].bottom) {
                    return true;
                }
            }
            return false;
        }

        function collapseSidebar() {
            isCollapsed = true;
            sidebar.classList.add('collapsed');
            mainContent.classList.add('expanded');
            pet.classList.add('at-edge');
            pet.classList.remove('at-sidebar');
            pet.classList.remove('slim');
            sidebarHint.classList.add('visible');
            localStorage.setItem('sidebarCollapsed', 'true');
            // æ›´æ–° quick-add-bar ä½ç½®
            var quickAddBar = document.querySelector('.quick-add-bar');
            if (quickAddBar) quickAddBar.classList.add('expanded');
        }

        function expandSidebar() {
            isCollapsed = false;
            sidebar.classList.remove('collapsed');
            mainContent.classList.remove('expanded');
            pet.classList.remove('at-edge');
            pet.classList.add('at-sidebar');
            sidebarHint.classList.remove('visible');
            localStorage.setItem('sidebarCollapsed', 'false');
            // æ›´æ–° quick-add-bar ä½ç½®
            var quickAddBar = document.querySelector('.quick-add-bar');
            if (quickAddBar) quickAddBar.classList.remove('expanded');
        }

        // åˆå§‹åŒ–
        if (isCollapsed) {
            collapseSidebar();
        } else {
            pet.classList.add('at-sidebar');
        }
        // ç§»é™¤æ—©æœŸåº”ç”¨çš„ä¸´æ—¶ç±»ï¼ŒJS å·²æ¥ç®¡çŠ¶æ€ç®¡ç†
        document.documentElement.classList.remove('sidebar-will-collapse');

        pet.addEventListener('click', function() {
            if (isCollapsed) {
                expandSidebar();
            } else {
                collapseSidebar();
            }
        });

        // é¼ æ ‡è·Ÿè¸ª
        document.addEventListener('mousemove', function(e) {
            var petX = isCollapsed ? 0 : sidebarWidth;
            var activeZone = petX + 100;

            if (e.clientX < activeZone) {
                isFollowing = true;
                isReturning = false;
                targetY = e.clientY;
                pet.classList.add('active');

                if (returnTimer) {
                    clearTimeout(returnTimer);
                    returnTimer = null;
                }
            } else if (isFollowing) {
                isFollowing = false;
                pet.classList.remove('active');
                pet.classList.remove('excited');

                returnTimer = setTimeout(function() {
                    isReturning = true;
                    targetY = window.innerHeight / 2;
                }, 600);
            }
        });

        // åŠ¨ç”»å¾ªç¯
        function animatePet() {
            var distance = targetY - currentY;
            var absDistance = Math.abs(distance);
            var moveAmount = 0;

            if (isFollowing) {
                if (absDistance > closeDistance) {
                    // ç–¯ç‹‚å†²åˆºï¼šæ¯å¸§ç§»åŠ¨30%çš„å‰©ä½™è·ç¦»ï¼Œæé€Ÿå“åº”
                    moveAmount = distance * rushEasing;
                    pet.classList.add('excited');
                } else {
                    // æ¸©æŸ”é è¿‘ï¼šæ¯å¸§ç§»åŠ¨10%çš„å‰©ä½™è·ç¦»
                    moveAmount = distance * gentleEasing;
                    pet.classList.remove('excited');
                }
            } else if (isReturning) {
                // è¿”å›ä¸­å¿ƒï¼šç¼“æ…¢ç§»åŠ¨
                moveAmount = distance * 0.04;
                pet.classList.remove('excited');
            }

            currentY += moveAmount;

            // è¾¹ç•Œ (è€ƒè™‘48pxé¡¶éƒ¨å¯¼èˆªæ )
            var minY = petHeight / 2 + 48 + 10;
            var maxY = window.innerHeight - petHeight / 2 - 20;
            currentY = Math.max(minY, Math.min(maxY, currentY));

            // æ£€æŸ¥æ˜¯å¦éœ€è¦ç˜¦èº«é¿è®©
            if (isInAvoidZone(currentY)) {
                pet.classList.add('slim');
            } else {
                pet.classList.remove('slim');
            }

            pet.style.top = currentY + 'px';
            requestAnimationFrame(animatePet);
        }

        animatePet();

        window.addEventListener('resize', function() {
            if (!isFollowing) {
                targetY = window.innerHeight / 2;
            }
        });
    })();

    // TabæŒ‰é’®å‘¼å¸æ•ˆæœ
    (function() {
        var tabBtns = document.querySelectorAll('.tab-btn');
        tabBtns.forEach(function(btn) {
            btn.addEventListener('mouseenter', function() {
                btn.classList.remove('fade-out');
                btn.classList.add('breathing');
            });
            btn.addEventListener('mouseleave', function() {
                btn.classList.remove('breathing');
                btn.classList.add('fade-out');
                setTimeout(function() {
                    btn.classList.remove('fade-out');
                }, 2000);
            });
        });
    })();

    // æ—¶åŒºæ›´æ–°
    (function() {
        var weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];

        function formatTz(date) {
            var m = date.getMonth() + 1;
            var d = date.getDate();
            var w = weekdays[date.getDay()];
            var h = date.getHours().toString().padStart(2, '0');
            var min = date.getMinutes().toString().padStart(2, '0');
            return {
                date: m + '/' + d + ' å‘¨' + w,
                time: h + ':' + min
            };
        }

        function updateTimezones() {
            var now = new Date();

            // åŒ—äº¬æ—¶é—´
            var beijing = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Shanghai' }));
            var bjFmt = formatTz(beijing);
            document.getElementById('tz-beijing-date').textContent = bjFmt.date;
            document.getElementById('tz-beijing-time').textContent = bjFmt.time;

            // æ»‘é“å¢æ—¶é—´
            var waterloo = new Date(now.toLocaleString('en-US', { timeZone: 'America/Toronto' }));
            var wtFmt = formatTz(waterloo);
            document.getElementById('tz-waterloo-date').textContent = wtFmt.date;
            document.getElementById('tz-waterloo-time').textContent = wtFmt.time;

            // æ¸©å“¥åæ—¶é—´
            var vancouver = new Date(now.toLocaleString('en-US', { timeZone: 'America/Vancouver' }));
            var vcFmt = formatTz(vancouver);
            document.getElementById('tz-vancouver-date').textContent = vcFmt.date;
            document.getElementById('tz-vancouver-time').textContent = vcFmt.time;
        }

        updateTimezones();
        setInterval(updateTimezones, 1000);
    })();

    // å¤©æ°”æ˜¾ç¤ºä¸å°é±¼åŠ¨ç”»è”åŠ¨
    (function() {
        // å…¨å±€å¤©æ°”çŠ¶æ€ï¼ˆä¾›å°é±¼åŠ¨ç”»ä½¿ç”¨ï¼‰
        window.currentWeather = {
            type: 'cloudy',  // sunny, cloudy, rainy, snowy, stormy
            temp: '--',
            updated: false
        };

        function updateWeather() {
            fetch('/api/weather')
                .then(function(res) { return res.json(); })
                .then(function(data) {
                    var icon = document.getElementById('weather-icon');
                    var temp = document.getElementById('weather-temp');
                    var desc = document.getElementById('weather-desc');

                    if (icon) icon.textContent = data.icon || 'â˜ï¸';
                    if (temp) temp.textContent = (data.temp_c || '--') + 'Â°C';
                    if (desc) desc.textContent = data.description || 'æ— æ³•è·å–';

                    // æ›´æ–°å¤©æ°”é¢æ¿æ ·å¼ç±»
                    var panel = document.getElementById('weather-panel');
                    if (panel) {
                        panel.classList.remove('sunny', 'cloudy', 'rainy', 'snowy', 'stormy');
                        panel.classList.add(data.weather_type || 'cloudy');
                    }

                    // æ›´æ–°å…¨å±€å¤©æ°”çŠ¶æ€
                    window.currentWeather.type = data.weather_type || 'cloudy';
                    window.currentWeather.temp = data.temp_c;
                    window.currentWeather.updated = true;

                    // è§¦å‘å¤©æ°”å˜åŒ–äº‹ä»¶ï¼ˆå°é±¼åŠ¨ç”»ç›‘å¬ï¼‰
                    window.dispatchEvent(new CustomEvent('weatherUpdate', { detail: data }));
                })
                .catch(function(err) {
                    console.log('Weather fetch error:', err);
                    var desc = document.getElementById('weather-desc');
                    if (desc) desc.textContent = 'æ— æ³•è·å–';
                });
        }

        // åˆå§‹åŠ è½½å’Œå®šæ—¶æ›´æ–°ï¼ˆ10åˆ†é’Ÿï¼‰
        updateWeather();
        setInterval(updateWeather, 600000);
    })();

    // å¤©æ°”ç‰¹æ•ˆå¼€å…³æ§åˆ¶
    (function() {
        var toggleBtn = document.getElementById('weather-toggle-fab');
        var iconSpan = toggleBtn.querySelector('.weather-toggle-icon');

        // å¤©æ°”ç±»å‹å¯¹åº”çš„å›¾æ ‡
        var weatherIcons = {
            sunny: 'â˜€ï¸',
            cloudy: 'â˜ï¸',
            rainy: 'ğŸŒ§ï¸',
            snowy: 'â„ï¸',
            stormy: 'â›ˆï¸'
        };

        // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
        function initToggleState() {
            var enabled = localStorage.getItem('weatherEffectEnabled') !== 'false';
            if (enabled) {
                toggleBtn.classList.remove('disabled');
            } else {
                toggleBtn.classList.add('disabled');
            }
            updateToggleIcon();
        }

        // æ›´æ–°æŒ‰é’®å›¾æ ‡ï¼ˆæ ¹æ®å½“å‰å¤©æ°”ç±»å‹ï¼‰
        function updateToggleIcon() {
            var weatherType = (window.currentWeather && window.currentWeather.type) || 'cloudy';
            iconSpan.textContent = weatherIcons[weatherType] || 'â˜ï¸';
        }

        // åˆ‡æ¢å¤©æ°”ç‰¹æ•ˆ
        function toggleWeatherEffect() {
            var enabled = localStorage.getItem('weatherEffectEnabled') !== 'false';
            enabled = !enabled;

            localStorage.setItem('weatherEffectEnabled', enabled ? 'true' : 'false');

            // æ›´æ–°å…¨å±€å˜é‡ï¼ˆå°é±¼åŠ¨ç”»ä½¿ç”¨ï¼‰
            if (typeof weatherEffectEnabled !== 'undefined') {
                weatherEffectEnabled = enabled;
            }

            // æ›´æ–°æŒ‰é’®æ ·å¼
            if (enabled) {
                toggleBtn.classList.remove('disabled');
            } else {
                toggleBtn.classList.add('disabled');
            }

            // æ˜¾ç¤ºæç¤º
            if (window.AppUtils && window.AppUtils.showToast) {
                window.AppUtils.showToast(enabled ? 'å¤©æ°”ç‰¹æ•ˆå·²å¼€å¯' : 'å¤©æ°”ç‰¹æ•ˆå·²å…³é—­', 'success');
            }
        }

        // ç»‘å®šç‚¹å‡»äº‹ä»¶
        toggleBtn.addEventListener('click', toggleWeatherEffect);

        // ç›‘å¬å¤©æ°”æ›´æ–°äº‹ä»¶ï¼Œæ›´æ–°å›¾æ ‡
        window.addEventListener('weatherUpdate', function() {
            updateToggleIcon();
        });

        // åˆå§‹åŒ–
        initToggleState();

        // æš´éœ²åˆ‡æ¢å‡½æ•°ä¾›å¿«æ·é”®ä½¿ç”¨
        window.toggleWeatherEffect = toggleWeatherEffect;
    })();

    // Register Service Worker for PWA
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js')
            .then(function(reg) {
                console.log('Service Worker registered:', reg.scope);
            })
            .catch(function(err) {
                console.log('Service Worker registration failed:', err);
            });
    }
    </script>
</body>
</html>
