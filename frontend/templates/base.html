<!DOCTYPE html>
<html lang="zh-CN" data-theme="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Boris Life">
    <title>{% block title %}Boris Life{% endblock %}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/base.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/assets/icons/icon-192.png">
    <script>
    // æ—©æœŸæ‰§è¡Œï¼šåœ¨é¡µé¢æ¸²æŸ“å‰åº”ç”¨ä¸»é¢˜å’Œä¾§è¾¹æ çŠ¶æ€ï¼Œé¿å…é—ªçƒ
    (function() {
        var theme = localStorage.getItem('theme');
        if (theme) {
            document.documentElement.setAttribute('data-theme', theme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.setAttribute('data-theme', 'dark');
        }
        // é€šè¿‡ CSS ç±»æå‰æ ‡è®°ä¾§è¾¹æ çŠ¶æ€
        if (localStorage.getItem('sidebarCollapsed') === 'true') {
            document.documentElement.classList.add('sidebar-will-collapse');
        }
    })();
    </script>
    <style>
    /* é˜²æ­¢ä¾§è¾¹æ çŠ¶æ€åˆ‡æ¢æ—¶é—ªçƒ */
    html.sidebar-will-collapse .sidebar {
        transform: translateX(-100%);
        opacity: 0;
    }
    html.sidebar-will-collapse .main-content {
        margin-left: 0;
    }
    html.sidebar-will-collapse .sidebar-hint {
        opacity: 1;
    }
    </style>
</head>
<body>
    <!-- ç²’å­åŠ¨ç”»ç”»å¸ƒï¼ˆè¦†ç›–é¡¶æ +ä¾§è¾¹æ çš„Lå½¢åŒºåŸŸï¼‰ -->
    <canvas id="header-particles" class="particles-canvas-extended"></canvas>

    <!-- GitHubé£æ ¼é¡¶éƒ¨å¯¼èˆªæ  -->
    <header class="top-header" id="top-header">
        <div class="header-left">
            <button class="header-menu-btn" id="header-menu-btn" title="èœå•">
                <span class="menu-icon">â˜°</span>
            </button>
            <span class="header-logo" id="header-logo" title="ç‚¹å‡»è®¾ç½®å°çƒæ•°é‡" style="cursor:pointer;">âš¡</span>
            <span class="header-title">Boris Life</span>
        </div>
        <div class="header-right">
            <div class="header-avatar" id="header-avatar" onclick="nextAvatarQuote()">
                <span class="avatar-text">B</span>
                <div class="avatar-quote-tooltip" id="avatar-quote-tooltip">
                    <div class="quote-content" id="avatar-quote-content">Loading...</div>
                    <div class="quote-hint">ç‚¹å‡»æ¢ä¸€å¥</div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- å·¦ä¾§æç¤ºæ¡ - ä¾§è¾¹æ æ”¶èµ·æ—¶æ˜¾ç¤º -->
        <div class="sidebar-hint" id="sidebar-hint">
            <div class="hint-glow"></div>
        </div>

        <!-- å°å® ç‰© - å§‹ç»ˆå¯è§ -->
        <div class="pet" id="pet">
            <div class="pet-eye"></div>
            <div class="pet-eye"></div>
            <div class="pet-eye"></div>
        </div>


        <!-- Left Sidebar -->
        <nav class="sidebar" id="sidebar">
            <div class="nav-links">
                <a href="{{ url_for('main') }}" class="nav-link {% if current_page == 'main' %}active{% endif %}">ä¸»é¡µ</a>
                <a href="{{ url_for('todo') }}" class="nav-link {% if current_page == 'todo' %}active{% endif %}">Todo</a>
                <a href="{{ url_for('motivation') }}" class="nav-link {% if current_page == 'motivation' %}active{% endif %}">ç¨‹åºå‘˜é¼“åŠ±å¤§å¸ˆ</a>
                <a href="{{ url_for('toolbox') }}" class="nav-link {% if current_page == 'toolbox' %}active{% endif %}">å·¥å…·ç®±</a>
                <a href="{{ url_for('game') }}" class="nav-link {% if current_page == 'game' %}active{% endif %}">æ¾å¼€ä½ çš„å¤§è„‘</a>
                <a href="{{ url_for('leader') }}" class="nav-link {% if current_page == 'leader' %}active{% endif %}">é¢†è¢–åŸ¹è®­ç­</a>
                <a href="{{ url_for('english') }}" class="nav-link {% if current_page == 'english' %}active{% endif %}">è‹±æ–‡å­¦ä¹ å¤©åœ°</a>
                <a href="{{ url_for('aichat') }}" class="nav-link ai-link {% if current_page == 'aichat' %}active{% endif %}">
                    <span class="ai-glow"></span>
                    æ™ºè„‘ä¸­æ¢
                </a>
            </div>

            <!-- åº•éƒ¨åŒºåŸŸï¼šå¾…æ‰§è¡Œprompt + promptå†å²è®°å½• + æ—¶åŒº -->
            <div class="sidebar-bottom">
                <a href="{{ url_for('prompt_todo') }}" class="prompt-log-link {% if current_page == 'prompt_todo' %}active{% endif %}">
                    <span class="prompt-icon">ğŸ“‹</span>
                    <span>å¾…æ‰§è¡Œprompt</span>
                </a>
                <a href="{{ url_for('prompts') }}" class="prompt-log-link {% if current_page == 'prompts' %}active{% endif %}">
                    <span class="prompt-icon">ğŸ“œ</span>
                    <span>promptå†å²è®°å½•</span>
                </a>
                <div class="sidebar-divider"></div>
            </div>

            <!-- æ—¶åŒºæ˜¾ç¤º - ä¾§è¾¹æ åº•éƒ¨ -->
            <div class="timezone-panel" id="timezone-panel">
                <div class="timezone-item">
                    <span class="tz-city">åŒ—äº¬</span>
                    <div class="tz-info">
                        <span class="tz-datetime" id="tz-beijing-date"></span>
                        <span class="tz-time" id="tz-beijing-time"></span>
                    </div>
                </div>
                <div class="timezone-item">
                    <span class="tz-city">æ»‘é“å¢</span>
                    <div class="tz-info">
                        <span class="tz-datetime" id="tz-waterloo-date"></span>
                        <span class="tz-time" id="tz-waterloo-time"></span>
                    </div>
                </div>
                <div class="timezone-item">
                    <span class="tz-city">æ¸©å“¥å</span>
                    <div class="tz-info">
                        <span class="tz-datetime" id="tz-vancouver-date"></span>
                        <span class="tz-time" id="tz-vancouver-time"></span>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Right Main Content -->
        <main class="main-content" id="main-content">
            {% block content %}{% endblock %}
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="theme-toggle" title="åˆ‡æ¢ä¸»é¢˜ (D)">
        <span class="icon-sun">â˜€ï¸</span>
        <span class="icon-moon">ğŸŒ™</span>
    </button>

    <!-- Sync Status Indicator -->
    <div class="sync-status" id="sync-status">
        <span class="sync-dot"></span>
        <span class="sync-text">å·²ä¿å­˜</span>
    </div>

    <!-- Focus Mode Indicator -->
    <div class="focus-mode-indicator" id="focus-indicator">
        ğŸ¯ ä¸“æ³¨æ¨¡å¼ Â· æŒ‰ Esc é€€å‡º
    </div>

    <!-- Pomodoro Timer FAB -->
    <button class="pomodoro-fab" id="pomodoro-fab" title="ç•ªèŒ„é’Ÿ (P)">ğŸ…</button>
    <div class="pomodoro-panel" id="pomodoro-panel">
        <div class="pomodoro-time" id="pomodoro-time">25:00</div>
        <div class="pomodoro-label" id="pomodoro-label">ä¸“æ³¨æ—¶é—´</div>
        <div class="pomodoro-controls">
            <button class="pomodoro-btn pomodoro-btn-start" id="pomodoro-start">å¼€å§‹</button>
            <button class="pomodoro-btn pomodoro-btn-reset" id="pomodoro-reset">é‡ç½®</button>
        </div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="shortcuts-modal" id="shortcuts-modal">
        <div class="shortcuts-content">
            <div class="shortcuts-title">âŒ¨ï¸ é”®ç›˜å¿«æ·é”®</div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>N</kbd></span>
                <span class="shortcut-desc">æ–°å»ºä»»åŠ¡</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>S</kbd></span>
                <span class="shortcut-desc">æœç´¢ä»»åŠ¡</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd></span>
                <span class="shortcut-desc">åˆ‡æ¢æ ‡ç­¾é¡µ</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>D</kbd></span>
                <span class="shortcut-desc">åˆ‡æ¢æ·±è‰²æ¨¡å¼</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>F</kbd></span>
                <span class="shortcut-desc">ä¸“æ³¨æ¨¡å¼</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>P</kbd></span>
                <span class="shortcut-desc">ç•ªèŒ„é’Ÿ</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>?</kbd></span>
                <span class="shortcut-desc">æ˜¾ç¤ºå¿«æ·é”®</span>
            </div>
            <div class="shortcut-item">
                <span class="shortcut-key"><kbd>Esc</kbd></span>
                <span class="shortcut-desc">å…³é—­å¼¹çª—</span>
            </div>
        </div>
    </div>

    <!-- Gesture Hint -->
    <div class="gesture-hint" id="gesture-hint"></div>

    <script>
    // ============================================
    // Global Feature Scripts
    // ============================================

    // Theme Management
    (function() {
        var themeToggle = document.getElementById('theme-toggle');
        var html = document.documentElement;

        // Load saved theme or detect system preference
        function initTheme() {
            var saved = localStorage.getItem('theme');
            if (saved) {
                html.setAttribute('data-theme', saved);
            } else {
                // Check system preference
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    html.setAttribute('data-theme', 'dark');
                }
            }
        }

        function toggleTheme() {
            var current = html.getAttribute('data-theme');
            var newTheme = current === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        themeToggle.addEventListener('click', toggleTheme);
        initTheme();

        // Expose for keyboard shortcut
        window.toggleTheme = toggleTheme;
    })();

    // å¤´åƒåè¨€åŠŸèƒ½
    (function() {
        var avatarQuotes = [
            "ä»£ç å¦‚è¯—ï¼Œä¼˜é›…è€Œç®€æ´ã€‚",
            "ä»Šå¤©çš„bugï¼Œæ˜¯æ˜å¤©çš„featureã€‚",
            "å…ˆè®©å®ƒå·¥ä½œï¼Œå†è®©å®ƒä¼˜é›…ã€‚",
            "ç®€å•æ˜¯æœ€ç»ˆçš„å¤æ‚ã€‚",
            "å¥½çš„ä»£ç æ˜¯è‡ªå·±çš„æœ€ä½³æ–‡æ¡£ã€‚",
            "è°ƒè¯•æ˜¯å†™ä»£ç æ—¶æ²¡åšçš„äº‹ã€‚",
            "ä¿æŒå­¦ä¹ ï¼Œä¿æŒè°¦é€Šã€‚",
            "ä¸€æ¬¡åªåšä¸€ä»¶äº‹ï¼Œåšåˆ°æè‡´ã€‚",
            "è½¯ä»¶å¼€å‘æ˜¯ä¸€åœºé©¬æ‹‰æ¾ï¼Œä¸æ˜¯çŸ­è·‘ã€‚",
            "æœ€å¥½çš„é”™è¯¯å¤„ç†æ˜¯ä¸è®©é”™è¯¯å‘ç”Ÿã€‚",
            "é‡æ„æ˜¯å¼€å‘è€…çš„æ—¥å¸¸ä¿®è¡Œã€‚",
            "æµ‹è¯•ä¸æ˜¯æ‰¾bugï¼Œæ˜¯è¯æ˜ä»£ç æ­£ç¡®ã€‚",
            "ä»£ç å†™ç»™äººçœ‹ï¼Œé¡ºä¾¿è®©æœºå™¨æ‰§è¡Œã€‚",
            "æ°¸è¿œä¸è¦ç›¸ä¿¡ç”¨æˆ·è¾“å…¥ã€‚",
            "æå‰ä¼˜åŒ–æ˜¯ä¸‡æ¶ä¹‹æºã€‚",
            "å¤åˆ¶ç²˜è´´æ˜¯æŠ€æœ¯å€ºçš„å¼€å§‹ã€‚"
        ];
        var currentQuoteIndex = Math.floor(Math.random() * avatarQuotes.length);
        var quoteContent = document.getElementById('avatar-quote-content');

        function updateQuote() {
            if (quoteContent) {
                quoteContent.textContent = '"' + avatarQuotes[currentQuoteIndex] + '"';
            }
        }

        window.nextAvatarQuote = function() {
            currentQuoteIndex = (currentQuoteIndex + 1) % avatarQuotes.length;
            updateQuote();
        };

        updateQuote();
    })();

    // Top Header - æ»šåŠ¨éšè—
    (function() {
        var header = document.getElementById('top-header');
        var menuBtn = document.getElementById('header-menu-btn');
        var lastScrollTop = 0;
        var scrollThreshold = 60;

        // æ»šåŠ¨æ—¶éšè—/æ˜¾ç¤ºé¡¶éƒ¨æ 
        window.addEventListener('scroll', function() {
            var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > lastScrollTop && scrollTop > scrollThreshold) {
                // å‘ä¸‹æ»šåŠ¨ï¼Œéšè—
                header.classList.add('hidden');
            } else {
                // å‘ä¸Šæ»šåŠ¨æˆ–æ¥è¿‘é¡¶éƒ¨ï¼Œæ˜¾ç¤º
                header.classList.remove('hidden');
            }

            lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
        }, { passive: true });

        // èœå•æŒ‰é’®ç‚¹å‡» - åˆ‡æ¢ä¾§è¾¹æ 
        if (menuBtn) {
            menuBtn.addEventListener('click', function() {
                var pet = document.getElementById('pet');
                if (pet) pet.click();
            });
        }
    })();

    // Header Particles Animation (å®Œæ•´ç‰ˆï¼šå°¾å·´+æ’æ–¥+ææƒ§+çˆ†ç‚¸+æ±‡åˆ+ä¾§è¾¹æ è´¯é€š)
    (function() {
        var canvas = document.getElementById('header-particles');
        if (!canvas) return;
        var ctx = canvas.getContext('2d');
        var header = document.getElementById('top-header');
        var sidebar = document.getElementById('sidebar');
        var logo = document.getElementById('header-logo');

        // åŒºåŸŸé…ç½® - Lå½¢åŒºåŸŸï¼šé¡¶æ å…¨å®½ + ä¾§è¾¹æ 
        var headerHeight = 48;
        var sidebarWidth = 220;

        // ç²’å­é…ç½®
        var particles = [];
        var fragments = []; // çˆ†ç‚¸ç¢ç‰‡
        var fishes = []; // å°é±¼
        var fishFragments = []; // å°é±¼ç¢ç‰‡
        var particleCount = parseInt(localStorage.getItem('particleCount')) || 6;
        var fishCount = parseInt(localStorage.getItem('fishCount')) || 3;
        var maxTailLength = 12; // ç¼©çŸ­å°¾å·´æœ€å¤§é•¿åº¦
        var colors = ['#60a5fa', '#34d399', '#f87171', '#fbbf24', '#a78bfa', '#f472b6'];
        var fishColors = ['#ff9966', '#66ccff', '#99ff99']; // å°é±¼é¢œè‰²

        // é¼ æ ‡ä½ç½®
        var mouse = { x: -1000, y: -1000 };
        var mouseRepelRadius = 100;
        var mouseRepelForce = 4;

        // ææƒ§ä¸çˆ†ç‚¸é…ç½®
        var fearThreshold = 60; // å¼€å§‹éœ‡åŠ¨çš„å¸§æ•°
        var explodeThreshold = 150; // çˆ†ç‚¸çš„å¸§æ•°
        var reuniteDelay = 120; // æ±‡åˆå»¶è¿Ÿå¸§æ•°

        function resizeCanvas() {
            // å…¨å±å®½åº¦ä»¥æ”¯æŒLå½¢åŒºåŸŸ
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨Lå½¢åŒºåŸŸå†…
        function isInLShape(x, y) {
            return y <= headerHeight || x <= sidebarWidth;
        }

        // è·å–Lå½¢åŒºåŸŸçš„æœ‰æ•ˆè¾¹ç•Œ
        function getLShapeBounds(y) {
            if (y <= headerHeight) {
                return { minX: 0, maxX: canvas.width };
            } else {
                return { minX: 0, maxX: sidebarWidth };
            }
        }

        function createParticle(index, x, y, radius) {
            var baseAngle = Math.random() < 0.5 ? 0 : Math.PI;
            var angle = baseAngle + (Math.random() - 0.5) * Math.PI / 3;
            var speed = 0.3 + Math.random() * 0.3;
            // å¤§éƒ¨åˆ†ç²’å­ç”Ÿæˆåœ¨é¡¶æ åŒºåŸŸï¼ˆ80%æ¦‚ç‡ï¼‰
            var spawnInHeader = Math.random() < 0.8;
            var spawnX = x !== undefined ? x : (spawnInHeader ? Math.random() * canvas.width : Math.random() * sidebarWidth);
            var spawnY = y !== undefined ? y : (spawnInHeader ? Math.random() * headerHeight : headerHeight + Math.random() * (canvas.height - headerHeight));
            return {
                x: spawnX, y: spawnY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius || (4 + Math.random() * 3),
                color: colors[index % colors.length],
                alpha: 0.7 + Math.random() * 0.2,
                trail: [],
                stuckTime: 0,
                isShaking: false,
                shakeOffset: { x: 0, y: 0 },
                targetAngle: angle,
                turnSpeed: 0.015 + Math.random() * 0.015,
                nextTurnTime: 100 + Math.floor(Math.random() * 150)
            };
        }

        function initParticles() {
            particles = [];
            fragments = [];
            fishes = [];
            fishFragments = [];
            for (var i = 0; i < particleCount; i++) {
                particles.push(createParticle(i));
            }
            for (var i = 0; i < fishCount; i++) {
                fishes.push(createFish(i));
            }
        }

        function createFish(index, x, y, size) {
            var direction = Math.random() < 0.5 ? 1 : -1;
            var facingAngle = direction > 0 ? 0 : Math.PI;
            var spawnInHeader = Math.random() < 0.8;
            var spawnX = x !== undefined ? x : (spawnInHeader ? Math.random() * canvas.width : Math.random() * sidebarWidth);
            var spawnY = y !== undefined ? y : (spawnInHeader ? 8 + Math.random() * (headerHeight - 16) : headerHeight + Math.random() * (canvas.height - headerHeight - 16));
            var fishSize = size || (6 + Math.random() * 3);
            return {
                x: spawnX, y: spawnY,
                vx: direction * (0.4 + Math.random() * 0.3),
                vy: (Math.random() - 0.5) * 0.1,
                size: fishSize,
                color: fishColors[index % fishColors.length],
                tailPhase: Math.random() * Math.PI * 2,
                direction: direction,
                facingAngle: facingAngle,
                angle: facingAngle,
                backwardTime: 0,
                turnSpeed: 0.15,
                isEscaping: false,
                escapePhase: 0,
                stuckTime: 0,
                isShaking: false,
                shakeOffset: { x: 0, y: 0 }
            };
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= Math.PI * 2;
            while (angle < -Math.PI) angle += Math.PI * 2;
            return angle;
        }

        // æ£€æµ‹é±¼æ˜¯å¦è¢«å›°
        function isFishStuckAtEdge(f) {
            var edgeMargin = f.size + 5;
            var bounds = getLShapeBounds(f.y);
            var nearEdge = f.x < edgeMargin || f.x > bounds.maxX - edgeMargin ||
                           f.y < edgeMargin || f.y > canvas.height - edgeMargin;
            var dx = f.x - mouse.x;
            var dy = f.y - mouse.y;
            var nearMouse = Math.sqrt(dx * dx + dy * dy) < mouseRepelRadius + 20;
            return nearEdge && nearMouse;
        }

        // å°é±¼çˆ†ç‚¸
        function explodeFish(f, index) {
            for (var i = 0; i < 3; i++) {
                var angle = (Math.PI * 2 / 3) * i + Math.random() * 0.5;
                var speed = 2 + Math.random() * 1.5;
                fishFragments.push({
                    x: f.x, y: f.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: f.size * 0.5,
                    color: f.color,
                    tailPhase: Math.random() * Math.PI * 2,
                    angle: angle,
                    life: reuniteDelay,
                    parentIndex: index,
                    ignoreMouseTime: 40
                });
            }
            fishes.splice(index, 1);
        }

        // å°é±¼æ±‡åˆ
        function reuniteFishFragments() {
            var groups = {};
            fishFragments.forEach(function(f, i) {
                if (!groups[f.parentIndex]) groups[f.parentIndex] = [];
                groups[f.parentIndex].push({ fragment: f, index: i });
            });
            var toRemove = [];
            for (var parentIndex in groups) {
                var group = groups[parentIndex];
                if (group.length > 0 && group[0].fragment.life <= 0) {
                    var cx = 0, cy = 0;
                    group.forEach(function(g) { cx += g.fragment.x; cy += g.fragment.y; });
                    cx /= group.length; cy /= group.length;
                    var newFish = createFish(parseInt(parentIndex), cx, cy);
                    newFish.vx = (Math.random() - 0.5) * 1.5;
                    newFish.vy = (Math.random() - 0.5) * 1.5;
                    fishes.push(newFish);
                    group.forEach(function(g) { toRemove.push(g.index); });
                }
            }
            toRemove.sort(function(a, b) { return b - a; });
            toRemove.forEach(function(i) { fishFragments.splice(i, 1); });
        }

        function updateFish(f, index) {
            f.tailPhase += 0.15;
            var dx = f.x - mouse.x;
            var dy = f.y - mouse.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var escapeAngle = Math.atan2(dy, dx);
            var velocityAngle = Math.atan2(f.vy, f.vx);

            // é¼ æ ‡æ’æ–¥ä¸æ™ºèƒ½é€ƒé€¸
            if (dist < mouseRepelRadius && dist > 0) {
                f.isEscaping = true;
                var angleDiff = normalizeAngle(escapeAngle - f.facingAngle);
                var isFacingAway = Math.abs(angleDiff) < Math.PI / 2;

                if (isFacingAway) {
                    f.escapePhase = 0;
                    var force = (mouseRepelRadius - dist) / mouseRepelRadius * 6;
                    f.vx += (dx / dist) * force;
                    f.vy += (dy / dist) * force;
                } else {
                    if (f.escapePhase === 0) {
                        f.escapePhase = 1;
                        f.backwardTime = 0;
                    }
                    if (f.escapePhase === 1) {
                        f.backwardTime++;
                        var backwardForce = (mouseRepelRadius - dist) / mouseRepelRadius * 3;
                        f.vx += (dx / dist) * backwardForce;
                        f.vy += (dy / dist) * backwardForce;
                        if (f.backwardTime > 15 || dist < mouseRepelRadius * 0.5) {
                            f.escapePhase = 2;
                        }
                    }
                    if (f.escapePhase === 2) {
                        var turnAmount = normalizeAngle(escapeAngle - f.facingAngle) * 0.3;
                        f.facingAngle = normalizeAngle(f.facingAngle + turnAmount);
                        var force = (mouseRepelRadius - dist) / mouseRepelRadius * 5;
                        f.vx += (dx / dist) * force;
                        f.vy += (dy / dist) * force;
                        if (Math.abs(normalizeAngle(escapeAngle - f.facingAngle)) < Math.PI / 4) {
                            f.escapePhase = 0;
                        }
                    }
                }
            } else {
                f.isEscaping = false;
                f.escapePhase = 0;
                f.backwardTime = 0;
            }

            if (isFishStuckAtEdge(f)) {
                f.stuckTime++;
                if (f.stuckTime > fearThreshold) {
                    f.isShaking = true;
                    f.shakeOffset = { x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3 };
                }
                if (f.stuckTime > explodeThreshold) {
                    explodeFish(f, index);
                    return false;
                }
            } else {
                f.stuckTime = Math.max(0, f.stuckTime - 2);
                f.isShaking = false;
                f.shakeOffset = { x: 0, y: 0 };
            }

            var inHeader = f.y <= headerHeight;
            if (inHeader) {
                f.vy += (Math.random() - 0.5) * 0.02;
                f.vy *= 0.95;
            } else {
                f.vx += (Math.random() - 0.5) * 0.03;
                f.vy += (Math.random() - 0.5) * 0.03;
            }
            f.x += f.vx;
            f.y += f.vy;

            var speed = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
            if (speed < 0.3) {
                var angle = inHeader ? (Math.random() < 0.5 ? 0 : Math.PI) : Math.random() * Math.PI * 2;
                f.vx = Math.cos(angle) * 0.5;
                f.vy = Math.sin(angle) * 0.5;
            }
            var maxSpeed = 4;
            if (speed > maxSpeed) {
                f.vx = (f.vx / speed) * maxSpeed;
                f.vy = (f.vy / speed) * maxSpeed;
            }
            f.vx *= 0.995;
            f.vy *= 0.995;

            // Lå½¢æ‹è§’å¤„ç†
            if (f.y > headerHeight && f.x > sidebarWidth - f.size) {
                var overY = f.y - headerHeight;
                var overX = f.x - (sidebarWidth - f.size);
                if (overY < overX) {
                    f.y = headerHeight - f.size;
                    f.vy = -Math.abs(f.vy);
                } else {
                    f.x = sidebarWidth - f.size;
                    f.vx = -Math.abs(f.vx);
                }
            }
            var bounds = getLShapeBounds(f.y);
            if (f.x < f.size) { f.x = f.size; f.vx = Math.abs(f.vx); }
            else if (f.x > bounds.maxX - f.size) { f.x = bounds.maxX - f.size; f.vx = -Math.abs(f.vx); }
            if (f.y < f.size) { f.y = f.size; f.vy = Math.abs(f.vy); }
            else if (f.y > canvas.height - f.size) { f.y = canvas.height - f.size; f.vy = -Math.abs(f.vy); }

            // æ›´æ–°é±¼å¤´æœå‘
            velocityAngle = Math.atan2(f.vy, f.vx);
            if (!f.isEscaping || f.escapePhase === 0) {
                var targetAngle = velocityAngle;
                var angleDiff = normalizeAngle(targetAngle - f.facingAngle);
                var isBackward = Math.abs(angleDiff) > Math.PI / 2;
                if (isBackward) {
                    f.backwardTime++;
                    if (f.backwardTime > 30) {
                        f.facingAngle = normalizeAngle(f.facingAngle + angleDiff * 0.2);
                    }
                } else {
                    f.backwardTime = Math.max(0, f.backwardTime - 1);
                    f.facingAngle = normalizeAngle(f.facingAngle + angleDiff * f.turnSpeed);
                }
            }

            f.angle = f.facingAngle;
            f.direction = Math.cos(f.angle) >= 0 ? 1 : -1;
            return true;
        }

        function updateFishFragment(ff) {
            ff.tailPhase += 0.2;
            if (ff.ignoreMouseTime > 0) ff.ignoreMouseTime--;
            else {
                var dx = ff.x - mouse.x;
                var dy = ff.y - mouse.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < mouseRepelRadius && dist > 0) {
                    var force = (mouseRepelRadius - dist) / mouseRepelRadius * 0.5;
                    ff.vx += (dx / dist) * force;
                    ff.vy += (dy / dist) * force;
                }
            }
            ff.vx *= 0.98; ff.vy *= 0.98;
            ff.x += ff.vx; ff.y += ff.vy;
            ff.life--;
            ff.angle = Math.atan2(ff.vy, ff.vx);
            // Lå½¢æ‹è§’å¤„ç†
            if (ff.y > headerHeight && ff.x > sidebarWidth - ff.size) {
                var overY = ff.y - headerHeight;
                var overX = ff.x - (sidebarWidth - ff.size);
                if (overY < overX) {
                    ff.y = headerHeight - ff.size;
                    ff.vy = -Math.abs(ff.vy);
                } else {
                    ff.x = sidebarWidth - ff.size;
                    ff.vx = -Math.abs(ff.vx);
                }
            }
            var bounds = getLShapeBounds(ff.y);
            if (ff.x < ff.size || ff.x > bounds.maxX - ff.size) {
                ff.vx = -ff.vx;
                ff.x = Math.max(ff.size, Math.min(bounds.maxX - ff.size, ff.x));
            }
            if (ff.y < ff.size || ff.y > canvas.height - ff.size) {
                ff.vy = -ff.vy;
                ff.y = Math.max(ff.size, Math.min(canvas.height - ff.size, ff.y));
            }
        }

        function drawFish(f) {
            var transMult = getTransparencyMultiplier(f.y);
            var drawX = f.x + (f.shakeOffset ? f.shakeOffset.x : 0);
            var drawY = f.y + (f.shakeOffset ? f.shakeOffset.y : 0);
            ctx.save();
            ctx.translate(drawX, drawY);
            var angle = f.angle || 0;
            var flipY = Math.abs(angle) > Math.PI / 2;
            if (flipY) { ctx.rotate(angle + Math.PI); ctx.scale(1, -1); }
            else { ctx.rotate(angle); }
            var s = f.size;
            var tailSwing = Math.sin(f.tailPhase) * 0.3;
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.2, s * 0.6, 0, 0, Math.PI * 2);
            ctx.fillStyle = f.color;
            ctx.globalAlpha = 0.85 * transMult;
            if (f.isShaking) { ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 15; }
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.moveTo(-s * 1.1, 0);
            ctx.lineTo(-s * 2, -s * 0.5 + tailSwing * s);
            ctx.lineTo(-s * 2, s * 0.5 + tailSwing * s);
            ctx.closePath();
            ctx.fillStyle = f.color;
            ctx.globalAlpha = 0.7 * transMult;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.5, -s * 0.1, s * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 1 * transMult;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.55, -s * 0.1, s * 0.08, 0, Math.PI * 2);
            ctx.fillStyle = '#333333';
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function drawFishFragment(ff) {
            var transMult = getTransparencyMultiplier(ff.y) * (ff.life / reuniteDelay);
            ctx.save();
            ctx.translate(ff.x, ff.y);
            var angle = ff.angle || 0;
            var flipY = Math.abs(angle) > Math.PI / 2;
            if (flipY) { ctx.rotate(angle + Math.PI); ctx.scale(1, -1); }
            else { ctx.rotate(angle); }
            var s = ff.size;
            var tailSwing = Math.sin(ff.tailPhase) * 0.4;
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.2, s * 0.6, 0, 0, Math.PI * 2);
            ctx.fillStyle = ff.color;
            ctx.globalAlpha = 0.8 * transMult;
            ctx.shadowColor = ff.color;
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.moveTo(-s * 1.1, 0);
            ctx.lineTo(-s * 2, -s * 0.5 + tailSwing * s);
            ctx.lineTo(-s * 2, s * 0.5 + tailSwing * s);
            ctx.closePath();
            ctx.globalAlpha = 0.6 * transMult;
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }

        function isStuckAtEdge(p) {
            var edgeMargin = p.radius + 5;
            var bounds = getLShapeBounds(p.y);
            var nearEdge = p.x < edgeMargin || p.x > bounds.maxX - edgeMargin ||
                           p.y < edgeMargin || p.y > canvas.height - edgeMargin;
            var dx = p.x - mouse.x;
            var dy = p.y - mouse.y;
            var nearMouse = Math.sqrt(dx * dx + dy * dy) < mouseRepelRadius + 20;
            return nearEdge && nearMouse;
        }

        // çˆ†ç‚¸åˆ†è£‚
        function explodeParticle(p, index) {
            var fragmentColors = [colors[(index) % colors.length], colors[(index + 2) % colors.length], colors[(index + 4) % colors.length]];
            for (var i = 0; i < 3; i++) {
                var angle = (Math.PI * 2 / 3) * i + Math.random() * 0.5;
                var speed = 3 + Math.random() * 2;
                fragments.push({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: p.radius * 0.5,
                    color: fragmentColors[i],
                    alpha: 0.9,
                    trail: [],
                    life: reuniteDelay,
                    parentIndex: index,
                    ignoreMouseTime: 40 // æ— è§†é¼ æ ‡çš„æ—¶é—´
                });
            }
            // ç§»é™¤åŸç²’å­
            particles.splice(index, 1);
        }

        // ç¢ç‰‡æ±‡åˆé‡ç»„
        function reuniteFragments() {
            var groups = {};
            fragments.forEach(function(f, i) {
                if (!groups[f.parentIndex]) groups[f.parentIndex] = [];
                groups[f.parentIndex].push({ fragment: f, index: i });
            });

            var toRemove = [];
            for (var parentIndex in groups) {
                var group = groups[parentIndex];
                if (group.length > 0 && group[0].fragment.life <= 0) {
                    // è®¡ç®—æ±‡åˆä¸­å¿ƒ
                    var cx = 0, cy = 0;
                    group.forEach(function(g) { cx += g.fragment.x; cy += g.fragment.y; });
                    cx /= group.length;
                    cy /= group.length;

                    // åˆ›å»ºæ–°ç²’å­
                    var newP = createParticle(parseInt(parentIndex), cx, cy);
                    newP.vx = (Math.random() - 0.5) * 2;
                    newP.vy = (Math.random() - 0.5) * 2;
                    particles.push(newP);

                    // æ ‡è®°ç§»é™¤ç¢ç‰‡
                    group.forEach(function(g) { toRemove.push(g.index); });
                }
            }
            // ä»åå¾€å‰ç§»é™¤
            toRemove.sort(function(a, b) { return b - a; });
            toRemove.forEach(function(i) { fragments.splice(i, 1); });
        }

        function updateParticle(p, index) {
            // è®¡ç®—å½“å‰é€Ÿåº¦
            var speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);

            // å°¾å·´é•¿åº¦ï¼šåŸºç¡€é•¿åº¦ + é€Ÿåº¦åŠ æˆ
            var dynamicTailLength = Math.floor(5 + speed * 2);
            dynamicTailLength = Math.max(5, Math.min(maxTailLength, dynamicTailLength));

            p.trail.push({ x: p.x, y: p.y });
            while (p.trail.length > dynamicTailLength) p.trail.shift();

            // æ£€æµ‹æ˜¯å¦è¢«å›°
            if (isStuckAtEdge(p)) {
                p.stuckTime++;
                if (p.stuckTime > fearThreshold) {
                    p.isShaking = true;
                    p.shakeOffset.x = (Math.random() - 0.5) * 3;
                    p.shakeOffset.y = (Math.random() - 0.5) * 3;
                }
                if (p.stuckTime > explodeThreshold) {
                    explodeParticle(p, index);
                    return false; // ç²’å­å·²ç§»é™¤
                }
            } else {
                p.stuckTime = Math.max(0, p.stuckTime - 2);
                p.isShaking = false;
                p.shakeOffset.x = 0;
                p.shakeOffset.y = 0;
            }

            // é¼ æ ‡æ’æ–¥ï¼ˆå°çƒå¿«é€Ÿé€ƒé€¸ï¼‰
            var dx = p.x - mouse.x;
            var dy = p.y - mouse.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var isEscaping = dist < mouseRepelRadius && dist > 0;

            if (isEscaping) {
                var force = (mouseRepelRadius - dist) / mouseRepelRadius * 10; // å¤§å¹…å¢å¼ºé€ƒé€¸åŠ›åº¦
                p.vx += (dx / dist) * force;
                p.vy += (dy / dist) * force;
            }

            var inHeader = p.y <= headerHeight;

            // åªåœ¨éé€ƒé€¸æ—¶è¿›è¡Œå¹³æ»‘è½¬å‘
            if (!isEscaping) {
                p.nextTurnTime--;
                if (p.nextTurnTime <= 0) {
                    var currentAngle = Math.atan2(p.vy, p.vx);
                    if (inHeader) {
                        if (Math.random() < 0.7) {
                            var baseAngle = Math.cos(currentAngle) > 0 ? 0 : Math.PI;
                            if (Math.random() < 0.15) baseAngle += Math.PI;
                            p.targetAngle = baseAngle + (Math.random() - 0.5) * Math.PI / 3;
                        } else {
                            p.targetAngle = currentAngle + (Math.random() - 0.5) * Math.PI * 0.4;
                        }
                    } else {
                        p.targetAngle = Math.random() * Math.PI * 2;
                    }
                    p.nextTurnTime = 80 + Math.floor(Math.random() * 120);
                }

                var currentAngle = Math.atan2(p.vy, p.vx);
                var angleDiff = p.targetAngle - currentAngle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                if (Math.abs(angleDiff) > 0.01) {
                    var newAngle = currentAngle + angleDiff * p.turnSpeed;
                    var targetSpeed = 0.4 + Math.random() * 0.3;
                    p.vx = Math.cos(newAngle) * Math.max(speed, targetSpeed);
                    p.vy = Math.sin(newAngle) * Math.max(speed, targetSpeed);
                }
            }

            if (inHeader) p.vy *= 0.95;

            // é€Ÿåº¦è§„åˆ™
            speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            var maxSpeed = 5, minSpeed = 0.3; // æé«˜æœ€å¤§é€Ÿåº¦åˆ°5
            if (speed > maxSpeed) {
                p.vx = (p.vx / speed) * maxSpeed;
                p.vy = (p.vy / speed) * maxSpeed;
            } else if (speed < minSpeed) {
                var angle = inHeader ? (Math.random() < 0.5 ? 0 : Math.PI) : Math.random() * Math.PI * 2;
                p.vx = Math.cos(angle) * 0.5;
                p.vy = Math.sin(angle) * 0.5;
            }

            p.vx *= 0.995; // ä¸å°é±¼ä¸€è‡´
            p.vy *= 0.995;

            p.x += p.vx;
            p.y += p.vy;

            // Lå½¢è¾¹ç¼˜å¹³æ»‘åå¼¹
            var bounced = false;

            // é¦–å…ˆå¤„ç†Lå½¢æ‹è§’ï¼šæ£€æµ‹æ˜¯å¦è¿›å…¥ç¦åŒºï¼ˆy > headerHeight ä¸” x > sidebarWidthï¼‰
            if (p.y > headerHeight && p.x > sidebarWidth - p.radius) {
                var overY = p.y - headerHeight;
                var overX = p.x - (sidebarWidth - p.radius);
                if (overY < overX) {
                    p.y = headerHeight - p.radius;
                    p.vy = -Math.abs(p.vy);
                } else {
                    p.x = sidebarWidth - p.radius;
                    p.vx = -Math.abs(p.vx);
                }
                bounced = true;
            }

            // å¸¸è§„è¾¹ç•Œæ£€æŸ¥
            var bounds = getLShapeBounds(p.y);
            if (p.x - p.radius < 0) {
                p.x = p.radius;
                p.vx = Math.abs(p.vx);
                bounced = true;
            } else if (p.x + p.radius > bounds.maxX) {
                p.x = bounds.maxX - p.radius;
                p.vx = -Math.abs(p.vx);
                bounced = true;
            }
            if (p.y - p.radius < 0) {
                p.y = p.radius;
                p.vy = Math.abs(p.vy);
                bounced = true;
            } else if (p.y + p.radius > canvas.height) {
                p.y = canvas.height - p.radius;
                p.vy = -Math.abs(p.vy);
                bounced = true;
            }
            if (bounced) {
                p.targetAngle = Math.atan2(p.vy, p.vx);
            }

            return true;
        }

        function updateFragment(f) {
            f.trail.push({ x: f.x, y: f.y });
            if (f.trail.length > 8) f.trail.shift();

            if (f.ignoreMouseTime > 0) {
                f.ignoreMouseTime--;
            } else {
                var dx = f.x - mouse.x;
                var dy = f.y - mouse.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < mouseRepelRadius && dist > 0) {
                    var force = (mouseRepelRadius - dist) / mouseRepelRadius * 0.5;
                    f.vx += (dx / dist) * force;
                    f.vy += (dy / dist) * force;
                }
            }

            f.vx *= 0.98;
            f.vy *= 0.98;
            f.x += f.vx;
            f.y += f.vy;
            f.life--;

            // Lå½¢æ‹è§’å¤„ç†
            if (f.y > headerHeight && f.x > sidebarWidth - f.radius) {
                var overY = f.y - headerHeight;
                var overX = f.x - (sidebarWidth - f.radius);
                if (overY < overX) {
                    f.y = headerHeight - f.radius;
                    f.vy = -Math.abs(f.vy);
                } else {
                    f.x = sidebarWidth - f.radius;
                    f.vx = -Math.abs(f.vx);
                }
            }

            // Lå½¢è¾¹ç•Œ
            var bounds = getLShapeBounds(f.y);
            if (f.x - f.radius < 0 || f.x + f.radius > bounds.maxX) {
                f.vx = -f.vx;
                f.x = Math.max(f.radius, Math.min(bounds.maxX - f.radius, f.x));
            }
            if (f.y - f.radius < 0 || f.y + f.radius > canvas.height) {
                f.vy = -f.vy;
                f.y = Math.max(f.radius, Math.min(canvas.height - f.radius, f.y));
            }
        }

        // è®¡ç®—é€æ˜åº¦ç³»æ•°ï¼ˆåœ¨ä¾§è¾¹æ åŒºåŸŸæ—¶å˜é€æ˜ï¼‰
        function getTransparencyMultiplier(y) {
            if (y <= headerHeight) return 1; // é¡¶æ åŒºåŸŸï¼šå®Œå…¨ä¸é€æ˜
            // ä¾§è¾¹æ åŒºåŸŸï¼šæ¸å˜åˆ°50%é€æ˜
            var fadeStart = headerHeight;
            var fadeEnd = headerHeight + 50;
            if (y < fadeEnd) {
                return 1 - 0.5 * ((y - fadeStart) / (fadeEnd - fadeStart));
            }
            return 0.5; // ä¾§è¾¹æ æ·±å¤„ï¼š50%é€æ˜
        }

        function drawParticle(p) {
            var drawX = p.x + (p.shakeOffset ? p.shakeOffset.x : 0);
            var drawY = p.y + (p.shakeOffset ? p.shakeOffset.y : 0);
            var transMult = getTransparencyMultiplier(drawY);

            // å½—æ˜Ÿå°¾å·´æ•ˆæœï¼šä»å¤´éƒ¨å‘å°¾éƒ¨é€æ¸å˜å°å˜æ·¡
            if (p.trail.length > 1) {
                for (var i = 0; i < p.trail.length; i++) {
                    var t = p.trail[i];
                    var progress = (i + 1) / p.trail.length; // 0â†’1ï¼Œå°¾éƒ¨æ˜¯0ï¼Œå¤´éƒ¨æ˜¯1
                    var trailTrans = getTransparencyMultiplier(t.y);
                    var size = p.radius * progress * 0.8; // å°¾éƒ¨å°ï¼Œå¤´éƒ¨å¤§
                    var alpha = p.alpha * progress * progress * 0.5; // å°¾éƒ¨æ·¡ï¼Œå¤´éƒ¨äº®
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = alpha * trailTrans;
                    ctx.fill();
                }
            }

            // ä¸»çƒä½“ï¼ˆéœ‡åŠ¨æ—¶å¸¦çº¢è‰²å…‰æ™•ï¼‰
            ctx.beginPath();
            ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.alpha * transMult;
            ctx.shadowColor = p.isShaking ? '#ff0000' : p.color;
            ctx.shadowBlur = p.isShaking ? 15 : 10;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function drawFragment(f) {
            var transMult = getTransparencyMultiplier(f.y);
            // å°¾å·´
            for (var i = 0; i < f.trail.length; i++) {
                var t = f.trail[i];
                var progress = i / f.trail.length;
                var trailTrans = getTransparencyMultiplier(t.y);
                ctx.beginPath();
                ctx.arc(t.x, t.y, f.radius * progress * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = f.color;
                ctx.globalAlpha = f.alpha * progress * 0.4 * trailTrans;
                ctx.fill();
            }
            // ç¢ç‰‡
            ctx.beginPath();
            ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
            ctx.fillStyle = f.color;
            ctx.globalAlpha = f.alpha * (f.life / reuniteDelay) * transMult;
            ctx.shadowColor = f.color;
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // æ›´æ–°å¹¶ç»˜åˆ¶å°é±¼ï¼ˆå€’åºéå†ä»¥ä¾¿å®‰å…¨åˆ é™¤ï¼‰
            for (var i = fishes.length - 1; i >= 0; i--) {
                if (updateFish(fishes[i], i)) {
                    drawFish(fishes[i]);
                }
            }

            // æ›´æ–°å¹¶ç»˜åˆ¶å°é±¼ç¢ç‰‡
            fishFragments.forEach(function(ff) {
                updateFishFragment(ff);
                drawFishFragment(ff);
            });

            // æ£€æŸ¥å°é±¼æ±‡åˆ
            reuniteFishFragments();

            // æ›´æ–°å¹¶ç»˜åˆ¶ç²’å­ï¼ˆå€’åºéå†ä»¥ä¾¿å®‰å…¨åˆ é™¤ï¼‰
            for (var i = particles.length - 1; i >= 0; i--) {
                if (updateParticle(particles[i], i)) {
                    drawParticle(particles[i]);
                }
            }

            // æ›´æ–°å¹¶ç»˜åˆ¶ç¢ç‰‡
            fragments.forEach(function(f) {
                updateFragment(f);
                drawFragment(f);
            });

            // æ£€æŸ¥æ±‡åˆ
            reuniteFragments();

            requestAnimationFrame(animate);
        }

        resizeCanvas();
        initParticles();
        animate();

        window.addEventListener('resize', resizeCanvas);

        // é¼ æ ‡è¿½è¸ªï¼šåœ¨Lå½¢åŒºåŸŸï¼ˆé¡¶æ å…¨å®½ + ä¾§è¾¹æ ï¼‰å†…ç”Ÿæ•ˆ
        document.addEventListener('mousemove', function(e) {
            var inLShape = (e.clientY <= headerHeight) || (e.clientX <= sidebarWidth);
            if (inLShape) {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            } else {
                mouse.x = -1000;
                mouse.y = -1000;
            }
        });

        document.addEventListener('mouseleave', function() {
            mouse.x = -1000;
            mouse.y = -1000;
        });

        // é—ªç”µç‚¹å‡»è®¾ç½®å°çƒå’Œå°é±¼æ•°é‡
        if (logo) {
            logo.addEventListener('click', function(e) {
                e.stopPropagation();
                var input = prompt('è®¾ç½®å°çƒæ•°é‡ (1-20)ï¼Œå½“å‰: ' + particleCount, particleCount);
                if (input !== null) {
                    var num = parseInt(input);
                    if (!isNaN(num) && num >= 1 && num <= 20) {
                        particleCount = num;
                        localStorage.setItem('particleCount', num);
                    }
                }
                var fishInput = prompt('è®¾ç½®å°é±¼æ•°é‡ (1-10)ï¼Œå½“å‰: ' + fishCount, fishCount);
                if (fishInput !== null) {
                    var fishNum = parseInt(fishInput);
                    if (!isNaN(fishNum) && fishNum >= 1 && fishNum <= 10) {
                        fishCount = fishNum;
                        localStorage.setItem('fishCount', fishNum);
                    }
                }
                initParticles();
            });
        }
    })();

    // Sync Status Indicator
    (function() {
        var syncStatus = document.getElementById('sync-status');
        var syncText = syncStatus.querySelector('.sync-text');
        var hideTimeout = null;

        window.showSyncStatus = function(status, message) {
            syncStatus.className = 'sync-status visible ' + status;
            syncText.textContent = message || (status === 'syncing' ? 'ä¿å­˜ä¸­...' : status === 'synced' ? 'å·²ä¿å­˜' : 'ä¿å­˜å¤±è´¥');

            if (hideTimeout) clearTimeout(hideTimeout);
            if (status !== 'syncing') {
                hideTimeout = setTimeout(function() {
                    syncStatus.classList.remove('visible');
                }, 2000);
            }
        };
    })();

    // Pomodoro Timer
    (function() {
        var fab = document.getElementById('pomodoro-fab');
        var panel = document.getElementById('pomodoro-panel');
        var timeDisplay = document.getElementById('pomodoro-time');
        var labelDisplay = document.getElementById('pomodoro-label');
        var startBtn = document.getElementById('pomodoro-start');
        var resetBtn = document.getElementById('pomodoro-reset');

        var WORK_TIME = 25 * 60;
        var BREAK_TIME = 5 * 60;
        var timeLeft = WORK_TIME;
        var isRunning = false;
        var isBreak = false;
        var interval = null;

        function formatTime(seconds) {
            var m = Math.floor(seconds / 60).toString().padStart(2, '0');
            var s = (seconds % 60).toString().padStart(2, '0');
            return m + ':' + s;
        }

        function updateDisplay() {
            timeDisplay.textContent = formatTime(timeLeft);
            labelDisplay.textContent = isBreak ? 'ä¼‘æ¯æ—¶é—´' : 'ä¸“æ³¨æ—¶é—´';
            fab.classList.toggle('active', isRunning);
        }

        function tick() {
            if (timeLeft > 0) {
                timeLeft--;
                updateDisplay();
            } else {
                // Timer finished
                clearInterval(interval);
                isRunning = false;

                // Notification
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification(isBreak ? 'ä¼‘æ¯ç»“æŸï¼' : 'ä¸“æ³¨æ—¶é—´ç»“æŸï¼', {
                        body: isBreak ? 'å¼€å§‹æ–°ä¸€è½®ä¸“æ³¨å§' : 'ä¼‘æ¯ä¸€ä¸‹å§',
                        icon: '/assets/icons/icon-192.png'
                    });
                }

                // Vibrate if supported
                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);

                // Switch mode
                isBreak = !isBreak;
                timeLeft = isBreak ? BREAK_TIME : WORK_TIME;
                updateDisplay();
                startBtn.textContent = 'å¼€å§‹';
            }
        }

        function toggleTimer() {
            if (isRunning) {
                clearInterval(interval);
                isRunning = false;
                startBtn.textContent = 'ç»§ç»­';
            } else {
                interval = setInterval(tick, 1000);
                isRunning = true;
                startBtn.textContent = 'æš‚åœ';
            }
            updateDisplay();
        }

        function resetTimer() {
            clearInterval(interval);
            isRunning = false;
            isBreak = false;
            timeLeft = WORK_TIME;
            startBtn.textContent = 'å¼€å§‹';
            updateDisplay();
        }

        fab.addEventListener('click', function() {
            panel.classList.toggle('visible');
        });

        startBtn.addEventListener('click', toggleTimer);
        resetBtn.addEventListener('click', resetTimer);

        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }

        updateDisplay();

        // Expose for keyboard shortcut
        window.togglePomodoro = function() {
            panel.classList.toggle('visible');
        };
    })();

    // Focus Mode
    (function() {
        window.toggleFocusMode = function() {
            document.body.classList.toggle('focus-mode');
        };
    })();

    // Keyboard Shortcuts
    (function() {
        var shortcutsModal = document.getElementById('shortcuts-modal');

        function isInputFocused() {
            var active = document.activeElement;
            return active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable);
        }

        document.addEventListener('keydown', function(e) {
            // Ignore if typing in input
            if (isInputFocused() && e.key !== 'Escape') return;

            switch(e.key.toLowerCase()) {
                case 'n':
                    e.preventDefault();
                    if (typeof showAddModal === 'function') showAddModal();
                    break;
                case 's':
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        var searchInput = document.getElementById('search-input');
                        if (searchInput) searchInput.focus();
                    }
                    break;
                case '1':
                    e.preventDefault();
                    if (typeof switchTab === 'function') switchTab('today');
                    break;
                case '2':
                    e.preventDefault();
                    if (typeof switchTab === 'function') switchTab('week');
                    break;
                case '3':
                    e.preventDefault();
                    if (typeof switchTab === 'function') switchTab('month');
                    break;
                case 'd':
                    e.preventDefault();
                    if (typeof toggleTheme === 'function') toggleTheme();
                    break;
                case 'f':
                    e.preventDefault();
                    if (typeof toggleFocusMode === 'function') toggleFocusMode();
                    break;
                case 'p':
                    e.preventDefault();
                    if (typeof togglePomodoro === 'function') togglePomodoro();
                    break;
                case '?':
                    e.preventDefault();
                    shortcutsModal.classList.toggle('visible');
                    break;
                case 'escape':
                    // Close any open modal
                    shortcutsModal.classList.remove('visible');
                    document.body.classList.remove('focus-mode');
                    var addModal = document.getElementById('add-modal');
                    if (addModal) addModal.style.display = 'none';
                    break;
            }
        });

        // Close shortcuts modal on click outside
        shortcutsModal.addEventListener('click', function(e) {
            if (e.target === shortcutsModal) {
                shortcutsModal.classList.remove('visible');
            }
        });
    })();

    // Enhanced API wrapper with sync status
    (function() {
        var originalFetch = window.fetch;
        window.fetch = function(url, options) {
            // Only track mutating requests
            var method = options && options.method ? options.method.toUpperCase() : 'GET';
            var isMutating = ['POST', 'PUT', 'DELETE', 'PATCH'].indexOf(method) >= 0;

            if (isMutating && typeof showSyncStatus === 'function') {
                showSyncStatus('syncing');
            }

            return originalFetch.apply(this, arguments)
                .then(function(response) {
                    if (isMutating && typeof showSyncStatus === 'function') {
                        showSyncStatus(response.ok ? 'synced' : 'error');
                    }
                    return response;
                })
                .catch(function(error) {
                    if (isMutating && typeof showSyncStatus === 'function') {
                        showSyncStatus('error', 'ç½‘ç»œé”™è¯¯');
                    }
                    throw error;
                });
        };
    })();

    // Original sidebar/pet script
    (function() {
        var sidebar = document.getElementById('sidebar');
        var mainContent = document.getElementById('main-content');
        var pet = document.getElementById('pet');
        var navLinks = document.querySelector('.nav-links');
        var sidebarHint = document.getElementById('sidebar-hint');

        var isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';

        // å°å® ç‰©çŠ¶æ€
        var targetY = window.innerHeight / 2;
        var currentY = targetY;
        var petHeight = 80;
        var sidebarWidth = 220;
        var isFollowing = false;
        var returnTimer = null;
        var isReturning = false;

        // å‚æ•°
        var closeDistance = 20;
        var rushEasing = 0.3;      // å†²åˆºæ—¶æ¯å¸§ç§»åŠ¨30%çš„å‰©ä½™è·ç¦»
        var gentleEasing = 0.1;    // é è¿‘æ—¶æ¯å¸§ç§»åŠ¨10%çš„å‰©ä½™è·ç¦»

        // è·å–éœ€è¦é¿è®©çš„åŒºåŸŸï¼ˆå¯¼èˆªæŒ‰é’®åŒºåŸŸï¼‰
        function getAvoidZones() {
            var zones = [];
            if (navLinks && !isCollapsed) {
                var rect = navLinks.getBoundingClientRect();
                zones.push({ top: rect.top - 10, bottom: rect.bottom + 10 });
            }
            return zones;
        }

        // æ£€æŸ¥æ˜¯å¦åœ¨é¿è®©åŒºåŸŸ
        function isInAvoidZone(y) {
            var zones = getAvoidZones();
            var petTop = y - petHeight / 2;
            var petBottom = y + petHeight / 2;
            for (var i = 0; i < zones.length; i++) {
                if (petBottom > zones[i].top && petTop < zones[i].bottom) {
                    return true;
                }
            }
            return false;
        }

        function collapseSidebar() {
            isCollapsed = true;
            sidebar.classList.add('collapsed');
            mainContent.classList.add('expanded');
            pet.classList.add('at-edge');
            pet.classList.remove('at-sidebar');
            pet.classList.remove('slim');
            sidebarHint.classList.add('visible');
            localStorage.setItem('sidebarCollapsed', 'true');
            // æ›´æ–° quick-add-bar ä½ç½®
            var quickAddBar = document.querySelector('.quick-add-bar');
            if (quickAddBar) quickAddBar.classList.add('expanded');
        }

        function expandSidebar() {
            isCollapsed = false;
            sidebar.classList.remove('collapsed');
            mainContent.classList.remove('expanded');
            pet.classList.remove('at-edge');
            pet.classList.add('at-sidebar');
            sidebarHint.classList.remove('visible');
            localStorage.setItem('sidebarCollapsed', 'false');
            // æ›´æ–° quick-add-bar ä½ç½®
            var quickAddBar = document.querySelector('.quick-add-bar');
            if (quickAddBar) quickAddBar.classList.remove('expanded');
        }

        // åˆå§‹åŒ–
        if (isCollapsed) {
            collapseSidebar();
        } else {
            pet.classList.add('at-sidebar');
        }
        // ç§»é™¤æ—©æœŸåº”ç”¨çš„ä¸´æ—¶ç±»ï¼ŒJS å·²æ¥ç®¡çŠ¶æ€ç®¡ç†
        document.documentElement.classList.remove('sidebar-will-collapse');

        pet.addEventListener('click', function() {
            if (isCollapsed) {
                expandSidebar();
            } else {
                collapseSidebar();
            }
        });

        // é¼ æ ‡è·Ÿè¸ª
        document.addEventListener('mousemove', function(e) {
            var petX = isCollapsed ? 0 : sidebarWidth;
            var activeZone = petX + 100;

            if (e.clientX < activeZone) {
                isFollowing = true;
                isReturning = false;
                targetY = e.clientY;
                pet.classList.add('active');

                if (returnTimer) {
                    clearTimeout(returnTimer);
                    returnTimer = null;
                }
            } else if (isFollowing) {
                isFollowing = false;
                pet.classList.remove('active');
                pet.classList.remove('excited');

                returnTimer = setTimeout(function() {
                    isReturning = true;
                    targetY = window.innerHeight / 2;
                }, 600);
            }
        });

        // åŠ¨ç”»å¾ªç¯
        function animatePet() {
            var distance = targetY - currentY;
            var absDistance = Math.abs(distance);
            var moveAmount = 0;

            if (isFollowing) {
                if (absDistance > closeDistance) {
                    // ç–¯ç‹‚å†²åˆºï¼šæ¯å¸§ç§»åŠ¨30%çš„å‰©ä½™è·ç¦»ï¼Œæé€Ÿå“åº”
                    moveAmount = distance * rushEasing;
                    pet.classList.add('excited');
                } else {
                    // æ¸©æŸ”é è¿‘ï¼šæ¯å¸§ç§»åŠ¨10%çš„å‰©ä½™è·ç¦»
                    moveAmount = distance * gentleEasing;
                    pet.classList.remove('excited');
                }
            } else if (isReturning) {
                // è¿”å›ä¸­å¿ƒï¼šç¼“æ…¢ç§»åŠ¨
                moveAmount = distance * 0.04;
                pet.classList.remove('excited');
            }

            currentY += moveAmount;

            // è¾¹ç•Œ (è€ƒè™‘48pxé¡¶éƒ¨å¯¼èˆªæ )
            var minY = petHeight / 2 + 48 + 10;
            var maxY = window.innerHeight - petHeight / 2 - 20;
            currentY = Math.max(minY, Math.min(maxY, currentY));

            // æ£€æŸ¥æ˜¯å¦éœ€è¦ç˜¦èº«é¿è®©
            if (isInAvoidZone(currentY)) {
                pet.classList.add('slim');
            } else {
                pet.classList.remove('slim');
            }

            pet.style.top = currentY + 'px';
            requestAnimationFrame(animatePet);
        }

        animatePet();

        window.addEventListener('resize', function() {
            if (!isFollowing) {
                targetY = window.innerHeight / 2;
            }
        });
    })();

    // TabæŒ‰é’®å‘¼å¸æ•ˆæœ
    (function() {
        var tabBtns = document.querySelectorAll('.tab-btn');
        tabBtns.forEach(function(btn) {
            btn.addEventListener('mouseenter', function() {
                btn.classList.remove('fade-out');
                btn.classList.add('breathing');
            });
            btn.addEventListener('mouseleave', function() {
                btn.classList.remove('breathing');
                btn.classList.add('fade-out');
                setTimeout(function() {
                    btn.classList.remove('fade-out');
                }, 2000);
            });
        });
    })();

    // æ—¶åŒºæ›´æ–°
    (function() {
        var weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];

        function formatTz(date) {
            var m = date.getMonth() + 1;
            var d = date.getDate();
            var w = weekdays[date.getDay()];
            var h = date.getHours().toString().padStart(2, '0');
            var min = date.getMinutes().toString().padStart(2, '0');
            return {
                date: m + '/' + d + ' å‘¨' + w,
                time: h + ':' + min
            };
        }

        function updateTimezones() {
            var now = new Date();

            // åŒ—äº¬æ—¶é—´
            var beijing = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Shanghai' }));
            var bjFmt = formatTz(beijing);
            document.getElementById('tz-beijing-date').textContent = bjFmt.date;
            document.getElementById('tz-beijing-time').textContent = bjFmt.time;

            // æ»‘é“å¢æ—¶é—´
            var waterloo = new Date(now.toLocaleString('en-US', { timeZone: 'America/Toronto' }));
            var wtFmt = formatTz(waterloo);
            document.getElementById('tz-waterloo-date').textContent = wtFmt.date;
            document.getElementById('tz-waterloo-time').textContent = wtFmt.time;

            // æ¸©å“¥åæ—¶é—´
            var vancouver = new Date(now.toLocaleString('en-US', { timeZone: 'America/Vancouver' }));
            var vcFmt = formatTz(vancouver);
            document.getElementById('tz-vancouver-date').textContent = vcFmt.date;
            document.getElementById('tz-vancouver-time').textContent = vcFmt.time;
        }

        updateTimezones();
        setInterval(updateTimezones, 1000);
    })();

    // Register Service Worker for PWA
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js')
            .then(function(reg) {
                console.log('Service Worker registered:', reg.scope);
            })
            .catch(function(err) {
                console.log('Service Worker registration failed:', err);
            });
    }
    </script>
</body>
</html>
