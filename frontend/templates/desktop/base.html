{% extends "shared/base_core.html" %}

{% block platform_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/desktop.css') }}">
{% endblock %}

{% block body_class %}platform-desktop{% endblock %}

{% block body_content %}
<!-- ç²’å­åŠ¨ç”»ç”»å¸ƒï¼ˆè¦†ç›–é¡¶æ +ä¾§è¾¹æ çš„Lå½¢åŒºåŸŸï¼‰ -->
<canvas id="header-particles" class="particles-canvas-extended"></canvas>

<!-- GitHubé£æ ¼é¡¶éƒ¨å¯¼èˆªæ  -->
<header class="top-header" id="top-header">
    <div class="header-left">
        <button class="header-menu-btn" id="header-menu-btn" title="èœå•">
            <span class="menu-icon">â˜°</span>
        </button>
        <span class="header-logo" id="header-logo" title="ç‚¹å‡»è®¾ç½®å°çƒæ•°é‡" style="cursor:pointer;">âš¡</span>
        <span class="header-title">Boris Life</span>
    </div>
    <div class="header-right">
        <div class="header-avatar" id="header-avatar" onclick="nextAvatarQuote()">
            <span class="avatar-text">B</span>
            <div class="avatar-quote-tooltip" id="avatar-quote-tooltip">
                <div class="quote-content" id="avatar-quote-content">Loading...</div>
                <div class="quote-hint">ç‚¹å‡»æ¢ä¸€å¥</div>
            </div>
        </div>
    </div>
</header>

<div class="container">
    <!-- å·¦ä¾§æç¤ºæ¡ - ä¾§è¾¹æ æ”¶èµ·æ—¶æ˜¾ç¤º -->
    <div class="sidebar-hint" id="sidebar-hint">
        <div class="hint-glow"></div>
    </div>

    <!-- å°å® ç‰© - å§‹ç»ˆå¯è§ -->
    <div class="pet" id="pet">
        <div class="pet-eye"></div>
        <div class="pet-eye"></div>
        <div class="pet-eye"></div>
    </div>

    <!-- Left Sidebar -->
    <nav class="sidebar" id="sidebar">
        <div class="nav-links">
            <a href="{{ url_for('main') }}" class="nav-link {% if current_page == 'main' %}active{% endif %}">ä¸»é¡µ</a>
            <a href="{{ url_for('todo') }}" class="nav-link {% if current_page == 'todo' %}active{% endif %}">Todo</a>
            <a href="{{ url_for('motivation') }}" class="nav-link {% if current_page == 'motivation' %}active{% endif %}">ç¨‹åºå‘˜é¼“åŠ±å¤§å¸ˆ</a>
            <a href="{{ url_for('bubble') }}" class="nav-link {% if current_page == 'bubble' %}active{% endif %}">æ°”æ³¡å›¾å·¥å…·</a>
            <a href="{{ url_for('game') }}" class="nav-link {% if current_page == 'game' %}active{% endif %}">æ¾å¼€ä½ çš„å¤§è„‘</a>
            <a href="{{ url_for('leader') }}" class="nav-link {% if current_page == 'leader' %}active{% endif %}">é¢†è¢–åŸ¹è®­ç­</a>
            <a href="{{ url_for('english') }}" class="nav-link {% if current_page == 'english' %}active{% endif %}">è‹±æ–‡å­¦ä¹ å¤©åœ°</a>
            <a href="{{ url_for('aichat') }}" class="nav-link ai-link {% if current_page == 'aichat' %}active{% endif %}">
                <span class="ai-glow"></span>
                æ™ºè„‘ä¸­æ¢
            </a>
        </div>

        <!-- åº•éƒ¨åŒºåŸŸï¼šå¾…æ‰§è¡Œprompt + promptå†å²è®°å½• -->
        <div class="sidebar-bottom">
            <a href="{{ url_for('prompt_todo') }}" class="prompt-log-link {% if current_page == 'prompt_todo' %}active{% endif %}">
                <span class="prompt-icon">ğŸ“‹</span>
                <span>å¾…æ‰§è¡Œprompt</span>
            </a>
            <a href="{{ url_for('prompts') }}" class="prompt-log-link {% if current_page == 'prompts' %}active{% endif %}">
                <span class="prompt-icon">ğŸ“œ</span>
                <span>promptå†å²è®°å½•</span>
            </a>
            <div class="sidebar-divider"></div>
        </div>

        <!-- æ—¶åŒºæ˜¾ç¤º -->
        <div class="timezone-panel" id="timezone-panel">
            <div class="timezone-item">
                <span class="tz-city">åŒ—äº¬</span>
                <div class="tz-info">
                    <span class="tz-datetime" id="tz-beijing-date"></span>
                    <span class="tz-time" id="tz-beijing-time"></span>
                </div>
            </div>
            <div class="timezone-item">
                <span class="tz-city">æ»‘é“å¢</span>
                <div class="tz-info">
                    <span class="tz-datetime" id="tz-waterloo-date"></span>
                    <span class="tz-time" id="tz-waterloo-time"></span>
                </div>
            </div>
            <div class="timezone-item">
                <span class="tz-city">æ¸©å“¥å</span>
                <div class="tz-info">
                    <span class="tz-datetime" id="tz-vancouver-date"></span>
                    <span class="tz-time" id="tz-vancouver-time"></span>
                </div>
            </div>
        </div>
    </nav>

    <!-- Right Main Content -->
    <main class="main-content" id="main-content">
        {% block content %}{% endblock %}
    </main>
</div>
{% endblock %}

{% block scripts %}
<script>
// å¤´åƒåè¨€åŠŸèƒ½
(function() {
    var avatarQuotes = [
        "ä»£ç å¦‚è¯—ï¼Œä¼˜é›…è€Œç®€æ´ã€‚",
        "ä»Šå¤©çš„bugï¼Œæ˜¯æ˜å¤©çš„featureã€‚",
        "å…ˆè®©å®ƒå·¥ä½œï¼Œå†è®©å®ƒä¼˜é›…ã€‚",
        "ç®€å•æ˜¯æœ€ç»ˆçš„å¤æ‚ã€‚",
        "å¥½çš„ä»£ç æ˜¯è‡ªå·±çš„æœ€ä½³æ–‡æ¡£ã€‚",
        "è°ƒè¯•æ˜¯å†™ä»£ç æ—¶æ²¡åšçš„äº‹ã€‚",
        "ä¿æŒå­¦ä¹ ï¼Œä¿æŒè°¦é€Šã€‚",
        "ä¸€æ¬¡åªåšä¸€ä»¶äº‹ï¼Œåšåˆ°æè‡´ã€‚",
        "è½¯ä»¶å¼€å‘æ˜¯ä¸€åœºé©¬æ‹‰æ¾ï¼Œä¸æ˜¯çŸ­è·‘ã€‚",
        "æœ€å¥½çš„é”™è¯¯å¤„ç†æ˜¯ä¸è®©é”™è¯¯å‘ç”Ÿã€‚",
        "é‡æ„æ˜¯å¼€å‘è€…çš„æ—¥å¸¸ä¿®è¡Œã€‚",
        "æµ‹è¯•ä¸æ˜¯æ‰¾bugï¼Œæ˜¯è¯æ˜ä»£ç æ­£ç¡®ã€‚",
        "ä»£ç å†™ç»™äººçœ‹ï¼Œé¡ºä¾¿è®©æœºå™¨æ‰§è¡Œã€‚",
        "æ°¸è¿œä¸è¦ç›¸ä¿¡ç”¨æˆ·è¾“å…¥ã€‚",
        "æå‰ä¼˜åŒ–æ˜¯ä¸‡æ¶ä¹‹æºã€‚",
        "å¤åˆ¶ç²˜è´´æ˜¯æŠ€æœ¯å€ºçš„å¼€å§‹ã€‚"
    ];
    var currentQuoteIndex = Math.floor(Math.random() * avatarQuotes.length);
    var quoteContent = document.getElementById('avatar-quote-content');

    function updateQuote() {
        if (quoteContent) {
            quoteContent.textContent = '"' + avatarQuotes[currentQuoteIndex] + '"';
        }
    }

    window.nextAvatarQuote = function() {
        currentQuoteIndex = (currentQuoteIndex + 1) % avatarQuotes.length;
        updateQuote();
    };

    updateQuote();
})();

// Top Header - æ»šåŠ¨éšè—
(function() {
    var header = document.getElementById('top-header');
    var menuBtn = document.getElementById('header-menu-btn');
    var lastScrollTop = 0;
    var scrollThreshold = 60;

    window.addEventListener('scroll', function() {
        var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        if (scrollTop > lastScrollTop && scrollTop > scrollThreshold) {
            header.classList.add('hidden');
        } else {
            header.classList.remove('hidden');
        }
        lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
    }, { passive: true });

    if (menuBtn) {
        menuBtn.addEventListener('click', function() {
            var pet = document.getElementById('pet');
            if (pet) pet.click();
        });
    }
})();

// Header Particles Animation (å®Œæ•´ç‰ˆï¼šå°¾å·´+æ’æ–¥+ææƒ§+çˆ†ç‚¸+æ±‡åˆ+ä¾§è¾¹æ è´¯é€š)
(function() {
    var canvas = document.getElementById('header-particles');
    if (!canvas) return;
    var ctx = canvas.getContext('2d');
    var header = document.getElementById('top-header');
    var sidebar = document.getElementById('sidebar');
    var logo = document.getElementById('header-logo');

    // åŒºåŸŸé…ç½® - Lå½¢åŒºåŸŸï¼šé¡¶æ å…¨å®½ + ä¾§è¾¹æ 
    var headerHeight = 48;
    var sidebarWidth = 220;

    var particles = [];
    var fragments = [];
    var fishes = [];
    var fishFragments = []; // å°é±¼ç¢ç‰‡
    var particleCount = parseInt(localStorage.getItem('particleCount')) || 6;
    var fishCount = parseInt(localStorage.getItem('fishCount')) || 3;
    var maxTailLength = 12; // ç¼©çŸ­å°¾å·´æœ€å¤§é•¿åº¦
    var colors = ['#60a5fa', '#34d399', '#f87171', '#fbbf24', '#a78bfa', '#f472b6'];
    var fishColors = ['#ff9966', '#66ccff', '#99ff99'];

    var mouse = { x: -1000, y: -1000 };
    var mouseRepelRadius = 100;
    var mouseRepelForce = 4;

    var fearThreshold = 60;
    var explodeThreshold = 150;
    var reuniteDelay = 120;

    function resizeCanvas() {
        // å…¨å±å®½åº¦ä»¥æ”¯æŒLå½¢åŒºåŸŸ
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨Lå½¢åŒºåŸŸå†…
    function isInLShape(x, y) {
        // Lå½¢åŒºåŸŸï¼šé¡¶æ å…¨å®½(y<=headerHeight) + ä¾§è¾¹æ (x<=sidebarWidth)
        return y <= headerHeight || x <= sidebarWidth;
    }

    // è·å–Lå½¢åŒºåŸŸçš„æœ‰æ•ˆè¾¹ç•Œ
    function getLShapeBounds(y) {
        if (y <= headerHeight) {
            // åœ¨é¡¶æ åŒºåŸŸï¼šå¯ä»¥ç”¨å…¨å®½
            return { minX: 0, maxX: canvas.width };
        } else {
            // åœ¨ä¾§è¾¹æ åŒºåŸŸï¼šåªèƒ½ç”¨ä¾§è¾¹æ å®½åº¦
            return { minX: 0, maxX: sidebarWidth };
        }
    }

    function createParticle(index, x, y, radius) {
        // éšæœºåˆå§‹è§’åº¦ï¼ˆåå‘æ¨ªå‘ï¼Œåƒé±¼åœ¨æµ´ç¼¸æ¸¸åŠ¨ï¼‰
        var baseAngle = Math.random() < 0.5 ? 0 : Math.PI;
        var angle = baseAngle + (Math.random() - 0.5) * Math.PI / 3;
        var speed = 0.3 + Math.random() * 0.3;
        // å¤§éƒ¨åˆ†ç²’å­ç”Ÿæˆåœ¨é¡¶æ åŒºåŸŸï¼ˆ80%æ¦‚ç‡ï¼‰
        var spawnInHeader = Math.random() < 0.8;
        var spawnX = x !== undefined ? x : (spawnInHeader ? Math.random() * canvas.width : Math.random() * sidebarWidth);
        var spawnY = y !== undefined ? y : (spawnInHeader ? Math.random() * headerHeight : headerHeight + Math.random() * (canvas.height - headerHeight));
        return {
            x: spawnX,
            y: spawnY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: radius || (4 + Math.random() * 3),
            color: colors[index % colors.length],
            alpha: 0.7 + Math.random() * 0.2,
            trail: [],
            stuckTime: 0,
            isShaking: false,
            shakeOffset: { x: 0, y: 0 },
            targetAngle: angle,
            turnSpeed: 0.015 + Math.random() * 0.015,
            nextTurnTime: 100 + Math.floor(Math.random() * 150)
        };
    }

    function initParticles() {
        particles = [];
        fragments = [];
        fishes = [];
        fishFragments = [];
        for (var i = 0; i < particleCount; i++) {
            particles.push(createParticle(i));
        }
        for (var i = 0; i < fishCount; i++) {
            fishes.push(createFish(i));
        }
    }

    function createFish(index, x, y, size) {
        var direction = Math.random() < 0.5 ? 1 : -1;
        var facingAngle = direction > 0 ? 0 : Math.PI;
        // å¤§éƒ¨åˆ†é±¼ç”Ÿæˆåœ¨é¡¶æ åŒºåŸŸï¼ˆ80%æ¦‚ç‡ï¼‰
        var spawnInHeader = Math.random() < 0.8;
        var spawnX = x !== undefined ? x : (spawnInHeader ? Math.random() * canvas.width : Math.random() * sidebarWidth);
        var spawnY = y !== undefined ? y : (spawnInHeader ? 8 + Math.random() * (headerHeight - 16) : headerHeight + Math.random() * (canvas.height - headerHeight - 16));
        var fishSize = size || (6 + Math.random() * 3);
        return {
            x: spawnX,
            y: spawnY,
            vx: direction * (0.4 + Math.random() * 0.3),
            vy: (Math.random() - 0.5) * 0.1,
            size: fishSize,
            color: fishColors[index % fishColors.length],
            tailPhase: Math.random() * Math.PI * 2,
            direction: direction,
            facingAngle: facingAngle, // é±¼å¤´æœå‘è§’åº¦ï¼ˆç‹¬ç«‹äºé€Ÿåº¦ï¼‰
            angle: facingAngle,       // å®é™…ç»˜åˆ¶è§’åº¦
            backwardTime: 0,          // å€’é€€è®¡æ—¶
            turnSpeed: 0.15,          // æ­£å¸¸è½¬å‘é€Ÿåº¦
            isEscaping: false,        // æ˜¯å¦æ­£åœ¨é€ƒé€¸
            escapePhase: 0,           // é€ƒé€¸é˜¶æ®µï¼š0=æ­£å¸¸ï¼Œ1=å€’é€€ä¸­ï¼Œ2=å¿«é€Ÿè½¬å‘
            // è¾¹ç•Œæ£€æµ‹å’Œçˆ†ç‚¸ç›¸å…³
            stuckTime: 0,
            isShaking: false,
            shakeOffset: { x: 0, y: 0 }
        };
    }

    // æ£€æµ‹é±¼æ˜¯å¦è¢«å›°åœ¨è¾¹ç¼˜
    function isFishStuckAtEdge(f) {
        var edgeMargin = f.size + 5;
        var bounds = getLShapeBounds(f.y);
        var nearEdge = f.x < edgeMargin || f.x > bounds.maxX - edgeMargin ||
                       f.y < edgeMargin || f.y > canvas.height - edgeMargin;
        var dx = f.x - mouse.x;
        var dy = f.y - mouse.y;
        var nearMouse = Math.sqrt(dx * dx + dy * dy) < mouseRepelRadius + 20;
        return nearEdge && nearMouse;
    }

    // å°é±¼çˆ†ç‚¸åˆ†è£‚ä¸º3æ¡å°é±¼
    function explodeFish(f, index) {
        for (var i = 0; i < 3; i++) {
            var angle = (Math.PI * 2 / 3) * i + Math.random() * 0.5;
            var speed = 2 + Math.random() * 1.5;
            fishFragments.push({
                x: f.x, y: f.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: f.size * 0.5,
                color: f.color,
                tailPhase: Math.random() * Math.PI * 2,
                angle: angle,
                life: reuniteDelay,
                parentIndex: index,
                ignoreMouseTime: 40
            });
        }
        fishes.splice(index, 1);
    }

    // å°é±¼ç¢ç‰‡æ±‡åˆé‡ç»„
    function reuniteFishFragments() {
        var groups = {};
        fishFragments.forEach(function(f, i) {
            if (!groups[f.parentIndex]) groups[f.parentIndex] = [];
            groups[f.parentIndex].push({ fragment: f, index: i });
        });

        var toRemove = [];
        for (var parentIndex in groups) {
            var group = groups[parentIndex];
            if (group.length > 0 && group[0].fragment.life <= 0) {
                var cx = 0, cy = 0;
                group.forEach(function(g) { cx += g.fragment.x; cy += g.fragment.y; });
                cx /= group.length; cy /= group.length;

                var newFish = createFish(parseInt(parentIndex), cx, cy);
                newFish.vx = (Math.random() - 0.5) * 1.5;
                newFish.vy = (Math.random() - 0.5) * 1.5;
                fishes.push(newFish);

                group.forEach(function(g) { toRemove.push(g.index); });
            }
        }
        toRemove.sort(function(a, b) { return b - a; });
        toRemove.forEach(function(i) { fishFragments.splice(i, 1); });
    }

    // æ ‡å‡†åŒ–è§’åº¦åˆ° [-PI, PI]
    function normalizeAngle(angle) {
        while (angle > Math.PI) angle -= Math.PI * 2;
        while (angle < -Math.PI) angle += Math.PI * 2;
        return angle;
    }

    function updateFish(f, index) {
        f.tailPhase += 0.15;

        var dx = f.x - mouse.x;
        var dy = f.y - mouse.y;
        var dist = Math.sqrt(dx * dx + dy * dy);
        var escapeAngle = Math.atan2(dy, dx); // é€ƒé€¸æ–¹å‘ï¼ˆä»é¼ æ ‡æŒ‡å‘é±¼ï¼‰
        var velocityAngle = Math.atan2(f.vy, f.vx);

        // é¼ æ ‡æ’æ–¥ä¸æ™ºèƒ½é€ƒé€¸
        if (dist < mouseRepelRadius && dist > 0) {
            f.isEscaping = true;

            // è®¡ç®—é±¼å¤´æœå‘ä¸é€ƒé€¸æ–¹å‘çš„å¤¹è§’
            var angleDiff = normalizeAngle(escapeAngle - f.facingAngle);
            var isFacingAway = Math.abs(angleDiff) < Math.PI / 2; // é±¼å¤´æœå‘é€ƒé€¸æ–¹å‘

            if (isFacingAway) {
                // é±¼å¤´å·²ç»æœå‘é€ƒé€¸æ–¹å‘ï¼Œç›´æ¥åŠ é€Ÿé€ƒé€¸
                f.escapePhase = 0;
                var force = (mouseRepelRadius - dist) / mouseRepelRadius * 6;
                f.vx += (dx / dist) * force;
                f.vy += (dy / dist) * force;
            } else {
                // é±¼å¤´æœå‘é¼ æ ‡æ–¹å‘
                if (f.escapePhase === 0) {
                    f.escapePhase = 1; // è¿›å…¥å€’é€€é˜¶æ®µ
                    f.backwardTime = 0;
                }

                if (f.escapePhase === 1) {
                    // å€’é€€é˜¶æ®µï¼šå‘åç§»åŠ¨ä½†ä¸è½¬å¤´
                    f.backwardTime++;
                    var backwardForce = (mouseRepelRadius - dist) / mouseRepelRadius * 3;
                    f.vx += (dx / dist) * backwardForce;
                    f.vy += (dy / dist) * backwardForce;

                    // å€’é€€æ—¶é—´é™åˆ¶ï¼Œè¶…è¿‡åå¿«é€Ÿæ‰å¤´
                    if (f.backwardTime > 15 || dist < mouseRepelRadius * 0.5) {
                        f.escapePhase = 2; // è¿›å…¥å¿«é€Ÿè½¬å‘é˜¶æ®µ
                    }
                }

                if (f.escapePhase === 2) {
                    // å¿«é€Ÿè½¬å‘é˜¶æ®µï¼šå¿«é€Ÿå°†é±¼å¤´è½¬å‘é€ƒé€¸æ–¹å‘
                    var turnAmount = normalizeAngle(escapeAngle - f.facingAngle) * 0.3;
                    f.facingAngle = normalizeAngle(f.facingAngle + turnAmount);

                    // åŒæ—¶åŠ é€Ÿé€ƒé€¸
                    var force = (mouseRepelRadius - dist) / mouseRepelRadius * 5;
                    f.vx += (dx / dist) * force;
                    f.vy += (dy / dist) * force;

                    // è½¬å‘å®Œæˆåæ¢å¤æ­£å¸¸
                    if (Math.abs(normalizeAngle(escapeAngle - f.facingAngle)) < Math.PI / 4) {
                        f.escapePhase = 0;
                    }
                }
            }
        } else {
            // ä¸åœ¨é¼ æ ‡èŒƒå›´å†…
            f.isEscaping = false;
            f.escapePhase = 0;
            f.backwardTime = 0;
        }

        // æ£€æµ‹æ˜¯å¦è¢«å›°
        if (isFishStuckAtEdge(f)) {
            f.stuckTime++;
            if (f.stuckTime > fearThreshold) {
                f.isShaking = true;
                f.shakeOffset = { x: (Math.random() - 0.5) * 3, y: (Math.random() - 0.5) * 3 };
            }
            if (f.stuckTime > explodeThreshold) {
                explodeFish(f, index);
                return false;
            }
        } else {
            f.stuckTime = Math.max(0, f.stuckTime - 2);
            f.isShaking = false;
            f.shakeOffset = { x: 0, y: 0 };
        }

        var inHeader = f.y <= headerHeight;

        // åŒºåŸŸè¡Œä¸º
        if (inHeader) {
            f.vy += (Math.random() - 0.5) * 0.02;
            f.vy *= 0.95;
        } else {
            f.vx += (Math.random() - 0.5) * 0.03;
            f.vy += (Math.random() - 0.5) * 0.03;
        }

        // æ›´æ–°ä½ç½®
        f.x += f.vx;
        f.y += f.vy;

        // é€Ÿåº¦ç»´æŒ
        var speed = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
        if (speed < 0.3) {
            var angle = inHeader ? (Math.random() < 0.5 ? 0 : Math.PI) : Math.random() * Math.PI * 2;
            f.vx = Math.cos(angle) * 0.5;
            f.vy = Math.sin(angle) * 0.5;
        }
        var maxSpeed = 4, minSpeed = 0.3; // æé«˜æœ€å¤§é€Ÿåº¦
        if (speed > maxSpeed) {
            f.vx = (f.vx / speed) * maxSpeed;
            f.vy = (f.vy / speed) * maxSpeed;
        }
        f.vx *= 0.995;
        f.vy *= 0.995;

        // Lå½¢æ‹è§’å¤„ç†
        if (f.y > headerHeight && f.x > sidebarWidth - f.size) {
            var overY = f.y - headerHeight;
            var overX = f.x - (sidebarWidth - f.size);
            if (overY < overX) {
                f.y = headerHeight - f.size;
                f.vy = -Math.abs(f.vy);
            } else {
                f.x = sidebarWidth - f.size;
                f.vx = -Math.abs(f.vx);
            }
        }

        // Lå½¢è¾¹ç•Œå¤„ç†
        var newBounds = getLShapeBounds(f.y);
        if (f.x < f.size) {
            f.x = f.size;
            f.vx = Math.abs(f.vx);
        } else if (f.x > newBounds.maxX - f.size) {
            f.x = newBounds.maxX - f.size;
            f.vx = -Math.abs(f.vx);
        }
        if (f.y < f.size) {
            f.y = f.size;
            f.vy = Math.abs(f.vy);
        } else if (f.y > canvas.height - f.size) {
            f.y = canvas.height - f.size;
            f.vy = -Math.abs(f.vy);
        }

        // æ›´æ–°é±¼å¤´æœå‘ï¼šé€æ¸è½¬å‘é€Ÿåº¦æ–¹å‘ï¼ˆä¸åœ¨é€ƒé€¸æ—¶ï¼‰
        velocityAngle = Math.atan2(f.vy, f.vx);
        if (!f.isEscaping || f.escapePhase === 0) {
            var targetAngle = velocityAngle;
            var angleDiff = normalizeAngle(targetAngle - f.facingAngle);

            // æ£€æŸ¥æ˜¯å¦åœ¨å€’æ¸¸ï¼ˆé±¼å¤´ä¸é€Ÿåº¦æ–¹å‘ç›¸åï¼‰
            var isBackward = Math.abs(angleDiff) > Math.PI / 2;

            if (isBackward) {
                f.backwardTime++;
                // å€’æ¸¸æ—¶é—´è¶…è¿‡é™åˆ¶ï¼Œå¿«é€Ÿæ‰å¤´
                if (f.backwardTime > 30) {
                    f.facingAngle = normalizeAngle(f.facingAngle + angleDiff * 0.2);
                }
            } else {
                f.backwardTime = Math.max(0, f.backwardTime - 1);
                // æ­£å¸¸è½¬å‘
                f.facingAngle = normalizeAngle(f.facingAngle + angleDiff * f.turnSpeed);
            }
        }

        // è®¾ç½®æœ€ç»ˆç»˜åˆ¶è§’åº¦
        f.angle = f.facingAngle;
        f.direction = Math.cos(f.angle) >= 0 ? 1 : -1;

        return true;
    }

    function updateFishFragment(ff) {
        ff.tailPhase += 0.2;

        if (ff.ignoreMouseTime > 0) {
            ff.ignoreMouseTime--;
        } else {
            var dx = ff.x - mouse.x;
            var dy = ff.y - mouse.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < mouseRepelRadius && dist > 0) {
                var force = (mouseRepelRadius - dist) / mouseRepelRadius * 0.5;
                ff.vx += (dx / dist) * force;
                ff.vy += (dy / dist) * force;
            }
        }

        ff.vx *= 0.98;
        ff.vy *= 0.98;
        ff.x += ff.vx;
        ff.y += ff.vy;
        ff.life--;
        ff.angle = Math.atan2(ff.vy, ff.vx);

        // Lå½¢æ‹è§’å¤„ç†
        if (ff.y > headerHeight && ff.x > sidebarWidth - ff.size) {
            var overY = ff.y - headerHeight;
            var overX = ff.x - (sidebarWidth - ff.size);
            if (overY < overX) {
                ff.y = headerHeight - ff.size;
                ff.vy = -Math.abs(ff.vy);
            } else {
                ff.x = sidebarWidth - ff.size;
                ff.vx = -Math.abs(ff.vx);
            }
        }

        // è¾¹ç•Œ
        var bounds = getLShapeBounds(ff.y);
        if (ff.x < ff.size || ff.x > bounds.maxX - ff.size) {
            ff.vx = -ff.vx;
            ff.x = Math.max(ff.size, Math.min(bounds.maxX - ff.size, ff.x));
        }
        if (ff.y < ff.size || ff.y > canvas.height - ff.size) {
            ff.vy = -ff.vy;
            ff.y = Math.max(ff.size, Math.min(canvas.height - ff.size, ff.y));
        }
    }

    // è®¡ç®—é€æ˜åº¦ç³»æ•°ï¼ˆåœ¨ä¾§è¾¹æ åŒºåŸŸæ—¶å˜é€æ˜ï¼‰
    function getTransparencyMultiplier(y) {
        if (y <= headerHeight) return 1;
        var fadeStart = headerHeight;
        var fadeEnd = headerHeight + 50;
        if (y < fadeEnd) return 1 - 0.5 * ((y - fadeStart) / (fadeEnd - fadeStart));
        return 0.5;
    }

    function drawFish(f) {
        var transMult = getTransparencyMultiplier(f.y);
        var drawX = f.x + (f.shakeOffset ? f.shakeOffset.x : 0);
        var drawY = f.y + (f.shakeOffset ? f.shakeOffset.y : 0);
        ctx.save();
        ctx.translate(drawX, drawY);

        var angle = f.angle || 0;
        var flipY = Math.abs(angle) > Math.PI / 2;
        if (flipY) {
            ctx.rotate(angle + Math.PI);
            ctx.scale(1, -1);
        } else {
            ctx.rotate(angle);
        }

        var s = f.size;
        var tailSwing = Math.sin(f.tailPhase) * 0.3;
        ctx.beginPath();
        ctx.ellipse(0, 0, s * 1.2, s * 0.6, 0, 0, Math.PI * 2);
        ctx.fillStyle = f.color;
        ctx.globalAlpha = 0.85 * transMult;
        // éœ‡åŠ¨æ—¶åŠ çº¢è‰²å…‰æ™•
        if (f.isShaking) {
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
        }
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(-s * 1.1, 0);
        ctx.lineTo(-s * 2, -s * 0.5 + tailSwing * s);
        ctx.lineTo(-s * 2, s * 0.5 + tailSwing * s);
        ctx.closePath();
        ctx.fillStyle = f.color;
        ctx.globalAlpha = 0.7 * transMult;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(s * 0.5, -s * 0.1, s * 0.15, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 1 * transMult;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(s * 0.55, -s * 0.1, s * 0.08, 0, Math.PI * 2);
        ctx.fillStyle = '#333333';
        ctx.fill();
        ctx.restore();
        ctx.globalAlpha = 1;
    }

    function drawFishFragment(ff) {
        var transMult = getTransparencyMultiplier(ff.y) * (ff.life / reuniteDelay);
        ctx.save();
        ctx.translate(ff.x, ff.y);

        var angle = ff.angle || 0;
        var flipY = Math.abs(angle) > Math.PI / 2;
        if (flipY) {
            ctx.rotate(angle + Math.PI);
            ctx.scale(1, -1);
        } else {
            ctx.rotate(angle);
        }

        var s = ff.size;
        var tailSwing = Math.sin(ff.tailPhase) * 0.4;
        ctx.beginPath();
        ctx.ellipse(0, 0, s * 1.2, s * 0.6, 0, 0, Math.PI * 2);
        ctx.fillStyle = ff.color;
        ctx.globalAlpha = 0.8 * transMult;
        ctx.shadowColor = ff.color;
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(-s * 1.1, 0);
        ctx.lineTo(-s * 2, -s * 0.5 + tailSwing * s);
        ctx.lineTo(-s * 2, s * 0.5 + tailSwing * s);
        ctx.closePath();
        ctx.globalAlpha = 0.6 * transMult;
        ctx.fill();
        ctx.restore();
        ctx.globalAlpha = 1;
    }

    function isStuckAtEdge(p) {
        var edgeMargin = p.radius + 5;
        var bounds = getLShapeBounds(p.y);
        var nearEdge = p.x < edgeMargin || p.x > bounds.maxX - edgeMargin ||
                       p.y < edgeMargin || p.y > canvas.height - edgeMargin;
        var dx = p.x - mouse.x;
        var dy = p.y - mouse.y;
        var nearMouse = Math.sqrt(dx * dx + dy * dy) < mouseRepelRadius + 20;
        return nearEdge && nearMouse;
    }

    function explodeParticle(p, index) {
        var fragmentColors = [colors[(index) % colors.length], colors[(index + 2) % colors.length], colors[(index + 4) % colors.length]];
        for (var i = 0; i < 3; i++) {
            var angle = (Math.PI * 2 / 3) * i + Math.random() * 0.5;
            var speed = 3 + Math.random() * 2;
            fragments.push({
                x: p.x, y: p.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: p.radius * 0.5,
                color: fragmentColors[i],
                alpha: 0.9,
                trail: [],
                life: reuniteDelay,
                parentIndex: index,
                ignoreMouseTime: 40
            });
        }
        particles.splice(index, 1);
    }

    function reuniteFragments() {
        var groups = {};
        fragments.forEach(function(f, i) {
            if (!groups[f.parentIndex]) groups[f.parentIndex] = [];
            groups[f.parentIndex].push({ fragment: f, index: i });
        });

        var toRemove = [];
        for (var parentIndex in groups) {
            var group = groups[parentIndex];
            if (group.length > 0 && group[0].fragment.life <= 0) {
                var cx = 0, cy = 0;
                group.forEach(function(g) { cx += g.fragment.x; cy += g.fragment.y; });
                cx /= group.length; cy /= group.length;

                var newP = createParticle(parseInt(parentIndex), cx, cy);
                newP.vx = (Math.random() - 0.5) * 2;
                newP.vy = (Math.random() - 0.5) * 2;
                particles.push(newP);

                group.forEach(function(g) { toRemove.push(g.index); });
            }
        }
        toRemove.sort(function(a, b) { return b - a; });
        toRemove.forEach(function(i) { fragments.splice(i, 1); });
    }

    function updateParticle(p, index) {
        var speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);

        // å°¾å·´é•¿åº¦ï¼šåŸºç¡€é•¿åº¦ + é€Ÿåº¦åŠ æˆ
        var dynamicTailLength = Math.floor(5 + speed * 2);
        dynamicTailLength = Math.max(5, Math.min(maxTailLength, dynamicTailLength));

        p.trail.push({ x: p.x, y: p.y });
        while (p.trail.length > dynamicTailLength) p.trail.shift();

        if (isStuckAtEdge(p)) {
            p.stuckTime++;
            if (p.stuckTime > fearThreshold) {
                p.isShaking = true;
                p.shakeOffset.x = (Math.random() - 0.5) * 3;
                p.shakeOffset.y = (Math.random() - 0.5) * 3;
            }
            if (p.stuckTime > explodeThreshold) {
                explodeParticle(p, index);
                return false;
            }
        } else {
            p.stuckTime = Math.max(0, p.stuckTime - 2);
            p.isShaking = false;
            p.shakeOffset.x = 0;
            p.shakeOffset.y = 0;
        }

        // é¼ æ ‡æ’æ–¥ï¼ˆå°çƒå¿«é€Ÿé€ƒé€¸ï¼‰
        var dx = p.x - mouse.x;
        var dy = p.y - mouse.y;
        var dist = Math.sqrt(dx * dx + dy * dy);
        var isEscaping = dist < mouseRepelRadius && dist > 0;

        if (isEscaping) {
            var force = (mouseRepelRadius - dist) / mouseRepelRadius * 10; // å¤§å¹…å¢å¼ºé€ƒé€¸åŠ›åº¦
            p.vx += (dx / dist) * force;
            p.vy += (dy / dist) * force;
        }

        var inHeader = p.y <= headerHeight;

        // åªåœ¨éé€ƒé€¸æ—¶è¿›è¡Œå¹³æ»‘è½¬å‘
        if (!isEscaping) {
            p.nextTurnTime--;
            if (p.nextTurnTime <= 0) {
                var currentAngle = Math.atan2(p.vy, p.vx);
                if (inHeader) {
                    if (Math.random() < 0.7) {
                        var baseAngle = Math.cos(currentAngle) > 0 ? 0 : Math.PI;
                        if (Math.random() < 0.15) baseAngle += Math.PI;
                        p.targetAngle = baseAngle + (Math.random() - 0.5) * Math.PI / 3;
                    } else {
                        p.targetAngle = currentAngle + (Math.random() - 0.5) * Math.PI * 0.4;
                    }
                } else {
                    p.targetAngle = Math.random() * Math.PI * 2;
                }
                p.nextTurnTime = 80 + Math.floor(Math.random() * 120);
            }

            var currentAngle = Math.atan2(p.vy, p.vx);
            var angleDiff = p.targetAngle - currentAngle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            if (Math.abs(angleDiff) > 0.01) {
                var newAngle = currentAngle + angleDiff * p.turnSpeed;
                var targetSpeed = 0.4 + Math.random() * 0.3;
                p.vx = Math.cos(newAngle) * Math.max(speed, targetSpeed);
                p.vy = Math.sin(newAngle) * Math.max(speed, targetSpeed);
            }
        }

        if (inHeader) p.vy *= 0.95;

        // é€Ÿåº¦è§„åˆ™
        speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
        var maxSpeed = 5, minSpeed = 0.3; // æé«˜æœ€å¤§é€Ÿåº¦åˆ°5
        if (speed > maxSpeed) {
            p.vx = (p.vx / speed) * maxSpeed;
            p.vy = (p.vy / speed) * maxSpeed;
        } else if (speed < minSpeed) {
            var angle = inHeader ? (Math.random() < 0.5 ? 0 : Math.PI) : Math.random() * Math.PI * 2;
            p.vx = Math.cos(angle) * 0.5;
            p.vy = Math.sin(angle) * 0.5;
        }

        p.vx *= 0.995; // ä¸å°é±¼ä¸€è‡´
        p.vy *= 0.995;

        p.x += p.vx;
        p.y += p.vy;

        // Lå½¢è¾¹ç¼˜å¹³æ»‘åå¼¹
        var bounced = false;

        // é¦–å…ˆå¤„ç†Lå½¢æ‹è§’ï¼šæ£€æµ‹æ˜¯å¦è¿›å…¥ç¦åŒºï¼ˆy > headerHeight ä¸” x > sidebarWidthï¼‰
        if (p.y > headerHeight && p.x > sidebarWidth - p.radius) {
            // è®¡ç®—è¿›å…¥ç¦åŒºçš„ç¨‹åº¦ï¼Œå†³å®šä»å“ªä¸ªæ–¹å‘å¼¹å›
            var overY = p.y - headerHeight;
            var overX = p.x - (sidebarWidth - p.radius);
            if (overY < overX) {
                // Yæ–¹å‘è¶Šç•Œè¾ƒå°‘ï¼Œæ¨å›åˆ°é¡¶æ 
                p.y = headerHeight - p.radius;
                p.vy = -Math.abs(p.vy);
            } else {
                // Xæ–¹å‘è¶Šç•Œè¾ƒå°‘ï¼Œæ¨å›åˆ°ä¾§è¾¹æ 
                p.x = sidebarWidth - p.radius;
                p.vx = -Math.abs(p.vx);
            }
            bounced = true;
        }

        // å¸¸è§„è¾¹ç•Œæ£€æŸ¥
        var bounds = getLShapeBounds(p.y);
        if (p.x - p.radius < 0) {
            p.x = p.radius;
            p.vx = Math.abs(p.vx);
            bounced = true;
        } else if (p.x + p.radius > bounds.maxX) {
            p.x = bounds.maxX - p.radius;
            p.vx = -Math.abs(p.vx);
            bounced = true;
        }
        if (p.y - p.radius < 0) {
            p.y = p.radius;
            p.vy = Math.abs(p.vy);
            bounced = true;
        } else if (p.y + p.radius > canvas.height) {
            p.y = canvas.height - p.radius;
            p.vy = -Math.abs(p.vy);
            bounced = true;
        }
        if (bounced) {
            p.targetAngle = Math.atan2(p.vy, p.vx);
        }

        return true;
    }

    function updateFragment(f) {
        f.trail.push({ x: f.x, y: f.y });
        if (f.trail.length > 8) f.trail.shift();

        if (f.ignoreMouseTime > 0) {
            f.ignoreMouseTime--;
        } else {
            var dx = f.x - mouse.x;
            var dy = f.y - mouse.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < mouseRepelRadius && dist > 0) {
                var force = (mouseRepelRadius - dist) / mouseRepelRadius * 0.5;
                f.vx += (dx / dist) * force;
                f.vy += (dy / dist) * force;
            }
        }

        f.vx *= 0.98;
        f.vy *= 0.98;
        f.x += f.vx;
        f.y += f.vy;
        f.life--;

        // Lå½¢æ‹è§’å¤„ç†
        if (f.y > headerHeight && f.x > sidebarWidth - f.radius) {
            var overY = f.y - headerHeight;
            var overX = f.x - (sidebarWidth - f.radius);
            if (overY < overX) {
                f.y = headerHeight - f.radius;
                f.vy = -Math.abs(f.vy);
            } else {
                f.x = sidebarWidth - f.radius;
                f.vx = -Math.abs(f.vx);
            }
        }

        // Lå½¢è¾¹ç•Œ
        var bounds = getLShapeBounds(f.y);
        if (f.x - f.radius < 0 || f.x + f.radius > bounds.maxX) {
            f.vx = -f.vx;
            f.x = Math.max(f.radius, Math.min(bounds.maxX - f.radius, f.x));
        }
        if (f.y - f.radius < 0 || f.y + f.radius > canvas.height) {
            f.vy = -f.vy;
            f.y = Math.max(f.radius, Math.min(canvas.height - f.radius, f.y));
        }
    }

    function drawParticle(p) {
        var drawX = p.x + (p.shakeOffset ? p.shakeOffset.x : 0);
        var drawY = p.y + (p.shakeOffset ? p.shakeOffset.y : 0);
        var transMult = getTransparencyMultiplier(drawY);

        // å½—æ˜Ÿå°¾å·´æ•ˆæœï¼šä»å¤´éƒ¨å‘å°¾éƒ¨é€æ¸å˜å°å˜æ·¡
        if (p.trail.length > 1) {
            for (var i = 0; i < p.trail.length; i++) {
                var t = p.trail[i];
                var progress = (i + 1) / p.trail.length; // 0â†’1ï¼Œå°¾éƒ¨æ˜¯0ï¼Œå¤´éƒ¨æ˜¯1
                var trailTrans = getTransparencyMultiplier(t.y);
                var size = p.radius * progress * 0.8; // å°¾éƒ¨å°ï¼Œå¤´éƒ¨å¤§
                var alpha = p.alpha * progress * progress * 0.5; // å°¾éƒ¨æ·¡ï¼Œå¤´éƒ¨äº®
                ctx.beginPath();
                ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = alpha * trailTrans;
                ctx.fill();
            }
        }

        ctx.beginPath();
        ctx.arc(drawX, drawY, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha * transMult;
        ctx.shadowColor = p.isShaking ? '#ff0000' : p.color;
        ctx.shadowBlur = p.isShaking ? 15 : 10;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    }

    function drawFragment(f) {
        var transMult = getTransparencyMultiplier(f.y);
        for (var i = 0; i < f.trail.length; i++) {
            var t = f.trail[i];
            var progress = i / f.trail.length;
            var trailTrans = getTransparencyMultiplier(t.y);
            ctx.beginPath();
            ctx.arc(t.x, t.y, f.radius * progress * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = f.color;
            ctx.globalAlpha = f.alpha * progress * 0.4 * trailTrans;
            ctx.fill();
        }
        ctx.beginPath();
        ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
        ctx.fillStyle = f.color;
        ctx.globalAlpha = f.alpha * (f.life / reuniteDelay) * transMult;
        ctx.shadowColor = f.color;
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // å…ˆç”»å°é±¼ï¼ˆåœ¨åº•å±‚ï¼‰- å€’åºéå†ä»¥ä¾¿å®‰å…¨åˆ é™¤
        for (var i = fishes.length - 1; i >= 0; i--) {
            if (updateFish(fishes[i], i)) {
                drawFish(fishes[i]);
            }
        }

        // å°é±¼ç¢ç‰‡
        fishFragments.forEach(function(ff) {
            updateFishFragment(ff);
            drawFishFragment(ff);
        });
        reuniteFishFragments();

        // ç²’å­
        for (var i = particles.length - 1; i >= 0; i--) {
            if (updateParticle(particles[i], i)) {
                drawParticle(particles[i]);
            }
        }

        // ç²’å­ç¢ç‰‡
        fragments.forEach(function(f) {
            updateFragment(f);
            drawFragment(f);
        });
        reuniteFragments();

        requestAnimationFrame(animate);
    }

    resizeCanvas();
    initParticles();
    animate();

    window.addEventListener('resize', resizeCanvas);

    // é¼ æ ‡è¿½è¸ªï¼šåœ¨Lå½¢åŒºåŸŸå†…ç”Ÿæ•ˆï¼ˆé¡¶æ å…¨å®½ + ä¾§è¾¹æ ï¼‰
    document.addEventListener('mousemove', function(e) {
        var inLShape = (e.clientY <= headerHeight) || (e.clientX <= sidebarWidth);
        if (inLShape) {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        } else {
            mouse.x = -1000;
            mouse.y = -1000;
        }
    });

    document.addEventListener('mouseleave', function() {
        mouse.x = -1000;
        mouse.y = -1000;
    });

    // ç‚¹å‡»é—ªç”µè®¾ç½®å°çƒå’Œå°é±¼æ•°é‡
    if (logo) {
        logo.addEventListener('click', function(e) {
            e.stopPropagation();
            var input = prompt('è®¾ç½®å°çƒæ•°é‡ (1-20)ï¼Œå½“å‰: ' + particleCount, particleCount);
            if (input !== null) {
                var num = parseInt(input);
                if (!isNaN(num) && num >= 1 && num <= 20) {
                    particleCount = num;
                    localStorage.setItem('particleCount', num);
                }
            }
            var fishInput = prompt('è®¾ç½®å°é±¼æ•°é‡ (1-10)ï¼Œå½“å‰: ' + fishCount, fishCount);
            if (fishInput !== null) {
                var fishNum = parseInt(fishInput);
                if (!isNaN(fishNum) && fishNum >= 1 && fishNum <= 10) {
                    fishCount = fishNum;
                    localStorage.setItem('fishCount', fishNum);
                }
            }
            initParticles();
        });
    }
})();

// Desktop-specific sidebar and pet logic
(function() {
    var sidebar = document.getElementById('sidebar');
    var mainContent = document.getElementById('main-content');
    var pet = document.getElementById('pet');
    var navLinks = document.querySelector('.nav-links');
    var sidebarHint = document.getElementById('sidebar-hint');

    var isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
    var targetY = window.innerHeight / 2;
    var currentY = targetY;
    var petHeight = 80;
    var sidebarWidth = 220;
    var isFollowing = false;
    var returnTimer = null;
    var isReturning = false;
    var closeDistance = 20;
    var rushEasing = 0.3;
    var gentleEasing = 0.1;

    function getAvoidZones() {
        var zones = [];
        if (navLinks && !isCollapsed) {
            var rect = navLinks.getBoundingClientRect();
            zones.push({ top: rect.top - 10, bottom: rect.bottom + 10 });
        }
        return zones;
    }

    function isInAvoidZone(y) {
        var zones = getAvoidZones();
        var petTop = y - petHeight / 2;
        var petBottom = y + petHeight / 2;
        for (var i = 0; i < zones.length; i++) {
            if (petBottom > zones[i].top && petTop < zones[i].bottom) return true;
        }
        return false;
    }

    function collapseSidebar() {
        isCollapsed = true;
        sidebar.classList.add('collapsed');
        mainContent.classList.add('expanded');
        pet.classList.add('at-edge');
        pet.classList.remove('at-sidebar', 'slim');
        sidebarHint.classList.add('visible');
        localStorage.setItem('sidebarCollapsed', 'true');
        var quickAddBar = document.querySelector('.quick-add-bar');
        if (quickAddBar) quickAddBar.classList.add('expanded');
    }

    function expandSidebar() {
        isCollapsed = false;
        sidebar.classList.remove('collapsed');
        mainContent.classList.remove('expanded');
        pet.classList.remove('at-edge');
        pet.classList.add('at-sidebar');
        sidebarHint.classList.remove('visible');
        localStorage.setItem('sidebarCollapsed', 'false');
        var quickAddBar = document.querySelector('.quick-add-bar');
        if (quickAddBar) quickAddBar.classList.remove('expanded');
    }

    if (isCollapsed) collapseSidebar();
    else pet.classList.add('at-sidebar');

    pet.addEventListener('click', function() {
        if (isCollapsed) expandSidebar();
        else collapseSidebar();
    });

    document.addEventListener('mousemove', function(e) {
        var petX = isCollapsed ? 0 : sidebarWidth;
        var activeZone = petX + 100;
        if (e.clientX < activeZone) {
            isFollowing = true;
            isReturning = false;
            targetY = e.clientY;
            pet.classList.add('active');
            if (returnTimer) { clearTimeout(returnTimer); returnTimer = null; }
        } else if (isFollowing) {
            isFollowing = false;
            pet.classList.remove('active', 'excited');
            returnTimer = setTimeout(function() {
                isReturning = true;
                targetY = window.innerHeight / 2;
            }, 600);
        }
    });

    function animatePet() {
        var distance = targetY - currentY;
        var absDistance = Math.abs(distance);
        var moveAmount = 0;
        if (isFollowing) {
            if (absDistance > closeDistance) {
                moveAmount = distance * rushEasing;
                pet.classList.add('excited');
            } else {
                moveAmount = distance * gentleEasing;
                pet.classList.remove('excited');
            }
        } else if (isReturning) {
            moveAmount = distance * 0.04;
            pet.classList.remove('excited');
        }
        currentY += moveAmount;
        var minY = petHeight / 2 + 48 + 10; // è€ƒè™‘48pxé¡¶éƒ¨å¯¼èˆªæ 
        var maxY = window.innerHeight - petHeight / 2 - 20;
        currentY = Math.max(minY, Math.min(maxY, currentY));
        if (isInAvoidZone(currentY)) pet.classList.add('slim');
        else pet.classList.remove('slim');
        pet.style.top = currentY + 'px';
        requestAnimationFrame(animatePet);
    }
    animatePet();

    window.addEventListener('resize', function() {
        if (!isFollowing) targetY = window.innerHeight / 2;
    });
})();

// Timezone updates
(function() {
    var weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
    function formatTz(date) {
        var m = date.getMonth() + 1;
        var d = date.getDate();
        var w = weekdays[date.getDay()];
        var h = date.getHours().toString().padStart(2, '0');
        var min = date.getMinutes().toString().padStart(2, '0');
        return { date: m + '/' + d + ' å‘¨' + w, time: h + ':' + min };
    }
    function updateTimezones() {
        var now = new Date();
        var beijing = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Shanghai' }));
        var bjFmt = formatTz(beijing);
        document.getElementById('tz-beijing-date').textContent = bjFmt.date;
        document.getElementById('tz-beijing-time').textContent = bjFmt.time;
        var waterloo = new Date(now.toLocaleString('en-US', { timeZone: 'America/Toronto' }));
        var wtFmt = formatTz(waterloo);
        document.getElementById('tz-waterloo-date').textContent = wtFmt.date;
        document.getElementById('tz-waterloo-time').textContent = wtFmt.time;
        var vancouver = new Date(now.toLocaleString('en-US', { timeZone: 'America/Vancouver' }));
        var vcFmt = formatTz(vancouver);
        document.getElementById('tz-vancouver-date').textContent = vcFmt.date;
        document.getElementById('tz-vancouver-time').textContent = vcFmt.time;
    }
    updateTimezones();
    setInterval(updateTimezones, 1000);
})();
</script>
{% endblock %}
