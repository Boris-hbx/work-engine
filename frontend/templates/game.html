{% extends "base.html" %}

{% block title %}æ”¾æ¾å¤§è„‘ - Boris Life{% endblock %}

{% block content %}
<div class="game-page">
    <div class="game-header">
        <h1 class="game-title">æ”¾æ¾å¤§è„‘</h1>
        <p class="game-subtitle">é€‰æ‹©ä¸€ä¸ªæ¸¸æˆå¼€å§‹æŒ‘æˆ˜</p>
    </div>

    <!-- Main Layout: Left(Games) - Center(Game Area) - Right(Instructions) -->
    <div class="game-main-layout">
        <!-- Left: Game List -->
        <div class="game-list-panel">
            <h3 class="panel-title">æ¸¸æˆåˆ—è¡¨</h3>
            <div class="game-list">
                <button class="game-item active" data-game="spider" onclick="switchGame('spider')">
                    <span class="game-icon">ğŸ•·ï¸</span>
                    <div class="game-info">
                        <span class="game-name">ä½ è¿‡æ¥å•Š</span>
                        <span class="game-desc">é¢†åœ°å é¢†</span>
                    </div>
                </button>
                <button class="game-item" data-game="breakout" onclick="switchGame('breakout')">
                    <span class="game-icon">ğŸ§±</span>
                    <div class="game-info">
                        <span class="game-name">å„ä¸ªå‡»ç ´</span>
                        <span class="game-desc">æ¶ˆç­ç –å—</span>
                    </div>
                </button>
                <button class="game-item" data-game="zen" onclick="switchGame('zen')">
                    <span class="game-icon">ğŸŒŒ</span>
                    <div class="game-info">
                        <span class="game-name">å‘å‘†æ—¶å…‰</span>
                        <span class="game-desc">æ”¾ç©ºè‡ªå·±</span>
                    </div>
                </button>
                <button class="game-item" data-game="tower" onclick="switchGame('tower')">
                    <span class="game-icon">ğŸ°</span>
                    <div class="game-info">
                        <span class="game-name">TRCæ”»é˜²å¤§å¸ˆ</span>
                        <span class="game-desc">å¡”é˜²ç­–ç•¥</span>
                    </div>
                </button>
            </div>
        </div>

        <!-- Center: Game Area -->
        <div class="game-center-panel">
            <!-- Spider Game -->
            <div class="game-wrapper" id="spiderGame">
                <div class="game-container">
                    <div class="game-controls">
                        <div class="difficulty-selector">
                            <span class="control-label">éš¾åº¦ï¼š</span>
                            <button class="diff-btn" data-diff="easy" onclick="setDifficulty('easy')">ç®€å•</button>
                            <button class="diff-btn active" data-diff="normal" onclick="setDifficulty('normal')">æ™®é€š</button>
                            <button class="diff-btn" data-diff="hard" onclick="setDifficulty('hard')">å›°éš¾</button>
                        </div>
                        <div class="game-stats">
                            <span class="stat">å·²å é¢†: <b id="capturedPercent">0</b>%</span>
                            <span class="stat">ç›®æ ‡: <b id="targetPercent">50</b>%</span>
                            <span class="stat">ç”¨æ—¶: <b id="gameTimer" class="timer-value">0.000</b>s</span>
                        </div>
                        <button class="btn-restart" onclick="initGame()">é‡æ–°å¼€å§‹</button>
                    </div>
                    <canvas id="gameCanvas" width="600" height="400"></canvas>
                    <div class="game-status" id="gameStatus"></div>
                </div>
            </div>

            <!-- Breakout Game -->
            <div class="game-wrapper hidden" id="breakoutGame">
                <iframe src="/breakout" id="breakoutFrame" width="100%" height="680" frameborder="0" scrolling="no"></iframe>
            </div>

            <!-- Zen/å‘å‘†æ—¶å…‰ -->
            <div class="game-wrapper hidden" id="zenGame">
                <div class="zen-container">
                    <div class="zen-animation-selector">
                        <button class="zen-btn active" data-anim="threebody" onclick="switchZenAnim('threebody')">ğŸŒŒ ä¸‰ä½“</button>
                        <button class="zen-btn" data-anim="orbits" onclick="switchZenAnim('orbits')">ğŸª è¡Œæ˜Ÿ</button>
                        <button class="zen-btn" data-anim="geometry" onclick="switchZenAnim('geometry')">ğŸ”· å‡ ä½•</button>
                        <button class="zen-btn" data-anim="pendulum" onclick="switchZenAnim('pendulum')">ğŸ¯ é’Ÿæ‘†</button>
                    </div>
                    <canvas id="zenCanvas" width="600" height="400"></canvas>
                    <div class="zen-controls-bar">
                        <button class="zen-control-btn" onclick="toggleZenPause()">
                            <span id="zen-pause-icon">â¸</span> <span id="zen-pause-text">æš‚åœ</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- TRCæ”»é˜²å¤§å¸ˆ / TRC Attack & Defense Master -->
            <div class="game-wrapper hidden" id="towerGame">
                <div class="tower-container">
                    <div class="tower-controls">
                        <div class="tower-info">
                            <span class="info-item">ğŸ’° é‡‘å¸: <b id="towerGold">100</b></span>
                            <span class="info-item">â¤ï¸ ç”Ÿå‘½: <b id="towerLives">10</b></span>
                            <span class="info-item">ğŸŒŠ æ³¢æ¬¡: <b id="towerWave">0</b>/<b id="towerMaxWave">10</b></span>
                            <span class="info-item">ğŸ’€ å‡»æ€: <b id="towerKills">0</b></span>
                        </div>
                        <div class="tower-actions">
                            <button class="tower-btn" id="startWaveBtn" onclick="TowerDefense.startWave()">å¼€å§‹æ³¢æ¬¡</button>
                            <button class="tower-btn speed-btn" id="speedBtn" onclick="TowerDefense.toggleSpeed()">1x</button>
                            <button class="tower-btn pause-btn" id="pauseBtn" onclick="TowerDefense.togglePause()">â¸ï¸</button>
                            <button class="tower-btn" onclick="TowerDefense.toggleFullscreen()">å…¨å±</button>
                            <button class="tower-btn" onclick="TowerDefense.saveGame()">ä¿å­˜</button>
                            <button class="tower-btn" onclick="TowerDefense.loadGame()">è¯»å–</button>
                            <button class="tower-btn restart" onclick="TowerDefense.restart()">é‡æ–°å¼€å§‹</button>
                        </div>
                        <!-- v1.2: æ³¢æ¬¡é¢„å‘Š -->
                        <div class="wave-preview" id="wavePreview">
                            <span class="preview-label">ä¸‹ä¸€æ³¢:</span>
                            <span class="preview-content" id="wavePreviewContent">å‡†å¤‡å°±ç»ª</span>
                        </div>
                        <!-- v1.3: åœ°å›¾å’Œæ¨¡å¼é€‰æ‹© -->
                        <div class="game-mode-selector">
                            <div class="map-selector">
                                <span class="mode-label">ğŸ—ºï¸ åŸå¸‚:</span>
                                <button class="map-btn active" data-map="0" onclick="TowerDefense.selectMap(0)" title="æ»‘é“å¢">Waterloo</button>
                                <button class="map-btn" data-map="1" onclick="TowerDefense.selectMap(1)" title="å¤šä¼¦å¤š">Toronto</button>
                                <button class="map-btn" data-map="2" onclick="TowerDefense.selectMap(2)" title="æ¸©å“¥å">Vancouver</button>
                                <button class="map-btn" data-map="3" onclick="TowerDefense.selectMap(3)" title="é‡‘å£«é¡¿">Kingston</button>
                                <button class="map-btn" data-map="4" onclick="TowerDefense.selectMap(4)" title="è’™ç‰¹åˆ©å°”">Montreal</button>
                                <button class="map-btn" data-map="5" onclick="TowerDefense.selectMap(5)" title="æ¸¥å¤ªå">Ottawa</button>
                                <button class="map-btn" data-map="6" onclick="TowerDefense.selectMap(6)" title="åŸƒå¾·è’™é¡¿">Edmonton</button>
                            </div>
                            <div class="mode-toggle">
                                <label class="endless-toggle">
                                    <input type="checkbox" id="endlessModeCheck" onchange="TowerDefense.toggleEndlessMode()">
                                    <span class="toggle-text">â™¾ï¸ æ— å°½æ¨¡å¼</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <!-- v2.2: é‡æ–°å¸ƒå±€ - ç”»å¸ƒåœ¨ä¸Šï¼Œå·¥å…·æ åœ¨ä¸‹ -->
                    <div class="tower-main">
                        <canvas id="towerCanvas" width="700" height="500"></canvas>
                        <div class="tower-selector">
                            <div class="tower-toolbar">
                                <div class="tower-options">
                                    <button class="tower-option selected" data-type="basic" onclick="TowerDefense.selectTower('basic')" title="Borisç‚®å° - åŸºç¡€ä¼¤å®³å¡”">
                                        <span class="tower-icon">ğŸ”«</span>
                                        <span class="tower-alias">åŸºç¡€å¡”</span>
                                        <span class="tower-cost">ğŸ’°50</span>
                                    </button>
                                    <button class="tower-option" data-type="slow" onclick="TowerDefense.selectTower('slow')" title="Rubyå†°éœœ - å‡é€Ÿæ•Œäºº">
                                        <span class="tower-icon">â„ï¸</span>
                                        <span class="tower-alias">å†°å†»å¡”</span>
                                        <span class="tower-cost">ğŸ’°75</span>
                                    </button>
                                    <button class="tower-option" data-type="splash" onclick="TowerDefense.selectTower('splash')" title="DongQiuçˆ†ç ´ - èŒƒå›´ä¼¤å®³">
                                        <span class="tower-icon">ğŸ’¥</span>
                                        <span class="tower-alias">æº…å°„å¡”</span>
                                        <span class="tower-cost">ğŸ’°100</span>
                                    </button>
                                    <button class="tower-option" data-type="sniper" onclick="TowerDefense.selectTower('sniper')" title="Yunç²¾å‡† - é«˜ä¼¤å®³è¿œç¨‹">
                                        <span class="tower-icon">ğŸ¯</span>
                                        <span class="tower-alias">ç‹™å‡»å¡”</span>
                                        <span class="tower-cost">ğŸ’°150</span>
                                    </button>
                                    <button class="tower-option" data-type="laser" onclick="TowerDefense.selectTower('laser')" title="TRCå…‰æŸ - æŒç»­æ¿€å…‰æ”»å‡»">
                                        <span class="tower-icon">âš¡</span>
                                        <span class="tower-alias">æ¿€å…‰å¡”</span>
                                        <span class="tower-cost">ğŸ’°200</span>
                                    </button>
                                    <button class="tower-option" data-type="poison" onclick="TowerDefense.selectTower('poison')" title="CSEæ¯’é›¾ - èŒƒå›´æŒç»­ä¼¤å®³">
                                        <span class="tower-icon">â˜ ï¸</span>
                                        <span class="tower-alias">æ¯’æ°”å¡”</span>
                                        <span class="tower-cost">ğŸ’°120</span>
                                    </button>
                                    <button class="tower-option" data-type="chain" onclick="TowerDefense.selectTower('chain')" title="CARIé“¾ç”µ - è¿é”é—ªç”µæ”»å‡»">
                                        <span class="tower-icon">ğŸ”Œ</span>
                                        <span class="tower-alias">ç”µç£å¡”</span>
                                        <span class="tower-cost">ğŸ’°180</span>
                                    </button>
                                </div>
                                <div class="skill-bar">
                                    <button class="skill-btn" data-skill="meteor" onclick="TowerDefense.useSkill('meteor')" title="é™¨çŸ³é›¨ [Q]">
                                        <span class="skill-icon">â˜„ï¸</span>
                                        <span class="skill-key">Q</span>
                                        <div class="skill-cooldown" id="meteorCooldown"></div>
                                    </button>
                                    <button class="skill-btn" data-skill="freeze" onclick="TowerDefense.useSkill('freeze')" title="å†°å° [W]">
                                        <span class="skill-icon">ğŸ¥¶</span>
                                        <span class="skill-key">W</span>
                                        <div class="skill-cooldown" id="freezeCooldown"></div>
                                    </button>
                                    <button class="skill-btn" data-skill="slowtime" onclick="TowerDefense.useSkill('slowtime')" title="æ—¶é—´å‡é€Ÿ [E]">
                                        <span class="skill-icon">â±ï¸</span>
                                        <span class="skill-key">E</span>
                                        <div class="skill-cooldown" id="slowtimeCooldown"></div>
                                    </button>
                                    <button class="talent-btn compact" onclick="TowerDefense.showTalentPanel()" title="å¤©èµ‹æ ‘">âœ¨</button>
                                    <button class="challenge-btn compact" onclick="TowerDefense.showChallengePanel()" title="æ¯æ—¥æŒ‘æˆ˜">ğŸ¯</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tower-status" id="towerStatus"></div>
                </div>
            </div>
        </div>

        <!-- Right: Game Instructions -->
        <div class="game-instructions-panel">
            <h3 class="panel-title">æ¸¸æˆè¯´æ˜</h3>

            <!-- Spider Game Instructions -->
            <div class="instructions-content" id="spiderInstructions">
                <div class="instruction-section">
                    <h4>æ“ä½œæ–¹å¼</h4>
                    <ul>
                        <li><kbd>â†‘</kbd><kbd>â†“</kbd><kbd>â†</kbd><kbd>â†’</kbd> æ–¹å‘é”®ç§»åŠ¨</li>
                        <li>ä¹Ÿå¯ä»¥ç”¨ <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>æ¸¸æˆè§„åˆ™</h4>
                    <ul>
                        <li>ä½ æ˜¯ç»¿è‰²å°çƒï¼Œä»è¾¹ç•Œå‡ºå‘</li>
                        <li>è¿›å…¥é»‘è‰²åŒºåŸŸå¼€å§‹ç”»çº¿</li>
                        <li>è¿”å›è“è‰²å®‰å…¨åŒºå®Œæˆå é¢†</li>
                        <li>çº¢è‰²èœ˜è››ä¼šç ´åä½ çš„ç”»çº¿ï¼</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>èƒœåˆ©æ¡ä»¶</h4>
                    <ul>
                        <li>ç®€å•ï¼šå é¢† <b>30%</b> åŒºåŸŸ</li>
                        <li>æ™®é€šï¼šå é¢† <b>50%</b> åŒºåŸŸ</li>
                        <li>å›°éš¾ï¼šå é¢† <b>70%</b> åŒºåŸŸ</li>
                    </ul>
                </div>
                <div class="instruction-section tips">
                    <h4>å°æŠ€å·§</h4>
                    <p>ç”»å°å—åŒºåŸŸæ›´å®‰å…¨ï¼Œä½†éœ€è¦å¤šæ¬¡å é¢†æ‰èƒ½è·èƒœï¼</p>
                </div>
            </div>

            <!-- Breakout Game Instructions -->
            <div class="instructions-content hidden" id="breakoutInstructions">
                <div class="instruction-section">
                    <h4>æ“ä½œæ–¹å¼</h4>
                    <ul>
                        <li><kbd>â†</kbd><kbd>â†’</kbd> æ–¹å‘é”®æ§åˆ¶æŒ¡æ¿</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>æ¸¸æˆè§„åˆ™</h4>
                    <ul>
                        <li>ç”¨æŒ¡æ¿åå¼¹å°çƒ</li>
                        <li>å‡»ç¢æ‰€æœ‰ç –å—å³å¯è·èƒœ</li>
                        <li>å°çƒè½åˆ°åº•éƒ¨åˆ™æ¸¸æˆç»“æŸ</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>èƒœåˆ©æ¡ä»¶</h4>
                    <ul>
                        <li>æ¶ˆç­æ‰€æœ‰ç –å—</li>
                    </ul>
                </div>
                <div class="instruction-section tips">
                    <h4>å°æŠ€å·§</h4>
                    <p>æŒ¡æ¿è¾¹ç¼˜å¯ä»¥æ”¹å˜çƒçš„åå¼¹è§’åº¦ï¼</p>
                </div>
            </div>

            <!-- Zen Instructions -->
            <div class="instructions-content hidden" id="zenInstructions">
                <div class="instruction-section">
                    <h4>å››ç§åŠ¨ç”»</h4>
                    <ul>
                        <li>ğŸŒŒ <b>ä¸‰ä½“</b> - ä¸‰ä½“é—®é¢˜æ¨¡æ‹Ÿ</li>
                        <li>ğŸª <b>è¡Œæ˜Ÿ</b> - å¤ªé˜³ç³»è½¨é“</li>
                        <li>ğŸ”· <b>å‡ ä½•</b> - æ—‹è½¬å¤šè¾¹å½¢</li>
                        <li>ğŸ¯ <b>é’Ÿæ‘†</b> - æ³¢æµªé’Ÿæ‘†</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>ä½¿ç”¨æ–¹å¼</h4>
                    <ul>
                        <li>ç‚¹å‡»æŒ‰é’®åˆ‡æ¢åŠ¨ç”»</li>
                        <li>ç‚¹å‡»æš‚åœ/ç»§ç»­æ§åˆ¶</li>
                    </ul>
                </div>
                <div class="instruction-section tips">
                    <h4>å°è´´å£«</h4>
                    <p>çœ‹ç€è§„å¾‹çš„è¿åŠ¨ï¼Œæ”¾ç©ºå¤§è„‘ï¼Œäº«å—ç‰‡åˆ»å®é™ã€‚</p>
                </div>
            </div>

            <!-- Tower Defense Instructions -->
            <div class="instructions-content hidden" id="towerInstructions">
                <div class="instruction-section">
                    <h4>æ“ä½œæ–¹å¼</h4>
                    <ul>
                        <li>é€‰æ‹©é˜²å¾¡å¡”ç±»å‹ (æˆ–æŒ‰ 1-7)</li>
                        <li>ç‚¹å‡»/æ‹–æ‹½åˆ°åœ°å›¾æ”¾ç½®</li>
                        <li>ç‚¹å‡»"å¼€å§‹æ³¢æ¬¡" (æˆ–ç©ºæ ¼é”®)</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>é˜²å¾¡å¡”ç±»å‹</h4>
                    <ul>
                        <li>ğŸ”« <b>åŸºç¡€å¡”</b> - å¹³è¡¡å‹å•ä½“æ”»å‡»</li>
                        <li>â„ï¸ <b>å†°å†»å¡”</b> - å‡é€Ÿæ•Œäºº50%</li>
                        <li>ğŸ’¥ <b>æº…å°„å¡”</b> - èŒƒå›´AOEä¼¤å®³</li>
                        <li>ğŸ¯ <b>ç‹™å‡»å¡”</b> - é«˜ä¼¤å®³è¶…è¿œç¨‹</li>
                        <li>âš¡ <b>æ¿€å…‰å¡”</b> - æŒç»­å…‰æŸä¼¤å®³</li>
                        <li>â˜ ï¸ <b>æ¯’æ°”å¡”</b> - èŒƒå›´æŒç»­æ‰è¡€</li>
                        <li>ğŸ”Œ <b>ç”µç£å¡”</b> - é“¾å¼è·³è·ƒæ”»å‡»</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>æ¸¸æˆæ¨¡å¼</h4>
                    <ul>
                        <li><b>æ™®é€šæ¨¡å¼</b> - ç”Ÿå­˜10æ³¢èƒœåˆ©</li>
                        <li><b>æ— å°½æ¨¡å¼</b> - æŒ‘æˆ˜æé™ï¼</li>
                        <li><b>3å¼ åœ°å›¾</b> - ä¸åŒè·¯çº¿å¸ƒå±€</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>ä¸»åŠ¨æŠ€èƒ½</h4>
                    <ul>
                        <li><kbd>Q</kbd> â˜„ï¸ é™¨çŸ³é›¨ - èŒƒå›´ä¼¤å®³</li>
                        <li><kbd>W</kbd> ğŸ¥¶ å†°å° - å†»ç»“æ•Œäºº</li>
                        <li><kbd>E</kbd> â±ï¸ æ—¶é—´å‡é€Ÿ</li>
                    </ul>
                </div>
                <div class="instruction-section">
                    <h4>å¿«æ·é”®</h4>
                    <ul>
                        <li><kbd>1-7</kbd> é€‰æ‹©é˜²å¾¡å¡”</li>
                        <li><kbd>ç©ºæ ¼</kbd> å¼€å§‹æ³¢æ¬¡</li>
                        <li><kbd>F</kbd> å…¨å± / <kbd>Esc</kbd> æš‚åœ</li>
                    </ul>
                </div>
                <div class="instruction-section tips">
                    <h4>å°æŠ€å·§</h4>
                    <p>å†°å°+é™¨çŸ³é›¨ç»„åˆæä½³ï¼å¡”ä¼šéšå‡»æ€å‡çº§ï¼</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom: Leaderboards -->
    <div class="leaderboard-section">
        <!-- Spider Game Leaderboard -->
        <div class="leaderboard-container" id="spiderLeaderboardContainer">
            <h3 class="leaderboard-title">ğŸ•·ï¸ ä½ è¿‡æ¥å•Š - æ’è¡Œæ¦œ</h3>
            <div class="leaderboard-tabs">
                <button class="lb-tab" data-diff="easy" onclick="showLeaderboard('easy')">ç®€å•æ¦œ</button>
                <button class="lb-tab active" data-diff="normal" onclick="showLeaderboard('normal')">æ™®é€šæ¦œ</button>
                <button class="lb-tab" data-diff="hard" onclick="showLeaderboard('hard')">å›°éš¾æ¦œ</button>
            </div>
            <div class="leaderboard" id="leaderboard">
                <!-- Spider game leaderboard entries -->
            </div>
        </div>

        <!-- Breakout Game Leaderboard -->
        <div class="leaderboard-container hidden" id="breakoutLeaderboardContainer">
            <h3 class="leaderboard-title">ğŸ§± å„ä¸ªå‡»ç ´ - æ’è¡Œæ¦œ</h3>
            <div class="leaderboard" id="breakoutLeaderboard">
                <!-- Breakout game leaderboard entries -->
            </div>
        </div>

        <!-- Tower Defense Leaderboard -->
        <div class="leaderboard-container hidden" id="towerLeaderboardContainer">
            <h3 class="leaderboard-title">ğŸ° TRCæ”»é˜²å¤§å¸ˆ - æ’è¡Œæ¦œ</h3>
            <div class="leaderboard-tabs">
                <button class="lb-tab active" data-mode="normal" onclick="showTowerLeaderboard('normal')">æ™®é€šæ¨¡å¼</button>
                <button class="lb-tab" data-mode="endless" onclick="showTowerLeaderboard('endless')">æ— å°½æ¨¡å¼</button>
            </div>
            <div class="leaderboard" id="towerLeaderboard">
                <!-- Tower defense leaderboard entries -->
            </div>
        </div>
    </div>

    <!-- Page Footer - Designer Signature -->
    <div class="game-page-footer">
        <span class="footer-text">Designed by</span>
        <span class="footer-signature-text">Boris Huai</span>
    </div>
</div>

<!-- Victory Modal -->
<div class="modal-overlay" id="victoryModal">
    <div class="modal-content">
        <h2>ğŸ‰ æŒ‘æˆ˜æˆåŠŸï¼</h2>
        <div class="victory-stats">
            <p>å é¢†é¢ç§¯: <b id="modalPercent">0</b>%</p>
            <p>ç”¨æ—¶: <b id="modalTime">0.000</b> ç§’</p>
        </div>
        <div class="name-input-group">
            <label>ç•™ä¸‹ä½ çš„å¤§åï¼š</label>
            <input type="text" id="playerName" placeholder="è¾“å…¥å§“å" maxlength="10">
        </div>
        <div class="modal-buttons">
            <button class="btn-submit" onclick="submitScore()">æäº¤æˆç»©</button>
            <button class="btn-skip" onclick="closeModal()">è·³è¿‡</button>
        </div>
    </div>
</div>

<!-- Tower Defense Game Over Modal -->
<div class="modal-overlay" id="towerGameOverModal">
    <div class="modal-content">
        <h2 id="towerModalTitle">ğŸ‰ èƒœåˆ©ï¼</h2>
        <div class="victory-stats">
            <p>ğŸŒŠ é€šè¿‡æ³¢æ¬¡: <b id="towerModalWave">0</b></p>
            <p>ğŸ’€ å‡»æ€æ•Œäºº: <b id="towerModalKills">0</b></p>
            <p>ğŸ—ºï¸ åœ°å›¾: <b id="towerModalMap">ç»å…¸</b></p>
        </div>
        <div class="name-input-group">
            <label>ç•™ä¸‹ä½ çš„å¤§åï¼š</label>
            <input type="text" id="towerPlayerName" placeholder="è¾“å…¥å§“å" maxlength="10">
        </div>
        <div class="modal-buttons">
            <button class="btn-submit" onclick="submitTowerScore()">æäº¤æˆç»©</button>
            <button class="btn-skip" onclick="closeTowerModal()">è·³è¿‡</button>
        </div>
    </div>
</div>

<!-- v2.0: å¤©èµ‹é¢æ¿ -->
<div class="talent-panel" id="talentPanel">
    <div class="talent-content">
        <div class="talent-header">
            <div class="talent-title">âœ¨ å¤©èµ‹æ ‘</div>
            <div class="talent-points">
                å¤©èµ‹ç‚¹: <span id="talentPointsDisplay">0</span>
            </div>
            <button class="talent-close" onclick="TowerDefense.closeTalentPanel()">Ã—</button>
        </div>
        <div class="talent-grid" id="talentGrid">
            <!-- å¤©èµ‹èŠ‚ç‚¹ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
        <div class="talent-actions">
            <button class="talent-reset-btn" onclick="TowerDefense.resetTalents()">ğŸ”„ é‡ç½®å¤©èµ‹</button>
        </div>
        <div style="margin-top: 16px; padding: 12px; background: rgba(139, 92, 246, 0.1); border-radius: 8px; font-size: 0.8rem; color: #9ca3af;">
            <p style="margin: 0 0 8px 0;">ğŸ’¡ <b>æç¤ºï¼š</b>å‡»æ€æ•Œäººè·å¾—å¤©èµ‹ç‚¹æ•°</p>
            <p style="margin: 0;">å¤©èµ‹åŠ æˆä¼šæ°¸ä¹…ä¿ç•™ï¼Œå³ä½¿æ¸¸æˆé‡å¯ä¹Ÿä¸ä¼šæ¶ˆå¤±</p>
        </div>
    </div>
</div>

<!-- v2.0: æ¯æ—¥æŒ‘æˆ˜é¢æ¿ -->
<div class="challenge-panel" id="challengePanel">
    <div class="challenge-content">
        <div class="challenge-header">
            <div class="challenge-title">ğŸ¯ æ¯æ—¥æŒ‘æˆ˜</div>
            <span class="challenge-status active" id="challengeStatus">è¿›è¡Œä¸­</span>
            <button class="challenge-close" onclick="TowerDefense.closeChallengePanel()">Ã—</button>
        </div>
        <div class="challenge-list" id="challengeList">
            <!-- æŒ‘æˆ˜é¡¹ç›®ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
        <div style="margin-top: 16px; padding: 12px; background: rgba(245, 158, 11, 0.1); border-radius: 8px; font-size: 0.8rem; color: #9ca3af;">
            <p style="margin: 0 0 8px 0;">ğŸ’¡ <b>æç¤ºï¼š</b>æ¯æ—¥æŒ‘æˆ˜åœ¨æ¯å¤©0ç‚¹åˆ·æ–°</p>
            <p style="margin: 0;">å®Œæˆæ‰€æœ‰æŒ‘æˆ˜å¯è·å¾—å¤©èµ‹ç‚¹å¥–åŠ±ï¼</p>
        </div>
    </div>
</div>

<style>
.game-page {
    max-width: 1400px;
    margin: 0 auto;
    padding: 15px;
}

.game-header {
    text-align: center;
    margin-bottom: 12px;
}

.game-title {
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(135deg, #ef4444, #f97316);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin: 0 0 8px 0;
}

.game-subtitle {
    color: var(--text-muted);
    font-size: 0.9rem;
    margin: 0;
}

/* ========== Three Column Layout ========== */
.game-main-layout {
    display: flex;
    gap: 15px;
    align-items: flex-start;
    margin-bottom: 15px;
}

/* Left Panel: Game List */
.game-list-panel {
    width: 170px; /* å¢åŠ å®½åº¦é¿å…æ¸¸æˆåç§°æ¢è¡Œ */
    flex-shrink: 0;
    background: var(--bg-card);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06);
}

.panel-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--primary-color);
}

.game-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.game-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px;
    background: #f9fafb;
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: left;
}

.game-item:hover {
    background: #f3f4f6;
    transform: translateX(4px);
}

.game-item.active {
    border-color: var(--primary-color);
    background: linear-gradient(135deg, rgba(102,126,234,0.1), rgba(118,75,162,0.1));
}

.game-item .game-icon {
    font-size: 1.5rem;
}

.game-item .game-info {
    display: flex;
    flex-direction: column;
}

.game-item .game-name {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-primary);
    white-space: nowrap; /* é˜²æ­¢æ¸¸æˆåç§°æ¢è¡Œ */
}

.game-item .game-desc {
    font-size: 0.7rem;
    color: var(--text-muted);
}

/* Center Panel: Game Area */
.game-center-panel {
    flex: 1;
    min-width: 0;
}

.game-wrapper {
    transition: opacity 0.3s ease;
}

.game-wrapper.hidden {
    display: none !important;
}

#breakoutGame:not(.hidden) {
    display: flex;
    justify-content: center;
}

#breakoutGame iframe {
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    max-width: 100%;
}

/* Right Panel: Instructions */
.game-instructions-panel {
    width: 180px;
    flex-shrink: 0;
    background: var(--bg-card);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06);
}

.instructions-content.hidden {
    display: none;
}

.instruction-section {
    margin-bottom: 14px;
}

.instruction-section h4 {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--primary-color);
    margin: 0 0 6px 0;
}

.instruction-section ul {
    margin: 0;
    padding-left: 16px;
    font-size: 0.75rem;
    color: var(--text-secondary);
    line-height: 1.6;
}

.instruction-section kbd {
    display: inline-block;
    padding: 2px 5px;
    background: #f0f0f0;
    border-radius: 4px;
    font-size: 0.7rem;
    font-family: monospace;
    margin: 0 1px;
}

.instruction-section.tips {
    background: rgba(102,126,234,0.08);
    border-radius: 8px;
    padding: 10px;
    margin-bottom: 0;
}

.instruction-section.tips p {
    margin: 0;
    font-size: 0.75rem;
    color: var(--text-secondary);
    line-height: 1.4;
}

/* Leaderboard Section (Bottom) */
.leaderboard-section {
    margin-top: 20px;
}

.leaderboard-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 2px solid var(--primary-color);
}

.leaderboard-container.hidden {
    display: none;
}

.game-container {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
}

.game-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    flex-wrap: wrap;
}

.control-label {
    font-size: 0.8rem;
    color: var(--text-muted);
}

.difficulty-selector {
    display: flex;
    align-items: center;
    gap: 6px;
}

.diff-btn {
    padding: 6px 12px;
    border: 2px solid #e5e7eb;
    background: white;
    border-radius: 6px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s;
}

.diff-btn:hover {
    border-color: var(--primary-color);
}

.diff-btn.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

.diff-btn[data-diff="easy"].active {
    background: #10b981;
    border-color: #10b981;
}

.diff-btn[data-diff="hard"].active {
    background: #ef4444;
    border-color: #ef4444;
}

.game-stats {
    display: flex;
    gap: 12px;
    margin-left: auto;
}

.game-stats .stat {
    font-size: 0.8rem;
    color: var(--text-secondary);
}

.game-stats .stat b {
    color: var(--primary-color);
    font-weight: 600;
}

.game-stats .stat b.timer-value {
    display: inline-block;
    min-width: 4.5em;
    text-align: right;
    color: #ef4444;
    font-family: 'Courier New', monospace;
}

.btn-restart {
    padding: 8px 16px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}

.btn-restart:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102,126,234,0.4);
}

#gameCanvas {
    display: block;
    margin: 0 auto;
    border-radius: 8px;
    background: #1a1a2e;
}

.game-status {
    text-align: center;
    margin-top: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    min-height: 28px;
}

.game-status.success {
    color: #10b981;
}

.game-status.fail {
    color: #ef4444;
}

/* Leaderboard */
.leaderboard-container {
    margin-top: 16px;
    background: var(--bg-card);
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06);
}

.leaderboard-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.lb-tab {
    flex: 1;
    padding: 8px 12px;
    border: 2px solid #e5e7eb;
    background: white;
    border-radius: 8px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s;
}

.lb-tab:hover {
    border-color: var(--primary-color);
}

.lb-tab.active {
    background: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

.lb-tab[data-diff="easy"].active {
    background: #10b981;
    border-color: #10b981;
}

.lb-tab[data-diff="hard"].active {
    background: #ef4444;
    border-color: #ef4444;
}

.leaderboard {
    max-height: 200px;
    overflow-y: auto;
}

.lb-entry {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background: #f9fafb;
    border-radius: 8px;
    margin-bottom: 6px;
    font-size: 0.85rem;
}

.lb-entry:last-child {
    margin-bottom: 0;
}

.lb-rank {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    margin-right: 12px;
    font-size: 0.8rem;
}

.lb-rank.gold {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: white;
}

.lb-rank.silver {
    background: linear-gradient(135deg, #9ca3af, #6b7280);
    color: white;
}

.lb-rank.bronze {
    background: linear-gradient(135deg, #d97706, #b45309);
    color: white;
}

.lb-rank.normal {
    background: #e5e7eb;
    color: #6b7280;
}

.lb-name {
    flex: 1;
    font-weight: 600;
    color: var(--text-primary);
}

.lb-score {
    width: 50px;
    text-align: right;
    color: var(--primary-color);
    font-weight: 600;
}

.lb-time {
    width: 80px;
    text-align: right;
    color: var(--text-secondary);
    font-size: 0.8rem;
}

.lb-date {
    width: 90px;
    text-align: right;
    color: var(--text-muted);
    font-size: 0.75rem;
}

.lb-empty {
    text-align: center;
    padding: 24px;
    color: var(--text-muted);
    font-size: 0.9rem;
}

/* Victory Modal */
.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.modal-overlay.show {
    display: flex;
}

.modal-content {
    background: white;
    border-radius: 16px;
    padding: 32px;
    max-width: 360px;
    width: 90%;
    text-align: center;
    animation: modalIn 0.3s ease;
}

@keyframes modalIn {
    from {
        opacity: 0;
        transform: scale(0.9) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

.modal-content h2 {
    margin: 0 0 16px 0;
    font-size: 1.5rem;
    color: var(--text-primary);
}

.victory-stats {
    background: #f0fdf4;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 20px;
}

.victory-stats p {
    margin: 8px 0;
    font-size: 1rem;
    color: var(--text-secondary);
}

.victory-stats b {
    color: #10b981;
    font-size: 1.2rem;
}

.name-input-group {
    margin-bottom: 20px;
}

.name-input-group label {
    display: block;
    margin-bottom: 8px;
    font-size: 0.9rem;
    color: var(--text-secondary);
}

.name-input-group input {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    font-size: 1rem;
    text-align: center;
    transition: border-color 0.2s;
}

.name-input-group input:focus {
    outline: none;
    border-color: var(--primary-color);
}

.modal-buttons {
    display: flex;
    gap: 12px;
}

.btn-submit {
    flex: 1;
    padding: 12px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    transition: transform 0.2s;
}

.btn-submit:hover {
    transform: translateY(-2px);
}

.btn-skip {
    padding: 12px 20px;
    background: #f3f4f6;
    color: var(--text-secondary);
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
}

.btn-skip:hover {
    background: #e5e7eb;
}

/* Responsive */
@media (max-width: 900px) {
    .game-layout {
        flex-direction: column;
    }
    .game-instructions {
        width: 100%;
    }
    #gameCanvas {
        max-width: 100%;
        height: auto;
    }
}

/* Zen Animation Styles */
.zen-container {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
}

.zen-animation-selector {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
    flex-wrap: wrap;
}

.zen-btn {
    padding: 8px 14px;
    background: #f3f4f6;
    border: 2px solid transparent;
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s ease;
}

.zen-btn:hover {
    background: #e5e7eb;
}

.zen-btn.active {
    background: var(--primary-color);
    color: white;
}

#zenCanvas {
    display: block;
    width: 100%;
    height: 400px;
    background: #0a0a1a;
    border-radius: 8px;
}

.zen-controls-bar {
    display: flex;
    justify-content: center;
    margin-top: 12px;
}

.zen-control-btn {
    padding: 8px 20px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s ease;
}

.zen-control-btn:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

/* Tower Defense Styles */
.tower-container {
    background: var(--bg-card);
    border-radius: 16px;
    padding: 16px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
}

.tower-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 12px;
    margin-bottom: 12px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
    flex-wrap: wrap;
    gap: 10px;
}

.tower-info {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
}

.tower-info .info-item {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.tower-info .info-item b {
    color: var(--primary-color);
    font-weight: 700;
}

.tower-actions {
    display: flex;
    gap: 8px;
}

.tower-btn {
    padding: 8px 16px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s;
}

.tower-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102,126,234,0.4);
}

.tower-btn.restart {
    background: linear-gradient(135deg, #ef4444, #dc2626);
}

.tower-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

/* v1.2: é€Ÿåº¦æŒ‰é’® */
.tower-btn.speed-btn {
    background: linear-gradient(135deg, #10b981, #059669);
    min-width: 45px;
}

.tower-btn.speed-btn.fast {
    background: linear-gradient(135deg, #f59e0b, #d97706);
}

.tower-btn.speed-btn.fastest {
    background: linear-gradient(135deg, #ef4444, #dc2626);
}

/* æš‚åœæŒ‰é’® */
.tower-btn.pause-btn {
    background: linear-gradient(135deg, #6366f1, #4f46e5);
    min-width: 45px;
    font-size: 1rem;
}

.tower-btn.pause-btn.paused {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    animation: pulse-play 1s ease-in-out infinite;
}

@keyframes pulse-play {
    0%, 100% { box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4); }
    50% { box-shadow: 0 2px 16px rgba(34, 197, 94, 0.8); }
}

/* v1.2: æ³¢æ¬¡é¢„å‘Š */
.wave-preview {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: rgba(102, 126, 234, 0.1);
    border-radius: 8px;
    font-size: 0.8rem;
    margin-top: 8px;
}

.wave-preview .preview-label {
    color: var(--text-secondary);
    font-weight: 500;
}

.wave-preview .preview-content {
    color: var(--text-primary);
    font-weight: 600;
}

.wave-preview .enemy-icon {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    padding: 2px 6px;
    background: rgba(0,0,0,0.1);
    border-radius: 4px;
    font-size: 0.75rem;
}

/* v1.3: åœ°å›¾å’Œæ¨¡å¼é€‰æ‹©å™¨ */
.game-mode-selector {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 12px;
    background: rgba(102, 126, 234, 0.05);
    border-radius: 8px;
    margin-top: 8px;
    gap: 12px;
    flex-wrap: wrap;
}

.map-selector, .mode-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
}

.mode-label {
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.map-btn {
    padding: 4px 10px;
    font-size: 0.7rem;
    background: #e5e7eb;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.map-btn:hover {
    background: #d1d5db;
}

.map-btn.active {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
}

.endless-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    font-size: 0.75rem;
}

.endless-toggle input {
    width: 16px;
    height: 16px;
    cursor: pointer;
}

.toggle-text {
    color: var(--text-secondary);
}

.endless-toggle input:checked + .toggle-text {
    color: #ef4444;
    font-weight: 600;
}

/* v1.2: å…¨å±æ¨¡å¼æ ·å¼ */
#towerGame:fullscreen,
#towerGame:-webkit-full-screen {
    background: #1a1a2e;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
}

#towerGame:fullscreen .tower-container,
#towerGame:-webkit-full-screen .tower-container {
    max-width: 1200px;
    width: 100%;
}

#towerGame:fullscreen #towerCanvas,
#towerGame:-webkit-full-screen #towerCanvas {
    width: auto;
    height: 80vh;
    max-height: 600px;
    aspect-ratio: 7 / 5;
}

/* v2.2: é‡æ–°è®¾è®¡å¸ƒå±€ - ç”»å¸ƒå±…ä¸­ï¼Œå¡”å°é€‰æ‹©å™¨åœ¨ä¸‹æ–¹ */
.tower-main {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
}

.tower-selector {
    width: 100%;
    max-width: 720px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.tower-selector h4 {
    font-size: 0.8rem;
    color: var(--text-primary);
    margin: 0;
    text-align: left;
}

.tower-options {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: center;
}

.tower-option {
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 8px 12px;
    background: #f3f4f6;
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
    gap: 8px;
    min-width: 90px;
}

.tower-option:hover {
    background: #e5e7eb;
    transform: scale(1.02);
}

.tower-option.selected {
    border-color: var(--primary-color);
    background: linear-gradient(135deg, rgba(102,126,234,0.15), rgba(118,75,162,0.15));
}

.tower-option .tower-icon {
    font-size: 1.3rem;
    flex-shrink: 0;
    line-height: 1;
}

.tower-option .tower-name {
    font-size: 0.7rem;
    font-weight: 600;
    color: var(--text-primary);
    white-space: nowrap;
    flex-shrink: 0;
    display: none; /* éšè—å…¨åï¼ŒèŠ‚çœç©ºé—´ */
}

.tower-option .tower-cost {
    font-size: 0.7rem;
    color: var(--text-muted);
}

/* å›¢é˜Ÿå…ƒç´ æ ·å¼ */
.team-hint {
    font-size: 0.7rem;
    font-weight: normal;
    color: #8b5cf6;
    margin-left: 8px;
    display: none; /* ç´§å‡‘å¸ƒå±€ä¸‹éšè— */
}

.tower-option .tower-alias {
    font-size: 0.75rem;
    color: var(--text-primary);
    white-space: nowrap;
}

.tower-option:hover .tower-alias {
    color: var(--primary-color);
}

/* v2.2: å·¥å…·æ å¸ƒå±€ */
.tower-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    align-items: center;
    padding: 8px;
    background: rgba(255,255,255,0.8);
    border-radius: 12px;
}

.skill-bar {
    display: flex;
    gap: 6px;
    align-items: center;
}

.talent-btn.compact,
.challenge-btn.compact {
    width: 36px;
    height: 36px;
    padding: 0;
    font-size: 1.2rem;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* åœ°å›¾æŒ‰é’®æ‰©å±• - æ”¯æŒæ›´å¤šåŸå¸‚ */
.map-selector {
    flex-wrap: wrap;
    gap: 4px;
}

.map-btn {
    font-size: 0.65rem;
    padding: 4px 8px;
    min-width: auto;
}

#towerCanvas {
    display: block;
    background: #1a1a2e;
    border-radius: 8px;
    cursor: crosshair;
    width: 700px;
    height: 500px;
    max-width: 100%;
    aspect-ratio: 7 / 5;
}

.tower-status {
    text-align: center;
    margin-top: 12px;
    font-size: 1rem;
    font-weight: 600;
    min-height: 24px;
}

.tower-status.victory {
    color: #10b981;
}

.tower-status.defeat {
    color: #ef4444;
}

/* v2.0: æŠ€èƒ½ç³»ç»Ÿæ ·å¼ */
.skill-bar {
    display: flex;
    gap: 8px;
    margin-top: 8px;
}

.skill-btn {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 12px;
    background: linear-gradient(135deg, #4a1a6b, #2d1b4e);
    border: 2px solid #8b5cf6;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    min-width: 70px;
    overflow: hidden;
}

.skill-btn:hover:not(.on-cooldown) {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
    border-color: #a78bfa;
}

.skill-btn:active:not(.on-cooldown) {
    transform: translateY(0);
}

.skill-btn.on-cooldown {
    opacity: 0.6;
    cursor: not-allowed;
    border-color: #555;
}

.skill-btn.active-skill {
    animation: skill-pulse 0.5s ease-out;
    border-color: #fbbf24;
    box-shadow: 0 0 20px rgba(251, 191, 36, 0.6);
}

@keyframes skill-pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.skill-icon {
    font-size: 1.5rem;
}

.skill-name {
    font-size: 0.65rem;
    color: #e0e0e0;
    margin-top: 2px;
}

.skill-key {
    position: absolute;
    top: 2px;
    right: 4px;
    font-size: 0.6rem;
    color: #888;
    background: rgba(0,0,0,0.4);
    padding: 1px 4px;
    border-radius: 3px;
}

.skill-cooldown {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    transform-origin: bottom;
    transform: scaleY(0);
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    font-weight: bold;
    color: #fff;
}

.skill-cooldown.active {
    transform: scaleY(1);
}

/* æŠ€èƒ½é‡Šæ”¾ç›®æ ‡æ¨¡å¼ */
.skill-targeting #towerCanvas {
    cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><circle cx="16" cy="16" r="14" stroke="%23ff6b6b" stroke-width="2" fill="none"/><line x1="16" y1="4" x2="16" y2="28" stroke="%23ff6b6b" stroke-width="2"/><line x1="4" y1="16" x2="28" y2="16" stroke="%23ff6b6b" stroke-width="2"/></svg>') 16 16, crosshair;
}

/* v2.0: æˆå°±å¼¹çª—æ ·å¼ */
.achievement-popup {
    position: absolute;
    top: 80px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px 20px;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid #fbbf24;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(251, 191, 36, 0.3), 0 0 60px rgba(251, 191, 36, 0.1);
    transform: translateX(120%);
    transition: transform 0.3s ease;
    z-index: 1000;
}

.achievement-popup.show {
    transform: translateX(0);
}

.achievement-icon {
    font-size: 2.5rem;
    animation: achievement-bounce 0.5s ease;
}

@keyframes achievement-bounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}

.achievement-info {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.achievement-title {
    font-size: 0.75rem;
    color: #fbbf24;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.achievement-name {
    font-size: 1.1rem;
    font-weight: bold;
    color: #fff;
}

.achievement-desc {
    font-size: 0.8rem;
    color: #9ca3af;
}

/* v2.0: å¤©èµ‹é¢æ¿ */
.talent-panel {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}

.talent-panel.show {
    display: flex;
}

.talent-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid #8b5cf6;
    border-radius: 16px;
    padding: 24px;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.talent-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.talent-title {
    font-size: 1.5rem;
    font-weight: bold;
    color: #8b5cf6;
}

.talent-points {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    background: rgba(139, 92, 246, 0.2);
    border-radius: 20px;
    color: #c4b5fd;
}

.talent-close {
    background: none;
    border: none;
    color: #9ca3af;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 4px 8px;
}

.talent-close:hover {
    color: #fff;
}

.talent-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 12px;
    margin-bottom: 20px;
}

.talent-node {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px 12px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.talent-node:hover:not(.locked):not(.unlocked) {
    border-color: #8b5cf6;
    background: rgba(139, 92, 246, 0.2);
    transform: translateY(-2px);
}

.talent-node.unlocked {
    border-color: #22c55e;
    background: rgba(34, 197, 94, 0.2);
}

.talent-node.locked {
    opacity: 0.4;
    cursor: not-allowed;
}

.talent-node.no-points {
    opacity: 0.6;
    cursor: not-allowed;
}

.talent-icon {
    font-size: 2rem;
    margin-bottom: 8px;
}

.talent-name {
    font-size: 0.85rem;
    font-weight: 600;
    color: #fff;
    text-align: center;
    margin-bottom: 4px;
}

.talent-cost {
    font-size: 0.75rem;
    color: #9ca3af;
}

.talent-node.unlocked .talent-cost {
    color: #22c55e;
}

.talent-actions {
    display: flex;
    justify-content: center;
    gap: 12px;
}

.talent-reset-btn {
    padding: 10px 20px;
    background: rgba(239, 68, 68, 0.2);
    border: 1px solid #ef4444;
    border-radius: 8px;
    color: #fca5a5;
    cursor: pointer;
    transition: all 0.2s ease;
}

.talent-reset-btn:hover {
    background: rgba(239, 68, 68, 0.3);
}

/* å¤©èµ‹æŒ‰é’® */
.talent-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 14px;
    background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
    border: none;
    border-radius: 8px;
    color: #fff;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.talent-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
}

/* v2.0: æ¯æ—¥æŒ‘æˆ˜é¢æ¿ */
.challenge-panel {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}

.challenge-panel.show {
    display: flex;
}

.challenge-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 2px solid #f59e0b;
    border-radius: 16px;
    padding: 24px;
    max-width: 450px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.challenge-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.challenge-title {
    font-size: 1.5rem;
    font-weight: bold;
    color: #f59e0b;
}

.challenge-status {
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 0.8rem;
}

.challenge-status.active {
    background: rgba(59, 130, 246, 0.2);
    color: #60a5fa;
}

.challenge-status.completed {
    background: rgba(34, 197, 94, 0.2);
    color: #22c55e;
}

.challenge-close {
    background: none;
    border: none;
    color: #9ca3af;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 4px 8px;
}

.challenge-close:hover {
    color: #fff;
}

.challenge-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.challenge-item {
    padding: 16px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    transition: all 0.2s ease;
}

.challenge-item.completed {
    border-color: #22c55e;
    background: rgba(34, 197, 94, 0.1);
}

.challenge-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.challenge-icon {
    font-size: 1.5rem;
}

.challenge-name {
    font-weight: 600;
    color: #fff;
    flex: 1;
}

.challenge-reward {
    font-size: 0.85rem;
    color: #fbbf24;
    font-weight: 600;
}

.challenge-desc {
    font-size: 0.85rem;
    color: #9ca3af;
    margin-bottom: 12px;
}

.challenge-progress-bar {
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 6px;
}

.challenge-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #f59e0b, #fbbf24);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.challenge-item.completed .challenge-progress-fill {
    background: linear-gradient(90deg, #22c55e, #4ade80);
}

.challenge-progress-text {
    font-size: 0.8rem;
    color: #9ca3af;
    text-align: right;
}

.challenge-item.completed .challenge-progress-text {
    color: #22c55e;
}

/* æ¯æ—¥æŒ‘æˆ˜æŒ‰é’® */
.challenge-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 14px;
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    border: none;
    border-radius: 8px;
    color: #fff;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.challenge-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
}

/* Page Footer - è®¾è®¡è€…ç½²å */
.game-page-footer {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 6px;
    padding: 20px 0;
    margin-top: 10px;
    opacity: 0.5;
    transition: opacity 0.3s ease;
}

.game-page-footer:hover {
    opacity: 0.8;
}

.footer-text {
    font-size: 12px;
    color: #666;
    font-style: italic;
}

.footer-signature {
    height: 14px;
    width: auto;
}

.footer-signature-text {
    font-size: 14px;
    font-weight: 600;
    font-style: italic;
    background: linear-gradient(90deg, #4facfe, #00f2fe);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Debug panel styles */
.tower-debug {
    position: absolute;
    top: 5px;
    left: 5px;
    background: rgba(0,0,0,0.7);
    color: #0f0;
    padding: 8px;
    font-size: 10px;
    font-family: monospace;
    border-radius: 4px;
    pointer-events: none;
}
</style>

<script>
// Canvas roundRect polyfill for browser compatibility
if (typeof CanvasRenderingContext2D !== 'undefined' && !CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radii) {
        var radius = typeof radii === 'number' ? radii : (radii && radii[0]) || 0;
        this.beginPath();
        this.moveTo(x + radius, y);
        this.lineTo(x + width - radius, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.lineTo(x + width, y + height - radius);
        this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.lineTo(x + radius, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.lineTo(x, y + radius);
        this.quadraticCurveTo(x, y, x + radius, y);
        this.closePath();
        return this;
    };
}

// Current active game tracking
var currentActiveGame = 'spider';

// Game Switcher
function switchGame(game) {
    // Update game list buttons
    document.querySelectorAll('.game-item').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.game === game);
    });

    // Pause previously active game to save resources
    if (currentActiveGame !== game) {
        if (currentActiveGame === 'tower' && window.TowerDefense) {
            TowerDefense.pause();
        }
        if (currentActiveGame === 'spider' && window.spiderGamePause) {
            spiderGamePause();
        }
        if (currentActiveGame === 'zen' && window.zenPause) {
            zenPause();
        }
    }

    // Toggle game visibility
    document.getElementById('spiderGame').classList.toggle('hidden', game !== 'spider');
    document.getElementById('breakoutGame').classList.toggle('hidden', game !== 'breakout');
    document.getElementById('zenGame').classList.toggle('hidden', game !== 'zen');
    document.getElementById('towerGame').classList.toggle('hidden', game !== 'tower');

    // Toggle instructions visibility
    document.getElementById('spiderInstructions').classList.toggle('hidden', game !== 'spider');
    document.getElementById('breakoutInstructions').classList.toggle('hidden', game !== 'breakout');
    document.getElementById('zenInstructions').classList.toggle('hidden', game !== 'zen');
    document.getElementById('towerInstructions').classList.toggle('hidden', game !== 'tower');

    // Toggle leaderboard visibility
    document.getElementById('spiderLeaderboardContainer').classList.toggle('hidden', game !== 'spider');
    document.getElementById('breakoutLeaderboardContainer').classList.toggle('hidden', game !== 'breakout');
    document.getElementById('towerLeaderboardContainer').classList.toggle('hidden', game !== 'tower');

    // Initialize tower defense leaderboard if selected
    if (game === 'tower') {
        showTowerLeaderboard('normal');
    }

    // Initialize zen if selected
    if (game === 'zen' && !window.zenInitialized) {
        initZenAnimations();
        window.zenInitialized = true;
    }

    // Initialize tower defense if selected (use requestAnimationFrame for better timing)
    if (game === 'tower' && !window.towerInitialized) {
        window.towerInitialized = true;
        // Show loading state on canvas
        var towerCanvas = document.getElementById('towerCanvas');
        if (towerCanvas) {
            var loadCtx = towerCanvas.getContext('2d');
            if (loadCtx) {
                loadCtx.fillStyle = '#1a1a2e';
                loadCtx.fillRect(0, 0, towerCanvas.width, towerCanvas.height);
                loadCtx.fillStyle = '#fff';
                loadCtx.font = '18px sans-serif';
                loadCtx.textAlign = 'center';
                loadCtx.textBaseline = 'middle';
                loadCtx.fillText('â³ åŠ è½½ä¸­...', towerCanvas.width / 2, towerCanvas.height / 2);
            }
        }
        // Use requestAnimationFrame + setTimeout for smooth init
        requestAnimationFrame(function() {
            setTimeout(function() {
                TowerDefense.init();
            }, 16);
        });
    } else if (game === 'tower' && window.TowerDefense) {
        // Resume tower defense if already initialized
        TowerDefense.resume();
    }

    // Resume spider game if switching to it
    if (game === 'spider' && window.spiderGameResume) {
        spiderGameResume();
    }

    // Resume zen if switching to it
    if (game === 'zen' && window.zenResume) {
        zenResume();
    }

    currentActiveGame = game;
}
window.switchGame = switchGame;

// Spider Game
(function() {
    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');
    var W = canvas.width;
    var H = canvas.height;
    var CELL = 10;
    var COLS = W / CELL;
    var ROWS = H / CELL;
    var totalInnerCells = (COLS - 2) * (ROWS - 2);

    // Difficulty settings
    var difficulties = {
        easy: { speed: 1.5, target: 30 },
        normal: { speed: 2.5, target: 50 },
        hard: { speed: 4, target: 70 }
    };
    var currentDifficulty = 'normal';
    var currentLeaderboardTab = 'normal';

    // Game state
    var grid = [];
    var player = { x: 0, y: 0 };
    var enemy = { x: 0, y: 0, dx: 2, dy: 2 };
    var trail = [];
    var isDrawing = false;
    var gameOver = false;
    var gameWon = false;
    var spiderPaused = false; // é¡µé¢ç¦»å¼€æ—¶æš‚åœ
    var keys = {};
    var capturedPercent = 0;

    // Timer
    var gameStartTime = 0;
    var gameElapsedTime = 0;
    var timerInterval = null;
    var gameStarted = false;  // æ ‡è®°æ¸¸æˆæ˜¯å¦å·²å¼€å§‹ï¼ˆç¬¬ä¸€æ¬¡ç§»åŠ¨ï¼‰

    // Leaderboard storage key
    var STORAGE_KEY = 'xonix_leaderboard';

    function getLeaderboard() {
        try {
            var data = localStorage.getItem(STORAGE_KEY);
            return data ? JSON.parse(data) : { easy: [], normal: [], hard: [] };
        } catch (e) {
            return { easy: [], normal: [], hard: [] };
        }
    }

    function saveLeaderboard(lb) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(lb));
    }

    function addScore(difficulty, name, score, timeMs) {
        var lb = getLeaderboard();
        lb[difficulty].push({
            name: name,
            score: score,
            time: timeMs,
            date: new Date().toISOString()
        });
        // Sort by time (fastest first)
        lb[difficulty].sort(function(a, b) { return a.time - b.time; });
        // Keep top 10
        lb[difficulty] = lb[difficulty].slice(0, 10);
        saveLeaderboard(lb);
    }

    function formatTime(ms) {
        return (ms / 1000).toFixed(3);
    }

    function formatDate(isoString) {
        var d = new Date(isoString);
        var m = (d.getMonth() + 1).toString().padStart(2, '0');
        var day = d.getDate().toString().padStart(2, '0');
        var h = d.getHours().toString().padStart(2, '0');
        var min = d.getMinutes().toString().padStart(2, '0');
        return m + '/' + day + ' ' + h + ':' + min;
    }

    function renderLeaderboard(difficulty) {
        var lb = getLeaderboard();
        var entries = lb[difficulty] || [];
        var container = document.getElementById('leaderboard');

        if (entries.length === 0) {
            container.innerHTML = '<div class="lb-empty">æš‚æ— è®°å½•ï¼Œæˆä¸ºç¬¬ä¸€ä¸ªæŒ‘æˆ˜è€…ï¼</div>';
            return;
        }

        var html = '';
        entries.forEach(function(entry, index) {
            var rankClass = index === 0 ? 'gold' : (index === 1 ? 'silver' : (index === 2 ? 'bronze' : 'normal'));
            html += '<div class="lb-entry">' +
                '<div class="lb-rank ' + rankClass + '">' + (index + 1) + '</div>' +
                '<div class="lb-name">' + escapeHtml(entry.name) + '</div>' +
                '<div class="lb-score">' + entry.score + '%</div>' +
                '<div class="lb-time">' + formatTime(entry.time) + 's</div>' +
                '<div class="lb-date">' + formatDate(entry.date) + '</div>' +
            '</div>';
        });
        container.innerHTML = html;
    }

    function showLeaderboard(difficulty) {
        currentLeaderboardTab = difficulty;
        document.querySelectorAll('.lb-tab').forEach(function(tab) {
            tab.classList.toggle('active', tab.dataset.diff === difficulty);
        });
        renderLeaderboard(difficulty);
    }
    window.showLeaderboard = showLeaderboard;

    function escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;')
                  .replace(/"/g, '&quot;');
    }

    function setDifficulty(diff) {
        currentDifficulty = diff;
        document.querySelectorAll('.diff-btn').forEach(function(btn) {
            btn.classList.toggle('active', btn.dataset.diff === diff);
        });
        document.getElementById('targetPercent').textContent = difficulties[diff].target;
        initGame();
    }
    window.setDifficulty = setDifficulty;

    function startTimer() {
        gameStartTime = performance.now();
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(function() {
            if (!gameOver) {
                gameElapsedTime = performance.now() - gameStartTime;
                document.getElementById('gameTimer').textContent = formatTime(gameElapsedTime);
            }
        }, 10);
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
        gameElapsedTime = performance.now() - gameStartTime;
    }

    function initGame() {
        grid = [];
        for (var r = 0; r < ROWS; r++) {
            grid[r] = [];
            for (var c = 0; c < COLS; c++) {
                grid[r][c] = (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) ? 1 : 0;
            }
        }

        player.x = 0;
        player.y = Math.floor(ROWS / 2);

        var speed = difficulties[currentDifficulty].speed;
        enemy.x = W / 2;
        enemy.y = H / 2;
        enemy.dx = speed * (Math.random() > 0.5 ? 1 : -1);
        enemy.dy = speed * (Math.random() > 0.5 ? 1 : -1);

        trail = [];
        isDrawing = false;
        gameOver = false;
        gameWon = false;
        capturedPercent = 0;
        gameElapsedTime = 0;
        gameStarted = false;  // é‡ç½®æ¸¸æˆå¼€å§‹æ ‡è®°

        updateStats();
        document.getElementById('gameStatus').textContent = '';
        document.getElementById('gameStatus').className = 'game-status';
        document.getElementById('gameTimer').textContent = '0.000';

        // è®¡æ—¶å™¨å°†åœ¨ç¬¬ä¸€æ¬¡ç§»åŠ¨æ—¶å¯åŠ¨
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }
    window.initGame = initGame;

    function updateStats() {
        var captured = 0;
        for (var r = 1; r < ROWS - 1; r++) {
            for (var c = 1; c < COLS - 1; c++) {
                if (grid[r][c] === 1) captured++;
            }
        }
        capturedPercent = Math.round((captured / totalInnerCells) * 100);
        document.getElementById('capturedPercent').textContent = capturedPercent;
    }

    function isSafe(gx, gy) {
        if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return false;
        return grid[gy][gx] === 1;
    }

    function isOnTrail(gx, gy) {
        for (var i = 0; i < trail.length; i++) {
            if (trail[i].x === gx && trail[i].y === gy) return true;
        }
        return false;
    }

    function fillCapturedArea() {
        if (trail.length < 2) return;

        for (var i = 0; i < trail.length; i++) {
            var t = trail[i];
            if (t.x >= 0 && t.x < COLS && t.y >= 0 && t.y < ROWS) {
                grid[t.y][t.x] = 1;
            }
        }

        var tempGrid = [];
        for (var r = 0; r < ROWS; r++) {
            tempGrid[r] = grid[r].slice();
        }

        var enemyGx = Math.max(1, Math.min(COLS - 2, Math.floor(enemy.x / CELL)));
        var enemyGy = Math.max(1, Math.min(ROWS - 2, Math.floor(enemy.y / CELL)));

        var queue = [{x: enemyGx, y: enemyGy}];
        var visited = {};

        while (queue.length > 0) {
            var cell = queue.shift();
            var key = cell.x + ',' + cell.y;
            if (visited[key]) continue;
            if (cell.x < 0 || cell.x >= COLS || cell.y < 0 || cell.y >= ROWS) continue;
            if (tempGrid[cell.y][cell.x] === 1) continue;

            visited[key] = true;
            tempGrid[cell.y][cell.x] = 2;

            queue.push({x: cell.x + 1, y: cell.y});
            queue.push({x: cell.x - 1, y: cell.y});
            queue.push({x: cell.x, y: cell.y + 1});
            queue.push({x: cell.x, y: cell.y - 1});
        }

        for (var r = 0; r < ROWS; r++) {
            for (var c = 0; c < COLS; c++) {
                if (tempGrid[r][c] === 0) {
                    grid[r][c] = 1;
                }
            }
        }

        updateStats();
    }

    function updatePlayer() {
        if (gameOver) return;

        var dx = 0, dy = 0;
        if (keys['ArrowUp'] || keys['KeyW']) dy = -1;
        if (keys['ArrowDown'] || keys['KeyS']) dy = 1;
        if (keys['ArrowLeft'] || keys['KeyA']) dx = -1;
        if (keys['ArrowRight'] || keys['KeyD']) dx = 1;

        if (dx !== 0 && dy !== 0) dy = 0;
        if (dx === 0 && dy === 0) return;

        // ç¬¬ä¸€æ¬¡ç§»åŠ¨æ—¶å¯åŠ¨è®¡æ—¶å™¨
        if (!gameStarted) {
            gameStarted = true;
            startTimer();
        }

        var newX = player.x + dx;
        var newY = player.y + dy;

        if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS) return;

        var wasOnSafe = isSafe(player.x, player.y);
        var willBeOnSafe = isSafe(newX, newY);

        if (isOnTrail(newX, newY)) {
            failGame();
            return;
        }

        player.x = newX;
        player.y = newY;

        if (wasOnSafe && !willBeOnSafe) {
            isDrawing = true;
            trail = [{x: player.x, y: player.y}];
        } else if (isDrawing && !willBeOnSafe) {
            trail.push({x: player.x, y: player.y});
        } else if (isDrawing && willBeOnSafe) {
            trail.push({x: player.x, y: player.y});
            fillCapturedArea();
            trail = [];
            isDrawing = false;
            checkWin();
        }
    }

    function updateEnemy() {
        if (gameOver) return;

        var newX = enemy.x + enemy.dx;
        var newY = enemy.y + enemy.dy;
        var hitWall = false;

        if (isSafe(Math.floor((newX + (enemy.dx > 0 ? CELL/2 : -CELL/2)) / CELL), Math.floor(enemy.y / CELL))) {
            enemy.dx = -enemy.dx;
            hitWall = true;
        }
        if (isSafe(Math.floor(enemy.x / CELL), Math.floor((newY + (enemy.dy > 0 ? CELL/2 : -CELL/2)) / CELL))) {
            enemy.dy = -enemy.dy;
            hitWall = true;
        }

        if (!hitWall) {
            enemy.x = newX;
            enemy.y = newY;
        }

        if (isDrawing) {
            var egx = Math.floor(enemy.x / CELL);
            var egy = Math.floor(enemy.y / CELL);
            if (isOnTrail(egx, egy)) {
                failGame();
            }
        }
    }

    function failGame() {
        gameOver = true;
        stopTimer();
        document.getElementById('gameStatus').textContent = 'å¤±è´¥ï¼èœ˜è››ç¢°åˆ°äº†ä½ çš„çº¿ï¼';
        document.getElementById('gameStatus').className = 'game-status fail';
    }

    function checkWin() {
        var target = difficulties[currentDifficulty].target;
        if (capturedPercent >= target) {
            gameOver = true;
            gameWon = true;
            stopTimer();
            document.getElementById('gameStatus').textContent = 'èƒœåˆ©ï¼å é¢†äº† ' + capturedPercent + '% çš„é¢†åœ°ï¼';
            document.getElementById('gameStatus').className = 'game-status success';
            showVictoryModal();
        }
    }

    function showVictoryModal() {
        document.getElementById('modalPercent').textContent = capturedPercent;
        document.getElementById('modalTime').textContent = formatTime(gameElapsedTime);
        document.getElementById('playerName').value = localStorage.getItem('lastPlayerName') || '';
        document.getElementById('victoryModal').classList.add('show');
        document.getElementById('playerName').focus();
    }

    function closeModal() {
        document.getElementById('victoryModal').classList.remove('show');
    }
    window.closeModal = closeModal;

    function submitScore() {
        var name = document.getElementById('playerName').value.trim();
        if (!name) {
            name = 'åŒ¿åç©å®¶';
        }
        localStorage.setItem('lastPlayerName', name);
        addScore(currentDifficulty, name, capturedPercent, Math.round(gameElapsedTime));
        closeModal();
        showLeaderboard(currentDifficulty);
    }
    window.submitScore = submitScore;

    // Enter key to submit
    document.getElementById('playerName').addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            submitScore();
        }
    });

    function draw() {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, W, H);

        for (var r = 0; r < ROWS; r++) {
            for (var c = 0; c < COLS; c++) {
                if (grid[r][c] === 1) {
                    ctx.fillStyle = 'rgba(102, 126, 234, 0.35)';
                    ctx.fillRect(c * CELL, r * CELL, CELL, CELL);
                }
            }
        }

        if (trail.length > 0) {
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(trail[0].x * CELL + CELL/2, trail[0].y * CELL + CELL/2);
            for (var i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x * CELL + CELL/2, trail[i].y * CELL + CELL/2);
            }
            ctx.stroke();

            ctx.fillStyle = '#fbbf24';
            for (var i = 0; i < trail.length; i++) {
                ctx.beginPath();
                ctx.arc(trail[i].x * CELL + CELL/2, trail[i].y * CELL + CELL/2, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Player
        ctx.fillStyle = '#10b981';
        ctx.shadowColor = '#10b981';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(player.x * CELL + CELL/2, player.y * CELL + CELL/2, CELL/2 + 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Enemy (spider)
        ctx.fillStyle = '#ef4444';
        ctx.shadowColor = '#ef4444';
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, CELL/2 + 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw progress bar
        var barWidth = 100;
        var barHeight = 8;
        var barX = W - barWidth - 10;
        var barY = 10;
        var target = difficulties[currentDifficulty].target;
        var progress = Math.min(capturedPercent / target, 1);

        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        ctx.fillStyle = capturedPercent >= target ? '#10b981' : '#667eea';
        ctx.fillRect(barX, barY, barWidth * progress, barHeight);

        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.strokeRect(barX, barY, barWidth, barHeight);

        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.fillText(capturedPercent + '%', barX + barWidth + 5, barY + 8);
    }

    var lastUpdate = 0;
    var updateInterval = 80;

    function gameLoop(timestamp) {
        if (!spiderPaused) {
            if (timestamp - lastUpdate > updateInterval) {
                updatePlayer();
                lastUpdate = timestamp;
            }
            updateEnemy();
        }
        draw();

        // ç»˜åˆ¶æš‚åœæç¤º
        if (spiderPaused && !gameOver && !gameWon) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â¸ æ¸¸æˆå·²æš‚åœ', W / 2, H / 2 - 20);
            ctx.font = '14px sans-serif';
            ctx.fillText('è¿”å›æœ¬é¡µé¢ç»§ç»­æ¸¸æˆ', W / 2, H / 2 + 15);
        }

        requestAnimationFrame(gameLoop);
    }

    // æš‚åœ/æ¢å¤å‡½æ•° (ä¾›å…¨å±€è°ƒç”¨)
    window.spiderGamePause = function() { spiderPaused = true; };
    window.spiderGameResume = function() { spiderPaused = false; };

    document.addEventListener('keydown', function(e) {
        keys[e.code] = true;
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', function(e) {
        keys[e.code] = false;
    });

    // Initialize
    initGame();
    showLeaderboard('normal');
    requestAnimationFrame(gameLoop);
})();

// ========== Zen Animations ==========
var zenCanvas, zenCtx, zenCurrentAnim = 'threebody', zenIsPaused = false, zenAnimId = null;
var zenBodies = [], zenPlanets = [], zenPendulums = [], zenGeoAngle = 0, zenTime = 0;

function initZenAnimations() {
    zenCanvas = document.getElementById('zenCanvas');
    zenCtx = zenCanvas.getContext('2d');
    zenCanvas.width = zenCanvas.offsetWidth;
    zenCanvas.height = 400;
    initZenThreeBody();
    zenAnimate();
}

function initZenThreeBody() {
    zenBodies = [
        { x: zenCanvas.width/2 - 100, y: zenCanvas.height/2, vx: 0, vy: 1.5, mass: 20, color: '#f87171', trail: [] },
        { x: zenCanvas.width/2 + 100, y: zenCanvas.height/2, vx: 0, vy: -1.5, mass: 20, color: '#60a5fa', trail: [] },
        { x: zenCanvas.width/2, y: zenCanvas.height/2 - 100, vx: 1.5, vy: 0, mass: 20, color: '#34d399', trail: [] }
    ];
}

function initZenOrbits() {
    zenPlanets = [
        { orbit: 50, speed: 0.03, size: 6, color: '#fbbf24', angle: 0 },
        { orbit: 80, speed: 0.02, size: 8, color: '#60a5fa', angle: Math.PI/3 },
        { orbit: 120, speed: 0.015, size: 10, color: '#34d399', angle: Math.PI/2 },
        { orbit: 160, speed: 0.01, size: 9, color: '#f87171', angle: Math.PI },
        { orbit: 200, speed: 0.007, size: 12, color: '#a78bfa', angle: Math.PI*1.5 }
    ];
}

function initZenPendulum() {
    zenPendulums = [];
    for (var i = 0; i < 15; i++) {
        zenPendulums.push({ length: 80 + i * 12, frequency: 0.5 + i * 0.03 });
    }
}

function drawZenThreeBody() {
    var G = 0.5, dt = 0.5;
    for (var i = 0; i < zenBodies.length; i++) {
        var ax = 0, ay = 0;
        for (var j = 0; j < zenBodies.length; j++) {
            if (i !== j) {
                var dx = zenBodies[j].x - zenBodies[i].x;
                var dy = zenBodies[j].y - zenBodies[i].y;
                var dist = Math.sqrt(dx*dx + dy*dy) + 10;
                var force = G * zenBodies[j].mass / (dist * dist);
                ax += force * dx / dist;
                ay += force * dy / dist;
            }
        }
        zenBodies[i].vx += ax * dt;
        zenBodies[i].vy += ay * dt;
    }
    for (var i = 0; i < zenBodies.length; i++) {
        zenBodies[i].x += zenBodies[i].vx * dt;
        zenBodies[i].y += zenBodies[i].vy * dt;
        if (zenBodies[i].x < 50 || zenBodies[i].x > zenCanvas.width - 50) zenBodies[i].vx *= -0.8;
        if (zenBodies[i].y < 50 || zenBodies[i].y > zenCanvas.height - 50) zenBodies[i].vy *= -0.8;
        zenBodies[i].x = Math.max(50, Math.min(zenCanvas.width - 50, zenBodies[i].x));
        zenBodies[i].y = Math.max(50, Math.min(zenCanvas.height - 50, zenBodies[i].y));
        zenBodies[i].trail.push({ x: zenBodies[i].x, y: zenBodies[i].y });
        if (zenBodies[i].trail.length > 80) zenBodies[i].trail.shift();
    }
    zenCtx.fillStyle = 'rgba(10, 10, 26, 0.1)';
    zenCtx.fillRect(0, 0, zenCanvas.width, zenCanvas.height);
    for (var i = 0; i < zenBodies.length; i++) {
        zenCtx.beginPath();
        zenCtx.strokeStyle = zenBodies[i].color;
        zenCtx.lineWidth = 2;
        for (var j = 0; j < zenBodies[i].trail.length; j++) {
            zenCtx.globalAlpha = j / zenBodies[i].trail.length * 0.5;
            if (j === 0) zenCtx.moveTo(zenBodies[i].trail[j].x, zenBodies[i].trail[j].y);
            else zenCtx.lineTo(zenBodies[i].trail[j].x, zenBodies[i].trail[j].y);
        }
        zenCtx.stroke();
        zenCtx.globalAlpha = 1;
        zenCtx.beginPath();
        zenCtx.fillStyle = zenBodies[i].color;
        zenCtx.shadowColor = zenBodies[i].color;
        zenCtx.shadowBlur = 15;
        zenCtx.arc(zenBodies[i].x, zenBodies[i].y, 10, 0, Math.PI * 2);
        zenCtx.fill();
        zenCtx.shadowBlur = 0;
    }
}

function drawZenOrbits() {
    var cx = zenCanvas.width / 2, cy = zenCanvas.height / 2;
    zenCtx.fillStyle = 'rgba(10, 10, 26, 0.05)';
    zenCtx.fillRect(0, 0, zenCanvas.width, zenCanvas.height);
    for (var i = 0; i < zenPlanets.length; i++) {
        zenCtx.beginPath();
        zenCtx.strokeStyle = 'rgba(255,255,255,0.1)';
        zenCtx.arc(cx, cy, zenPlanets[i].orbit, 0, Math.PI * 2);
        zenCtx.stroke();
    }
    zenCtx.beginPath();
    zenCtx.fillStyle = '#fbbf24';
    zenCtx.shadowColor = '#fbbf24';
    zenCtx.shadowBlur = 25;
    zenCtx.arc(cx, cy, 18, 0, Math.PI * 2);
    zenCtx.fill();
    zenCtx.shadowBlur = 0;
    for (var i = 0; i < zenPlanets.length; i++) {
        zenPlanets[i].angle += zenPlanets[i].speed;
        var x = cx + Math.cos(zenPlanets[i].angle) * zenPlanets[i].orbit;
        var y = cy + Math.sin(zenPlanets[i].angle) * zenPlanets[i].orbit;
        zenCtx.beginPath();
        zenCtx.fillStyle = zenPlanets[i].color;
        zenCtx.shadowColor = zenPlanets[i].color;
        zenCtx.shadowBlur = 12;
        zenCtx.arc(x, y, zenPlanets[i].size, 0, Math.PI * 2);
        zenCtx.fill();
        zenCtx.shadowBlur = 0;
    }
}

function drawZenGeometry() {
    var cx = zenCanvas.width / 2, cy = zenCanvas.height / 2;
    zenCtx.fillStyle = 'rgba(10, 10, 26, 0.05)';
    zenCtx.fillRect(0, 0, zenCanvas.width, zenCanvas.height);
    zenGeoAngle += 0.01;
    var colors = ['#f87171', '#fbbf24', '#34d399', '#60a5fa', '#a78bfa', '#f472b6'];
    for (var layer = 0; layer < 6; layer++) {
        var sides = 3 + layer, radius = 40 + layer * 28;
        var rotation = zenGeoAngle * (layer % 2 === 0 ? 1 : -1) * (1 + layer * 0.2);
        zenCtx.beginPath();
        zenCtx.strokeStyle = colors[layer];
        zenCtx.lineWidth = 2;
        zenCtx.shadowColor = colors[layer];
        zenCtx.shadowBlur = 8;
        for (var i = 0; i <= sides; i++) {
            var angle = rotation + (i * 2 * Math.PI / sides);
            var x = cx + Math.cos(angle) * radius;
            var y = cy + Math.sin(angle) * radius;
            if (i === 0) zenCtx.moveTo(x, y);
            else zenCtx.lineTo(x, y);
        }
        zenCtx.closePath();
        zenCtx.stroke();
        zenCtx.shadowBlur = 0;
    }
    var pulse = Math.sin(zenGeoAngle * 3) * 8 + 15;
    zenCtx.beginPath();
    zenCtx.fillStyle = 'rgba(255,255,255,0.8)';
    zenCtx.arc(cx, cy, pulse, 0, Math.PI * 2);
    zenCtx.fill();
}

function drawZenPendulum() {
    zenCtx.fillStyle = 'rgba(10, 10, 26, 0.1)';
    zenCtx.fillRect(0, 0, zenCanvas.width, zenCanvas.height);
    var startX = (zenCanvas.width - (zenPendulums.length - 1) * 35) / 2, startY = 40;
    zenTime += 0.02;
    for (var i = 0; i < zenPendulums.length; i++) {
        var p = zenPendulums[i];
        var angle = Math.sin(zenTime * p.frequency) * (Math.PI / 4);
        var x = startX + i * 35;
        var endX = x + Math.sin(angle) * p.length;
        var endY = startY + Math.cos(angle) * p.length;
        zenCtx.beginPath();
        zenCtx.strokeStyle = 'rgba(255,255,255,0.3)';
        zenCtx.lineWidth = 1;
        zenCtx.moveTo(x, startY);
        zenCtx.lineTo(endX, endY);
        zenCtx.stroke();
        var hue = (i / zenPendulums.length) * 360;
        zenCtx.beginPath();
        zenCtx.fillStyle = 'hsl(' + hue + ', 70%, 60%)';
        zenCtx.shadowColor = 'hsl(' + hue + ', 70%, 60%)';
        zenCtx.shadowBlur = 12;
        zenCtx.arc(endX, endY, 10, 0, Math.PI * 2);
        zenCtx.fill();
        zenCtx.shadowBlur = 0;
    }
    zenCtx.beginPath();
    zenCtx.strokeStyle = 'rgba(255,255,255,0.5)';
    zenCtx.lineWidth = 3;
    zenCtx.moveTo(startX - 15, startY);
    zenCtx.lineTo(startX + (zenPendulums.length - 1) * 35 + 15, startY);
    zenCtx.stroke();
}

function zenAnimate() {
    if (!zenIsPaused) {
        switch(zenCurrentAnim) {
            case 'threebody': drawZenThreeBody(); break;
            case 'orbits': drawZenOrbits(); break;
            case 'geometry': drawZenGeometry(); break;
            case 'pendulum': drawZenPendulum(); break;
        }
    }
    zenAnimId = requestAnimationFrame(zenAnimate);
}

function switchZenAnim(anim) {
    zenCurrentAnim = anim;
    zenCtx.fillStyle = '#0a0a1a';
    zenCtx.fillRect(0, 0, zenCanvas.width, zenCanvas.height);
    document.querySelectorAll('.zen-btn').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.anim === anim);
    });
    switch(anim) {
        case 'threebody': initZenThreeBody(); break;
        case 'orbits': initZenOrbits(); break;
        case 'pendulum': initZenPendulum(); break;
    }
    zenTime = 0;
}
window.switchZenAnim = switchZenAnim;

function toggleZenPause() {
    zenIsPaused = !zenIsPaused;
    document.getElementById('zen-pause-icon').textContent = zenIsPaused ? 'â–¶' : 'â¸';
    document.getElementById('zen-pause-text').textContent = zenIsPaused ? 'ç»§ç»­' : 'æš‚åœ';
}
window.toggleZenPause = toggleZenPause;

// Zen game pause/resume functions for game switcher
function zenPause() {
    zenIsPaused = true;
    var icon = document.getElementById('zen-pause-icon');
    var text = document.getElementById('zen-pause-text');
    if (icon) icon.textContent = 'â–¶';
    if (text) text.textContent = 'ç»§ç»­';
}
window.zenPause = zenPause;

function zenResume() {
    zenIsPaused = false;
    var icon = document.getElementById('zen-pause-icon');
    var text = document.getElementById('zen-pause-text');
    if (icon) icon.textContent = 'â¸';
    if (text) text.textContent = 'æš‚åœ';
}
window.zenResume = zenResume;

// ========== Tower Defense Game ==========
var TowerDefense = (function() {
    // Canvas and context
    var canvas, ctx;
    var W = 700, H = 500;
    var CELL = 50; // Grid cell size
    var COLS = Math.floor(W / CELL);
    var ROWS = Math.floor(H / CELL);

    // èƒŒæ™¯å›¾ç‰‡ç¼“å­˜
    var mapBgImages = {};
    var bgImageOpacity = 0.2; // èƒŒæ™¯å›¾ç‰‡é€æ˜åº¦ï¼ˆæ›´æ·¡ï¼Œä¸å½±å“æ¸¸æˆï¼‰

    // Game state
    var gold = 100;
    var lives = 10;
    var wave = 0;
    var maxWave = 10;
    var kills = 0;
    var gameOver = false;
    var waveInProgress = false;
    var debugMode = false;
    var isPaused = false; // é¡µé¢ç¦»å¼€æ—¶æš‚åœ

    // v1.2: æ¸¸æˆé€Ÿåº¦ (1, 2, 4)
    var gameSpeed = 1;
    var SPEED_OPTIONS = [1, 2, 4];
    var currentSpeedIndex = 0;

    // v1.2: ä¼¤å®³æ•°å­—
    var damageNumbers = [];

    // v1.2: éŸ³æ•ˆç³»ç»Ÿ
    var soundEnabled = true;
    var audioContext = null;
    var sounds = {};

    // v1.3: æ¸¸æˆæ¨¡å¼å’Œåœ°å›¾
    var isEndlessMode = false;
    var currentMapIndex = 0;
    var MAPS = [
        // åœ°å›¾1: Waterloo æ»‘é“å¢ - Så½¢ç»å…¸è·¯çº¿
        {
            name: 'Waterloo',
            nameZh: 'æ»‘é“å¢',
            bgImage: '/PrtSc/TRC.png',
            bgGradient: ['#1a365d', '#2c5282'], // æ·±è“è‰²è°ƒ
            path: [
                { x: 0, y: 200 },
                { x: 150, y: 200 },
                { x: 150, y: 350 },
                { x: 400, y: 350 },
                { x: 400, y: 100 },
                { x: 600, y: 100 },
                { x: 600, y: 400 },
                { x: 700, y: 400 }
            ]
        },
        // åœ°å›¾2: Toronto å¤šä¼¦å¤š - èºæ—‹è¿·å®«
        {
            name: 'Toronto',
            nameZh: 'å¤šä¼¦å¤š',
            bgImage: '/PrtSc/FRC.png',
            bgGradient: ['#742a2a', '#9b2c2c'], // çº¢æ£•è‰²è°ƒ(CNå¡”) - å¤‡ç”¨
            path: [
                { x: 0, y: 250 },
                { x: 200, y: 250 },
                { x: 200, y: 100 },
                { x: 500, y: 100 },
                { x: 500, y: 250 },
                { x: 350, y: 250 },
                { x: 350, y: 400 },
                { x: 700, y: 400 }
            ]
        },
        // åœ°å›¾3: Vancouver æ¸©å“¥å - äº¤å‰è·¯çº¿
        {
            name: 'Vancouver',
            nameZh: 'æ¸©å“¥å',
            bgGradient: ['#234e52', '#2c7a7b'], // é’ç»¿è‰²è°ƒ(æµ·æ´‹)
            path: [
                { x: 0, y: 150 },
                { x: 250, y: 150 },
                { x: 350, y: 250 },
                { x: 450, y: 250 },
                { x: 550, y: 350 },
                { x: 700, y: 350 }
            ]
        },
        // åœ°å›¾4: Kingston é‡‘å£«é¡¿ - Zå½¢é—ªç”µ
        {
            name: 'Kingston',
            nameZh: 'é‡‘å£«é¡¿',
            bgGradient: ['#44337a', '#6b46c1'], // ç´«è‰²è°ƒ(çš‡å®¶)
            path: [
                { x: 0, y: 100 },
                { x: 300, y: 100 },
                { x: 300, y: 250 },
                { x: 100, y: 250 },
                { x: 100, y: 400 },
                { x: 500, y: 400 },
                { x: 500, y: 300 },
                { x: 700, y: 300 }
            ]
        },
        // åœ°å›¾5: Montreal è’™ç‰¹åˆ©å°” - åŒSæ›²çº¿
        {
            name: 'Montreal',
            nameZh: 'è’™ç‰¹åˆ©å°”',
            bgGradient: ['#1a202c', '#4a5568'], // ç°é»‘è‰²è°ƒ(ç°ä»£éƒ½å¸‚)
            path: [
                { x: 0, y: 450 },
                { x: 200, y: 450 },
                { x: 200, y: 150 },
                { x: 400, y: 150 },
                { x: 400, y: 350 },
                { x: 550, y: 350 },
                { x: 550, y: 80 },
                { x: 700, y: 80 }
            ]
        },
        // åœ°å›¾6: Ottawa æ¸¥å¤ªå - å¿ƒå½¢è·¯çº¿
        {
            name: 'Ottawa',
            nameZh: 'æ¸¥å¤ªå',
            bgGradient: ['#7b341e', '#c05621'], // æ©™æ£•è‰²è°ƒ(å›½ä¼šå±±)
            path: [
                { x: 0, y: 250 },
                { x: 150, y: 100 },
                { x: 350, y: 200 },
                { x: 550, y: 100 },
                { x: 700, y: 250 },
                { x: 550, y: 400 },
                { x: 350, y: 350 },
                { x: 700, y: 450 }
            ]
        },
        // åœ°å›¾7: Edmonton åŸƒå¾·è’™é¡¿ - å›å­—å½¢
        {
            name: 'Edmonton',
            nameZh: 'åŸƒå¾·è’™é¡¿',
            bgGradient: ['#1c4532', '#276749'], // æ·±ç»¿è‰²è°ƒ(è‰åŸ)
            path: [
                { x: 0, y: 80 },
                { x: 620, y: 80 },
                { x: 620, y: 420 },
                { x: 80, y: 420 },
                { x: 80, y: 180 },
                { x: 450, y: 180 },
                { x: 450, y: 320 },
                { x: 700, y: 320 }
            ]
        }
    ];

    // v1.3: æ¿€å…‰å¡”çš„å…‰æŸæ•°æ®
    var beams = [];

    // v2.0: æŠ€èƒ½ç³»ç»Ÿ
    var SKILLS = {
        meteor: {
            id: 'meteor',
            name: 'é™¨çŸ³é›¨',
            icon: 'â˜„ï¸',
            cooldown: 1800, // 30ç§’ (60å¸§/ç§’)
            damage: 200,
            radius: 80,
            description: 'å¯¹æŒ‡å®šåŒºåŸŸé€ æˆå¤§é‡ä¼¤å®³'
        },
        freeze: {
            id: 'freeze',
            name: 'å†°å°',
            icon: 'ğŸ¥¶',
            cooldown: 2400, // 40ç§’
            duration: 180, // 3ç§’
            description: 'å†»ç»“æ‰€æœ‰æ•Œäºº3ç§’'
        },
        slowtime: {
            id: 'slowtime',
            name: 'æ—¶é—´å‡é€Ÿ',
            icon: 'â±ï¸',
            cooldown: 1200, // 20ç§’
            duration: 300, // 5ç§’
            slowEffect: 0.5,
            description: 'æ•Œäººå‡é€Ÿ50%æŒç»­5ç§’'
        }
    };
    var skillCooldowns = { meteor: 0, freeze: 0, slowtime: 0 };
    var skillEffects = { freeze: 0, slowtime: 0 }; // å½“å‰ç”Ÿæ•ˆä¸­çš„æ•ˆæœå‰©ä½™æ—¶é—´
    var pendingSkill = null; // ç­‰å¾…é€‰æ‹©ç›®æ ‡çš„æŠ€èƒ½ï¼ˆå¦‚é™¨çŸ³é›¨ï¼‰
    var meteorEffects = []; // é™¨çŸ³åŠ¨ç”»æ•ˆæœ

    // v2.0: æˆå°±ç³»ç»Ÿ
    var ACHIEVEMENTS = [
        { id: 'first_blood', name: 'åˆæ¬¡å‡»æ€', icon: 'ğŸ¯', desc: 'å‡»æ€ç¬¬ä¸€ä¸ªæ•Œäºº', condition: function() { return kills >= 1; } },
        { id: 'killer_10', name: 'å°è¯•ç‰›åˆ€', icon: 'âš”ï¸', desc: 'ç´¯è®¡å‡»æ€10ä¸ªæ•Œäºº', condition: function() { return kills >= 10; } },
        { id: 'killer_50', name: 'æ€æˆ®æœºå™¨', icon: 'ğŸ’€', desc: 'ç´¯è®¡å‡»æ€50ä¸ªæ•Œäºº', condition: function() { return kills >= 50; } },
        { id: 'killer_100', name: 'ç™¾äººæ–©', icon: 'ğŸ‘¹', desc: 'ç´¯è®¡å‡»æ€100ä¸ªæ•Œäºº', condition: function() { return kills >= 100; } },
        { id: 'wave_5', name: 'åˆéœ²é”‹èŠ’', icon: 'ğŸŒŠ', desc: 'é€šè¿‡ç¬¬5æ³¢', condition: function() { return wave >= 5; } },
        { id: 'wave_10', name: 'åšå®ˆé˜µåœ°', icon: 'ğŸ°', desc: 'é€šè¿‡ç¬¬10æ³¢', condition: function() { return wave >= 10; } },
        { id: 'wave_20', name: 'æ— å°½å®ˆæŠ¤', icon: 'â™¾ï¸', desc: 'æ— å°½æ¨¡å¼é€šè¿‡20æ³¢', condition: function() { return isEndlessMode && wave >= 20; } },
        { id: 'rich', name: 'å¯Œç”²ä¸€æ–¹', icon: 'ğŸ’°', desc: 'åŒæ—¶æ‹¥æœ‰500é‡‘å¸', condition: function() { return gold >= 500; } },
        { id: 'tower_master', name: 'å¡”é˜²å¤§å¸ˆ', icon: 'ğŸ—ï¸', desc: 'æ”¾ç½®10åº§é˜²å¾¡å¡”', condition: function() { return towers.length >= 10; } },
        { id: 'skill_user', name: 'æŠ€èƒ½è¾¾äºº', icon: 'âœ¨', desc: 'ä½¿ç”¨ä»»æ„æŠ€èƒ½', condition: function() { return skillsUsed > 0; } },
        { id: 'no_damage', name: 'å®Œç¾é˜²å®ˆ', icon: 'ğŸ›¡ï¸', desc: 'é€šè¿‡ä¸€æ³¢ä¸æŸå¤±ç”Ÿå‘½', condition: function() { return perfectWave; } },
        { id: 'speed_demon', name: 'æ—¶é—´ç®¡ç†', icon: 'âš¡', desc: 'ä½¿ç”¨4å€é€Ÿé€šå…³', condition: function() { return gameSpeed === 4 && wave >= maxWave; } }
    ];
    var unlockedAchievements = []; // æœ¬å±€å·²è§£é”çš„æˆå°±
    var allTimeAchievements = []; // æ°¸ä¹…è§£é”çš„æˆå°±ï¼ˆä»localStorageè¯»å–ï¼‰
    var skillsUsed = 0; // ä½¿ç”¨æŠ€èƒ½æ¬¡æ•°
    var perfectWave = false; // æœ¬æ³¢æ˜¯å¦å®Œç¾
    var livesAtWaveStart = 10; // æ³¢æ¬¡å¼€å§‹æ—¶çš„ç”Ÿå‘½å€¼
    var achievementQueue = []; // å¾…æ˜¾ç¤ºçš„æˆå°±é˜Ÿåˆ—
    var showingAchievement = false; // æ˜¯å¦æ­£åœ¨æ˜¾ç¤ºæˆå°±

    // v2.0: å¤©èµ‹æ ‘ç³»ç»Ÿ
    var TALENTS = [
        { id: 'dmg1', name: 'æ”»å‡»å¼ºåŒ–I', icon: 'âš”ï¸', desc: 'æ‰€æœ‰å¡”ä¼¤å®³+5%', cost: 100, bonus: { damage: 0.05 }, requires: [] },
        { id: 'dmg2', name: 'æ”»å‡»å¼ºåŒ–II', icon: 'âš”ï¸', desc: 'æ‰€æœ‰å¡”ä¼¤å®³+10%', cost: 300, bonus: { damage: 0.10 }, requires: ['dmg1'] },
        { id: 'range1', name: 'å°„ç¨‹æ‰©å±•I', icon: 'ğŸ¯', desc: 'æ‰€æœ‰å¡”å°„ç¨‹+5%', cost: 100, bonus: { range: 0.05 }, requires: [] },
        { id: 'range2', name: 'å°„ç¨‹æ‰©å±•II', icon: 'ğŸ¯', desc: 'æ‰€æœ‰å¡”å°„ç¨‹+10%', cost: 300, bonus: { range: 0.10 }, requires: ['range1'] },
        { id: 'speed1', name: 'æ”»é€Ÿæå‡I', icon: 'âš¡', desc: 'æ‰€æœ‰å¡”æ”»é€Ÿ+5%', cost: 150, bonus: { fireRate: 0.05 }, requires: [] },
        { id: 'speed2', name: 'æ”»é€Ÿæå‡II', icon: 'âš¡', desc: 'æ‰€æœ‰å¡”æ”»é€Ÿ+10%', cost: 400, bonus: { fireRate: 0.10 }, requires: ['speed1'] },
        { id: 'gold1', name: 'è´¢å¯Œå¢ç›Š', icon: 'ğŸ’°', desc: 'å‡»æ€å¥–åŠ±+10%', cost: 200, bonus: { goldBonus: 0.10 }, requires: [] },
        { id: 'skill1', name: 'æŠ€èƒ½ç²¾é€š', icon: 'âœ¨', desc: 'æŠ€èƒ½å†·å´-10%', cost: 250, bonus: { skillCooldown: 0.10 }, requires: [] },
        { id: 'hp1', name: 'åšéŸ§é˜²å¾¡', icon: 'â¤ï¸', desc: 'åˆå§‹ç”Ÿå‘½+2', cost: 200, bonus: { bonusLives: 2 }, requires: [] },
        { id: 'start1', name: 'å¯åŠ¨èµ„é‡‘', icon: 'ğŸ¦', desc: 'åˆå§‹é‡‘å¸+50', cost: 150, bonus: { bonusGold: 50 }, requires: [] }
    ];
    var unlockedTalents = []; // å·²è§£é”çš„å¤©èµ‹IDåˆ—è¡¨
    var talentPoints = 0; // å¤©èµ‹ç‚¹æ•°ï¼ˆç´¯è®¡å‡»æ€æ•°ï¼‰
    var totalKillsAllTime = 0; // å†å²æ€»å‡»æ€æ•°
    var talentBonuses = { damage: 0, range: 0, fireRate: 0, goldBonus: 0, skillCooldown: 0, bonusLives: 0, bonusGold: 0 };

    // v2.0: æ¯æ—¥æŒ‘æˆ˜ç³»ç»Ÿ
    var CHALLENGE_TYPES = [
        { id: 'kill_basic', name: 'åŸºç¡€å‡»æ€', desc: 'å‡»æ€{n}ä¸ªæ•Œäºº', base: 30, icon: 'ğŸ’€' },
        { id: 'kill_fast', name: 'é—ªç”µçŒæ‰‹', desc: 'å‡»æ€{n}ä¸ªç–¾é£æ•Œäºº', base: 5, icon: 'âš¡' },
        { id: 'kill_boss', name: 'å‹‡è€…è¯•ç‚¼', desc: 'å‡»æ€{n}ä¸ªBOSS', base: 2, icon: 'ğŸ‘¹' },
        { id: 'wave_clear', name: 'æ³¢æ¬¡æ¸…ç†', desc: 'å®Œæˆ{n}ä¸ªæ³¢æ¬¡', base: 5, icon: 'ğŸŒŠ' },
        { id: 'skill_use', name: 'æŠ€èƒ½å¤§å¸ˆ', desc: 'ä½¿ç”¨{n}æ¬¡æŠ€èƒ½', base: 5, icon: 'âœ¨' },
        { id: 'no_damage', name: 'å®Œç¾é˜²å¾¡', desc: '1æ³¢æ¬¡å†…ä¸æŸå¤±ç”Ÿå‘½', base: 1, icon: 'ğŸ›¡ï¸' },
        { id: 'tower_limit', name: 'æç®€ä¸»ä¹‰', desc: 'ä½¿ç”¨ä¸è¶…è¿‡{n}åº§å¡”é€šå…³', base: 5, icon: 'ğŸ°' },
        { id: 'gold_earn', name: 'è´¢å¯Œç§¯ç´¯', desc: 'ç´¯è®¡è·å¾—{n}é‡‘å¸', base: 300, icon: 'ğŸ’°' }
    ];
    var dailyChallenge = null; // ä»Šæ—¥æŒ‘æˆ˜æ•°æ®
    var dailyChallengeProgress = {}; // æŒ‘æˆ˜è¿›åº¦
    var dailyChallengeCompleted = false; // æ˜¯å¦å·²å®Œæˆ
    var lastChallengeDate = ''; // ä¸Šæ¬¡æŒ‘æˆ˜æ—¥æœŸ

    // v1.1: æ‹–æ‹½æ”¾ç½®çŠ¶æ€
    var isDragging = false;
    var dragTowerType = null;

    // v1.1: é€‰ä¸­çš„å¡”ï¼ˆç”¨äºå›æ”¶ï¼‰
    var selectedTower = null;
    var hoveredTower = null;  // v2.1: é¼ æ ‡æ‚¬æµ®çš„å¡”

    // v1.1: å‡çº§ç³»ç»Ÿé…ç½®
    var UPGRADE_THRESHOLDS = [0, 5, 15, 30]; // 0çº§, 1çº§, 2çº§, 3çº§æ‰€éœ€å‡»æ€æ•°
    var UPGRADE_BONUSES = [
        { damage: 1.0, range: 1.0, fireRate: 1.0 },   // 0çº§
        { damage: 1.2, range: 1.05, fireRate: 0.95 }, // 1çº§
        { damage: 1.5, range: 1.10, fireRate: 0.90 }, // 2çº§
        { damage: 2.0, range: 1.20, fireRate: 0.80 }  // 3çº§
    ];

    // Game objects
    var towers = [];
    var enemies = [];
    var bullets = [];
    var particles = [];

    // Selected tower type
    var selectedTowerType = 'basic';

    // Tower definitions (å¯æ‰©å±•æ¥å£ - å›¢é˜Ÿå…ƒç´ å¯ç»‘å®š)
    var TOWER_TYPES = {
        basic: {
            id: 'basic',
            name: 'åŸºç¡€å¡”',
            alias: 'Borisç‚®å°',  // å›¢é˜Ÿæˆå‘˜: Boris
            icon: 'ğŸ”«',
            cost: 50,
            range: 100,
            damage: 10,
            fireRate: 60, // frames between shots
            color: '#60a5fa',
            // å›¢é˜Ÿå…ƒç´ 
            teamLabel: 'Boris',
            teamAvatar: null,
            teamLogo: null
        },
        slow: {
            id: 'slow',
            name: 'å†°å†»å¡”',
            alias: 'Rubyå†°éœœ',  // å›¢é˜Ÿæˆå‘˜: Ruby
            icon: 'â„ï¸',
            cost: 75,
            range: 80,
            damage: 5,
            fireRate: 90,
            slowEffect: 0.5, // å‡é€Ÿ50%
            slowDuration: 120, // frames
            color: '#22d3ee',
            teamLabel: 'Ruby',
            teamAvatar: null,
            teamLogo: null
        },
        splash: {
            id: 'splash',
            name: 'æº…å°„å¡”',
            alias: 'DongQiuçˆ†ç ´',  // å›¢é˜Ÿæˆå‘˜: DongQiu
            icon: 'ğŸ’¥',
            cost: 100,
            range: 90,
            damage: 8,
            fireRate: 80,
            splashRadius: 40,
            color: '#f97316',
            teamLabel: 'DongQiu',
            teamAvatar: null,
            teamLogo: null
        },
        sniper: {
            id: 'sniper',
            name: 'ç‹™å‡»å¡”',
            alias: 'Yunç²¾å‡†',  // å›¢é˜Ÿæˆå‘˜: Yun
            icon: 'ğŸ¯',
            cost: 150,
            range: 180,
            damage: 40,
            fireRate: 150,
            color: '#a855f7',
            teamLabel: 'Yun',
            teamAvatar: null,
            teamLogo: null
        },
        // v1.3: æ–°é˜²å¾¡å¡”ç±»å‹ - äº§å“åˆ«å
        laser: {
            id: 'laser',
            name: 'æ¿€å…‰å¡”',
            alias: 'TRCå…‰æŸ',  // äº§å“: TRC
            icon: 'âš¡',
            cost: 200,
            range: 150,
            damage: 3,  // æ¯å¸§ä¼¤å®³
            fireRate: 1, // æŒç»­æ”»å‡»
            color: '#ec4899',
            isBeam: true, // å…‰æŸå‹æ”»å‡»
            piercing: true, // ç©¿é€æ•Œäºº
            teamLabel: 'TRC',
            teamAvatar: null,
            teamLogo: null
        },
        poison: {
            id: 'poison',
            name: 'æ¯’æ°”å¡”',
            alias: 'CSEæ¯’é›¾',  // äº§å“: CSE
            icon: 'â˜ ï¸',
            cost: 120,
            range: 70,
            damage: 2, // æ¯å¸§æ¯’ä¼¤
            fireRate: 30,
            color: '#84cc16',
            isAura: true, // å…‰ç¯å‹æ”»å‡»
            poisonDuration: 180, // ä¸­æ¯’æŒç»­å¸§æ•°
            poisonDamage: 1, // ä¸­æ¯’æ¯å¸§ä¼¤å®³
            teamLabel: 'CSE',
            teamAvatar: null,
            teamLogo: null
        },
        chain: {
            id: 'chain',
            name: 'ç”µç£å¡”',
            alias: 'CARIé“¾ç”µ',  // äº§å“: CARI (ç¾¤ä¼¤ç‰¹æ•ˆ)
            icon: 'ğŸ”Œ',
            cost: 180,
            range: 100,
            damage: 15,
            fireRate: 90,
            color: '#06b6d4',
            chainCount: 3, // è·³è·ƒæ”»å‡»æ¬¡æ•°
            chainRange: 60, // è·³è·ƒè·ç¦»
            teamLabel: 'CARI',
            teamAvatar: null,
            teamLogo: null
        }
    };

    // Enemy definitions (å¯æ‰©å±•æ¥å£ - æ•Œäººç±»å‹å¯ç»‘å®šæ ‡ç­¾)
    // v2.2: å¹³è¡¡è°ƒæ•´ - åŸºäºæ¨¡æ‹Ÿå™¨æ¨æ¼”ï¼ŒHPçº¦1.5å€åŸå€¼
    var ENEMY_TYPES = {
        basic: {
            id: 'basic',
            name: 'Bug',
            hp: 45,  // åŸ30ï¼Œå¹³è¡¡å45ï¼ˆéœ€è¦2-3åº§å¡”é…åˆï¼‰
            speed: 1.0,
            reward: 10,
            color: '#ef4444',
            size: 12,
            label: 'Bug'
        },
        fast: {
            id: 'fast',
            name: 'å¿«é€ŸBug',
            hp: 30,  // åŸ20ï¼Œå¹³è¡¡å30
            speed: 2.0,
            reward: 12,
            color: '#fbbf24',
            size: 10,
            label: 'å¿«Bug'
        },
        tank: {
            id: 'tank',
            name: 'å¼ºåŒ–Bug',
            hp: 150,  // åŸ100ï¼Œå¹³è¡¡å150
            speed: 0.5,
            reward: 25,
            color: '#7c3aed',
            size: 18,
            label: 'å¦å…‹'
        },
        boss: {
            id: 'boss',
            name: 'Boss',
            hp: 450,  // åŸ300ï¼Œå¹³è¡¡å450
            speed: 0.35,
            reward: 80,
            color: '#dc2626',
            size: 25,
            label: 'Boss'
        },
        // v1.3: æ–°æ•Œäººç±»å‹
        stealth: {
            id: 'stealth',
            name: 'éšå½¢Bug',
            hp: 38,  // åŸ25ï¼Œå¹³è¡¡å38
            speed: 1.5,
            reward: 15,
            color: '#6366f1',
            size: 11,
            label: 'éšèº«',
            stealthCycle: 120,
            stealthDuration: 60
        },
        split: {
            id: 'split',
            name: 'åˆ†è£‚Bug',
            hp: 60,  // åŸ40ï¼Œå¹³è¡¡å60
            speed: 0.9,
            reward: 20,
            color: '#f472b6',
            size: 14,
            label: 'åˆ†è£‚',
            splitCount: 2,
            splitType: 'basic'
        },
        healer: {
            id: 'healer',
            name: 'æ²»æ„ˆBug',
            hp: 52,  // åŸ35ï¼Œå¹³è¡¡å52
            speed: 0.8,
            reward: 25,
            color: '#34d399',
            size: 13,
            label: 'æ²»æ„ˆ',
            healRadius: 50,
            healAmount: 1,  // é€‚åº¦æ²»æ„ˆ
            healCooldown: 60  // æ ‡å‡†é¢‘ç‡
        }
    };

    // Path waypoints (æ•Œäººè·¯å¾„)
    var PATH = [
        { x: 0, y: 200 },
        { x: 150, y: 200 },
        { x: 150, y: 350 },
        { x: 400, y: 350 },
        { x: 400, y: 100 },
        { x: 600, y: 100 },
        { x: 600, y: 400 },
        { x: 700, y: 400 }
    ];

    // Wave configurations
    function getWaveConfig(waveNum) {
        var config = { enemies: [] };
        // v1.3: æ— å°½æ¨¡å¼ä¸‹æ•Œäººæ•°é‡æŒç»­å¢é•¿
        var count = isEndlessMode ? 3 + waveNum * 2 + Math.floor(waveNum / 5) * 3 : 3 + waveNum * 2;

        for (var i = 0; i < count; i++) {
            var type = 'basic';
            var rand = Math.random();

            // åŸºç¡€æ•Œäººå‡ºç°è§„åˆ™
            if (waveNum >= 3 && rand < 0.25) type = 'fast';
            if (waveNum >= 5 && rand < 0.15) type = 'tank';

            // v1.3: æ–°æ•Œäººç±»å‹å‡ºç°è§„åˆ™
            if (waveNum >= 4 && rand < 0.12) type = 'stealth';
            if (waveNum >= 6 && rand < 0.10) type = 'split';
            if (waveNum >= 7 && rand < 0.08) type = 'healer';

            // Bosså‡ºç°è§„åˆ™
            if (!isEndlessMode && waveNum === 10 && i === count - 1) type = 'boss';
            // v1.3: æ— å°½æ¨¡å¼æ¯5æ³¢å‡ºç°Boss
            if (isEndlessMode && waveNum % 5 === 0 && i === count - 1) type = 'boss';

            config.enemies.push({
                type: type,
                delay: i * (isEndlessMode && waveNum > 10 ? 30 : 40) // æ— å°½æ¨¡å¼åæœŸåŠ å¿«å‡ºæ€ª
            });
        }
        return config;
    }

    // Initialize game - optimized with async chunks to prevent UI freeze
    var isInitializing = false;
    function init() {
        if (isInitializing) return; // Prevent multiple init calls
        isInitializing = true;

        try {
            canvas = document.getElementById('towerCanvas');
            if (!canvas) {
                console.error('Tower defense canvas not found');
                isInitializing = false;
                return;
            }
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2D context');
                isInitializing = false;
                return;
            }

            // Phase 1: Core canvas events (immediate)
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseLeave);

            // Phase 2: Setup and restart (deferred to allow UI update)
            setTimeout(function() {
                try {
                    setupDragEvents();
                    initAudio();
                    updateWavePreview();
                    preloadMapBackgrounds(); // é¢„åŠ è½½åœ°å›¾èƒŒæ™¯
                } catch (e) { console.warn('Phase 2 init failed:', e); }

                // Phase 3: Heavy systems (further deferred)
                setTimeout(function() {
                    try {
                        setupKeyboardShortcuts();
                        initAchievements();
                    } catch (e) { console.warn('Phase 3 init failed:', e); }

                    // Phase 4: Final systems and start game
                    setTimeout(function() {
                        try {
                            initTalents();
                            initDailyChallenge();
                            restart();
                            requestAnimationFrame(gameLoop);
                        } catch (e) { console.warn('Phase 4 init failed:', e); }
                        isInitializing = false;
                    }, 10);
                }, 10);
            }, 10);
        } catch (e) {
            console.error('Tower defense init failed:', e);
            isInitializing = false;
        }
    }

    // é¢„åŠ è½½åœ°å›¾èƒŒæ™¯å›¾ç‰‡
    function preloadMapBackgrounds() {
        for (var i = 0; i < MAPS.length; i++) {
            var map = MAPS[i];
            if (map.bgImage) {
                var img = new Image();
                img.src = map.bgImage;
                mapBgImages[map.name] = img;
            }
        }
    }

    // ç»˜åˆ¶åœ°å›¾èƒŒæ™¯
    function drawMapBackground() {
        var currentMap = MAPS[currentMapIndex];
        if (!currentMap) return;

        ctx.save();
        ctx.globalAlpha = bgImageOpacity;

        // ä¼˜å…ˆä½¿ç”¨èƒŒæ™¯å›¾ç‰‡
        if (currentMap.bgImage) {
            var img = mapBgImages[currentMap.name];
            if (img && img.complete) {
                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œä¿æŒå›¾ç‰‡è¦†ç›–æ•´ä¸ªç”»å¸ƒ
                var scale = Math.max(W / img.width, H / img.height);
                var scaledW = img.width * scale;
                var scaledH = img.height * scale;
                var offsetX = (W - scaledW) / 2;
                var offsetY = (H - scaledH) / 2;
                ctx.drawImage(img, offsetX, offsetY, scaledW, scaledH);
                ctx.restore();
                return;
            }
        }

        // ä½¿ç”¨æ¸å˜è‰²ä½œä¸ºå¤‡ç”¨èƒŒæ™¯
        if (currentMap.bgGradient) {
            var gradient = ctx.createLinearGradient(0, 0, W, H);
            gradient.addColorStop(0, currentMap.bgGradient[0]);
            gradient.addColorStop(1, currentMap.bgGradient[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
        }

        ctx.restore();
    }

    // v1.3: å¿«æ·é”®ç³»ç»Ÿ
    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', function(e) {
            // åªåœ¨å¡”é˜²æ¸¸æˆå¯è§æ—¶å“åº”
            var towerGame = document.getElementById('towerGame');
            if (!towerGame || towerGame.classList.contains('hidden')) return;

            switch(e.key) {
                case '1':
                    selectTower('basic');
                    playSound('click');
                    break;
                case '2':
                    selectTower('slow');
                    playSound('click');
                    break;
                case '3':
                    selectTower('splash');
                    playSound('click');
                    break;
                case '4':
                    selectTower('sniper');
                    playSound('click');
                    break;
                case '5':
                    selectTower('laser');
                    playSound('click');
                    break;
                case '6':
                    selectTower('poison');
                    playSound('click');
                    break;
                case '7':
                    selectTower('chain');
                    playSound('click');
                    break;
                case ' ':
                    e.preventDefault();
                    if (!waveInProgress && !gameOver) {
                        startWave();
                    }
                    break;
                case 'Escape':
                case 'p':
                case 'P':
                    togglePause();
                    break;
                case 'f':
                case 'F':
                    toggleFullscreen();
                    break;
                case 's':
                case 'S':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        saveGame();
                    }
                    break;
                // v2.0: æŠ€èƒ½å¿«æ·é”®
                case 'q':
                case 'Q':
                    useSkill('meteor');
                    break;
                case 'w':
                case 'W':
                    if (!e.ctrlKey) { // é¿å…å’ŒCtrl+Wå†²çª
                        useSkill('freeze');
                    }
                    break;
                case 'e':
                case 'E':
                    useSkill('slowtime');
                    break;
            }
        });
    }

    // v1.1: è®¾ç½®æ‹–æ‹½äº‹ä»¶
    function setupDragEvents() {
        var towerOptions = document.querySelectorAll('.tower-option');
        towerOptions.forEach(function(btn) {
            btn.addEventListener('mousedown', function(e) {
                e.preventDefault();
                var type = btn.dataset.type;
                if (type && TOWER_TYPES[type]) {
                    isDragging = true;
                    dragTowerType = type;
                    selectTower(type);
                }
            });
        });

        // å…¨å±€mouseupé˜²æ­¢æ‹–æ‹½çŠ¶æ€å¡ä½
        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                dragTowerType = null;
            }
        });
    }

    // v1.1: é¼ æ ‡æ¾å¼€æ”¾ç½®å¡”
    function handleMouseUp(e) {
        if (!isDragging || !dragTowerType) return;

        var rect = canvas.getBoundingClientRect();
        // v2.2: ä¿®å¤åæ ‡ç¼©æ”¾é—®é¢˜
        var scaleX = canvas.width / rect.width;
        var scaleY = canvas.height / rect.height;
        var x = (e.clientX - rect.left) * scaleX;
        var y = (e.clientY - rect.top) * scaleY;

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”¾ç½®
        var towerDef = TOWER_TYPES[dragTowerType];
        var canPlace = true;

        if (isOnPath(x, y, 30)) canPlace = false;
        if (gold < towerDef.cost) canPlace = false;

        for (var i = 0; i < towers.length; i++) {
            var dx = towers[i].x - x;
            var dy = towers[i].y - y;
            if (Math.sqrt(dx*dx + dy*dy) < 40) {
                canPlace = false;
                break;
            }
        }

        if (canPlace) {
            placeTower(x, y, dragTowerType);
        }

        isDragging = false;
        dragTowerType = null;
    }

    // v1.1: é¼ æ ‡ç¦»å¼€ç”»å¸ƒ
    function handleMouseLeave() {
        mouseX = -100;
        mouseY = -100;
    }

    // Restart game
    function restart() {
        // v2.0: åº”ç”¨å¤©èµ‹åŠ æˆ
        gold = 100 + (talentBonuses.bonusGold || 0);
        lives = 10 + (talentBonuses.bonusLives || 0);
        wave = 0;
        kills = 0;
        gameOver = false;
        waveInProgress = false;
        towers = [];
        enemies = [];
        bullets = [];
        particles = [];

        // v1.1: é‡ç½®æ‹–æ‹½å’Œé€‰ä¸­çŠ¶æ€
        isDragging = false;
        dragTowerType = null;
        selectedTower = null;

        // v1.2: é‡ç½®é€Ÿåº¦å’Œä¼¤å®³æ•°å­—
        gameSpeed = 1;
        currentSpeedIndex = 0;
        damageNumbers = [];
        var speedBtn = document.getElementById('speedBtn');
        if (speedBtn) {
            speedBtn.textContent = '1x';
            speedBtn.classList.remove('fast', 'fastest');
        }

        // v2.0: é‡ç½®æŠ€èƒ½çŠ¶æ€
        resetSkills();

        // v2.0: é‡ç½®æˆå°±çŠ¶æ€
        resetAchievementState();

        updateUI();
        updateWavePreview();
        document.getElementById('towerStatus').textContent = '';
        document.getElementById('towerStatus').className = 'tower-status';
        document.getElementById('startWaveBtn').disabled = false;
    }

    // Update UI
    function updateUI() {
        document.getElementById('towerGold').textContent = gold;
        document.getElementById('towerLives').textContent = lives;
        document.getElementById('towerWave').textContent = wave;
        document.getElementById('towerMaxWave').textContent = maxWave;
        document.getElementById('towerKills').textContent = kills;
    }

    // Select tower type
    function selectTower(type) {
        selectedTowerType = type;
        document.querySelectorAll('.tower-option').forEach(function(btn) {
            btn.classList.toggle('selected', btn.dataset.type === type);
        });
    }

    // Handle canvas click - place tower or select/sell
    function handleCanvasClick(e) {
        if (gameOver) return;

        var rect = canvas.getBoundingClientRect();
        // v2.2: ä¿®å¤åæ ‡ç¼©æ”¾é—®é¢˜
        var scaleX = canvas.width / rect.width;
        var scaleY = canvas.height / rect.height;
        var x = (e.clientX - rect.left) * scaleX;
        var y = (e.clientY - rect.top) * scaleY;

        // v2.0: æŠ€èƒ½ç›®æ ‡é€‰æ‹©
        if (pendingSkill === 'meteor') {
            castMeteor(x, y);
            return;
        }

        // v1.1: æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å›æ”¶æŒ‰é’®
        if (selectedTower) {
            var btnX = selectedTower.x;
            var btnY = selectedTower.y - 44;
            if (x >= btnX - 30 && x <= btnX + 30 && y >= btnY - 11 && y <= btnY + 11) {
                sellTower(selectedTower);
                return;
            }
        }

        // v1.1: æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å·²æœ‰çš„å¡”ï¼ˆé€‰ä¸­/å–æ¶ˆé€‰ä¸­ï¼‰
        for (var i = 0; i < towers.length; i++) {
            var dx = towers[i].x - x;
            var dy = towers[i].y - y;
            if (Math.sqrt(dx*dx + dy*dy) < 25) {
                if (selectedTower && selectedTower.id === towers[i].id) {
                    selectedTower = null; // å–æ¶ˆé€‰ä¸­
                } else {
                    selectedTower = towers[i]; // é€‰ä¸­
                }
                return;
            }
        }

        // ç‚¹å‡»ç©ºç™½å¤„å–æ¶ˆé€‰ä¸­
        selectedTower = null;

        // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œåœ¨mouseupæ—¶æ”¾ç½®ï¼›è¿™é‡Œåªå¤„ç†ç‚¹å‡»æ”¾ç½®
        if (isDragging) return;

        // Check if on path
        if (isOnPath(x, y, 30)) {
            showStatus('æ— æ³•åœ¨è·¯å¾„ä¸Šæ”¾ç½®é˜²å¾¡å¡”ï¼', false);
            return;
        }

        // Check if tower already exists
        for (var i = 0; i < towers.length; i++) {
            var dx = towers[i].x - x;
            var dy = towers[i].y - y;
            if (Math.sqrt(dx*dx + dy*dy) < 40) {
                showStatus('è¯¥ä½ç½®å·²æœ‰é˜²å¾¡å¡”ï¼', false);
                return;
            }
        }

        // Check gold
        var towerType = TOWER_TYPES[selectedTowerType];
        if (gold < towerType.cost) {
            showStatus('é‡‘å¸ä¸è¶³ï¼', false);
            return;
        }

        // Place tower
        placeTower(x, y, selectedTowerType);
    }

    // v1.1: å›æ”¶å¡”
    function sellTower(tower) {
        var sellPrice = Math.floor(tower.cost * 0.7);
        var index = towers.indexOf(tower);
        if (index > -1) {
            towers.splice(index, 1);
            gold += sellPrice;
            updateUI();
            selectedTower = null;
            showStatus('å›æ”¶æˆåŠŸï¼è·å¾— ' + sellPrice + ' é‡‘å¸', true);

            // å›æ”¶ç‰¹æ•ˆ
            for (var i = 0; i < 10; i++) {
                particles.push({
                    x: tower.x,
                    y: tower.y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 20,
                    color: '#fbbf24'
                });
            }
        }
    }

    // Check if position is on path
    function isOnPath(x, y, threshold) {
        for (var i = 0; i < PATH.length - 1; i++) {
            var p1 = PATH[i], p2 = PATH[i + 1];
            var dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
            if (dist < threshold) return true;
        }
        return false;
    }

    function pointToLineDistance(px, py, x1, y1, x2, y2) {
        var dx = x2 - x1, dy = y2 - y1;
        var len = Math.sqrt(dx*dx + dy*dy);
        if (len === 0) return Math.sqrt((px-x1)*(px-x1) + (py-y1)*(py-y1));

        var t = Math.max(0, Math.min(1, ((px-x1)*dx + (py-y1)*dy) / (len*len)));
        var projX = x1 + t * dx, projY = y1 + t * dy;
        return Math.sqrt((px-projX)*(px-projX) + (py-projY)*(py-projY));
    }

    // Place tower
    function placeTower(x, y, type) {
        var towerDef = TOWER_TYPES[type];
        // v2.0: åº”ç”¨å¤©èµ‹åŠ æˆ
        var bonusDmg = 1 + (talentBonuses.damage || 0);
        var bonusRange = 1 + (talentBonuses.range || 0);
        var bonusFireRate = 1 - (talentBonuses.fireRate || 0); // æ”»é€ŸåŠ æˆæ˜¯å‡å°‘å†·å´
        var tower = {
            id: 'tower_' + Date.now() + '_' + Math.random().toString(36).substr(2,9),
            x: x,
            y: y,
            type: type,
            // v1.1: åŸºç¡€å±æ€§ï¼ˆä¼šæ ¹æ®ç­‰çº§è°ƒæ•´ï¼‰
            baseRange: towerDef.range,
            baseDamage: towerDef.damage,
            baseFireRate: towerDef.fireRate,
            range: Math.floor(towerDef.range * bonusRange),
            damage: Math.floor(towerDef.damage * bonusDmg),
            fireRate: Math.max(10, Math.floor(towerDef.fireRate * bonusFireRate)),
            color: towerDef.color,
            cooldown: 0,
            angle: 0,
            // v1.1: å‡çº§ç³»ç»Ÿ
            level: 0,
            killCount: 0,
            cost: towerDef.cost, // è®°å½•æˆæœ¬ç”¨äºå›æ”¶
            // Team elements (å¯æ‰©å±•)
            teamLabel: towerDef.teamLabel,
            teamAvatar: towerDef.teamAvatar
        };

        if (towerDef.slowEffect) {
            tower.slowEffect = towerDef.slowEffect;
            tower.slowDuration = towerDef.slowDuration;
        }
        if (towerDef.splashRadius) {
            tower.splashRadius = towerDef.splashRadius;
        }

        towers.push(tower);
        gold -= towerDef.cost;
        updateUI();

        // v1.2: æ”¾ç½®éŸ³æ•ˆ
        playSound('place');

        // Place animation
        for (var i = 0; i < 8; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 20,
                color: towerDef.color
            });
        }
    }

    // Start wave
    function startWave() {
        if (gameOver) return;
        // v2.1: æ— å°½æ¨¡å¼å…è®¸è¿ç»­å¼€å§‹æ³¢æ¬¡ï¼ˆä¸æ£€æŸ¥waveInProgressï¼‰
        if (!isEndlessMode && waveInProgress) return;

        wave++;
        waveInProgress = true;
        // v2.1: æ— å°½æ¨¡å¼ä¿æŒæŒ‰é’®å¯ç”¨
        if (!isEndlessMode) {
            document.getElementById('startWaveBtn').disabled = true;
        }

        // v2.0: è®°å½•æ³¢æ¬¡å¼€å§‹æ—¶çš„ç”Ÿå‘½å€¼ï¼ˆç”¨äºå®Œç¾é˜²å®ˆæˆå°±ï¼‰
        livesAtWaveStart = lives;

        // v1.2: æ³¢æ¬¡å¼€å§‹éŸ³æ•ˆ
        playSound('wave');

        var config = getWaveConfig(wave);
        var spawnIndex = 0;
        var frameCount = 0;

        function spawnEnemy() {
            if (spawnIndex >= config.enemies.length) return;

            frameCount++;
            var enemyConf = config.enemies[spawnIndex];
            if (frameCount >= enemyConf.delay) {
                var enemyType = ENEMY_TYPES[enemyConf.type];
                enemies.push({
                    id: 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2,9),
                    x: PATH[0].x,
                    y: PATH[0].y,
                    hp: enemyType.hp,
                    maxHp: enemyType.hp,
                    speed: enemyType.speed,
                    reward: enemyType.reward,
                    color: enemyType.color,
                    size: enemyType.size,
                    label: enemyType.label,
                    pathIndex: 0,
                    slowTimer: 0,
                    slowFactor: 1,
                    hitFlash: 0
                });
                spawnIndex++;
            }

            if (spawnIndex < config.enemies.length) {
                requestAnimationFrame(spawnEnemy);
            }
        }
        requestAnimationFrame(spawnEnemy);
    }

    // Update towers
    function updateTowers() {
        // æ¸…ç©ºä¸Šä¸€å¸§çš„å…‰æŸ
        beams = [];

        for (var i = 0; i < towers.length; i++) {
            var tower = towers[i];
            var towerDef = TOWER_TYPES[tower.type];

            // v1.3: æ¿€å…‰å¡” - æŒç»­æ”»å‡»
            if (towerDef.isBeam) {
                var targets = findTargetsInRange(tower);
                if (targets.length > 0) {
                    // ç„å‡†ç¬¬ä¸€ä¸ªç›®æ ‡
                    tower.angle = Math.atan2(targets[0].y - tower.y, targets[0].x - tower.x);

                    // ç©¿é€æ‰€æœ‰ç›®æ ‡
                    for (var t = 0; t < targets.length; t++) {
                        if (!targets[t].isStealthed) {
                            damageEnemy(targets[t], tower.damage, tower.id);
                        }
                    }

                    // æ·»åŠ å…‰æŸæ•ˆæœ
                    beams.push({
                        x1: tower.x, y1: tower.y,
                        x2: tower.x + Math.cos(tower.angle) * tower.range,
                        y2: tower.y + Math.sin(tower.angle) * tower.range,
                        color: tower.color
                    });
                }
                continue;
            }

            // v1.3: æ¯’æ°”å¡” - å…‰ç¯æ”»å‡»
            if (towerDef.isAura) {
                var enemiesInRange = findTargetsInRange(tower);
                for (var e = 0; e < enemiesInRange.length; e++) {
                    var enemy = enemiesInRange[e];
                    if (!enemy.isStealthed) {
                        // åº”ç”¨æ¯’ç´ æ•ˆæœ
                        enemy.poisonTimer = towerDef.poisonDuration;
                        enemy.poisonDamage = towerDef.poisonDamage;
                        enemy.poisonTowerId = tower.id;
                    }
                }
                continue;
            }

            // æ™®é€šå¡”çš„å†·å´
            if (tower.cooldown > 0) {
                tower.cooldown--;
                continue;
            }

            // Find target
            var target = findTarget(tower);
            if (target) {
                // Aim at target
                tower.angle = Math.atan2(target.y - tower.y, target.x - tower.x);

                // v1.3: ç”µç£å¡” - é“¾å¼æ”»å‡»
                if (towerDef.chainCount) {
                    fireChainLightning(tower, target);
                } else {
                    // æ™®é€šæ”»å‡»
                    fireBullet(tower, target);
                }
                tower.cooldown = tower.fireRate;
            }
        }
    }

    // v1.3: æŸ¥æ‰¾èŒƒå›´å†…æ‰€æœ‰ç›®æ ‡
    function findTargetsInRange(tower) {
        var targets = [];
        for (var i = 0; i < enemies.length; i++) {
            var enemy = enemies[i];
            var dx = enemy.x - tower.x;
            var dy = enemy.y - tower.y;
            var dist = Math.sqrt(dx*dx + dy*dy);
            if (dist <= tower.range) {
                targets.push(enemy);
            }
        }
        return targets;
    }

    // v1.3: é“¾å¼é—ªç”µæ”»å‡»
    function fireChainLightning(tower, firstTarget) {
        var towerDef = TOWER_TYPES[tower.type];
        var chainCount = towerDef.chainCount;
        var chainRange = towerDef.chainRange;
        var hitEnemies = [firstTarget];
        var currentTarget = firstTarget;

        // å¯¹ç¬¬ä¸€ä¸ªç›®æ ‡é€ æˆä¼¤å®³
        if (!firstTarget.isStealthed) {
            damageEnemy(firstTarget, tower.damage, tower.id);
        }

        // é“¾å¼è·³è·ƒ
        for (var c = 1; c < chainCount; c++) {
            var nextTarget = null;
            var minDist = Infinity;

            for (var i = 0; i < enemies.length; i++) {
                var enemy = enemies[i];
                if (hitEnemies.indexOf(enemy) !== -1) continue;
                if (enemy.isStealthed) continue;

                var dx = enemy.x - currentTarget.x;
                var dy = enemy.y - currentTarget.y;
                var dist = Math.sqrt(dx*dx + dy*dy);

                if (dist <= chainRange && dist < minDist) {
                    nextTarget = enemy;
                    minDist = dist;
                }
            }

            if (nextTarget) {
                // æ·»åŠ é—ªç”µæ•ˆæœ
                beams.push({
                    x1: currentTarget.x, y1: currentTarget.y,
                    x2: nextTarget.x, y2: nextTarget.y,
                    color: tower.color,
                    isChain: true
                });

                damageEnemy(nextTarget, tower.damage * 0.7, tower.id);
                hitEnemies.push(nextTarget);
                currentTarget = nextTarget;
            } else {
                break;
            }
        }

        playSound('shoot');
    }

    function findTarget(tower) {
        var closest = null;
        var closestDist = Infinity;

        for (var i = 0; i < enemies.length; i++) {
            var enemy = enemies[i];
            // v1.3: éšèº«æ•Œäººæ— æ³•è¢«é”å®š
            if (enemy.isStealthed) continue;

            var dx = enemy.x - tower.x;
            var dy = enemy.y - tower.y;
            var dist = Math.sqrt(dx*dx + dy*dy);

            if (dist <= tower.range && dist < closestDist) {
                closest = enemy;
                closestDist = dist;
            }
        }
        return closest;
    }

    function fireBullet(tower, target) {
        var angle = Math.atan2(target.y - tower.y, target.x - tower.x);
        var speed = 8;

        bullets.push({
            x: tower.x,
            y: tower.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            damage: tower.damage,
            color: tower.color,
            slowEffect: tower.slowEffect || 0,
            slowDuration: tower.slowDuration || 0,
            splashRadius: tower.splashRadius || 0,
            target: target,
            // v1.1: è®°å½•å‘å°„çš„å¡”ï¼Œç”¨äºå‡çº§ç³»ç»Ÿ
            towerId: tower.id
        });
    }

    // Update bullets
    function updateBullets() {
        for (var i = bullets.length - 1; i >= 0; i--) {
            var b = bullets[i];
            b.x += b.vx;
            b.y += b.vy;

            // Check collision with enemies
            var hit = false;
            for (var j = 0; j < enemies.length; j++) {
                var enemy = enemies[j];
                var dx = b.x - enemy.x;
                var dy = b.y - enemy.y;
                var dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < enemy.size + 5) {
                    hit = true;
                    damageEnemy(enemy, b.damage, b.towerId);

                    if (b.slowEffect > 0) {
                        enemy.slowFactor = b.slowEffect;
                        enemy.slowTimer = b.slowDuration;
                    }

                    if (b.splashRadius > 0) {
                        // Splash damage
                        for (var k = 0; k < enemies.length; k++) {
                            if (k !== j) {
                                var sdx = b.x - enemies[k].x;
                                var sdy = b.y - enemies[k].y;
                                var sdist = Math.sqrt(sdx*sdx + sdy*sdy);
                                if (sdist < b.splashRadius) {
                                    damageEnemy(enemies[k], b.damage * 0.5, b.towerId);
                                }
                            }
                        }
                        // Splash effect
                        for (var p = 0; p < 12; p++) {
                            particles.push({
                                x: b.x,
                                y: b.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 15,
                                color: '#f97316'
                            });
                        }
                    }
                    break;
                }
            }

            // Remove bullet if hit or out of bounds
            if (hit || b.x < 0 || b.x > W || b.y < 0 || b.y > H) {
                bullets.splice(i, 1);
            }
        }
    }

    function damageEnemy(enemy, damage, towerId) {
        enemy.hp -= damage;
        enemy.hitFlash = 5;

        // v1.2: åˆ›å»ºä¼¤å®³æ•°å­—
        var isCrit = damage >= 20; // é«˜ä¼¤å®³æ˜¾ç¤ºä¸ºæš´å‡»æ•ˆæœ
        createDamageNumber(enemy.x + (Math.random() - 0.5) * 20, enemy.y - enemy.size - 5, damage, isCrit);

        // v1.2: æ’­æ”¾å—å‡»éŸ³æ•ˆ
        playSound('hit');

        if (enemy.hp <= 0) {
            // v1.3: ä½¿ç”¨æ–°çš„å‡»æ€å‡½æ•°ï¼ˆåŒ…å«åˆ†è£‚é€»è¾‘ï¼‰
            var index = enemies.indexOf(enemy);
            if (index > -1) {
                killEnemy(enemy, index, towerId);
            }
        }
    }

    // v1.1: æ£€æŸ¥å¡”æ˜¯å¦å‡çº§
    function checkTowerUpgrade(tower) {
        var newLevel = 0;
        for (var i = UPGRADE_THRESHOLDS.length - 1; i >= 0; i--) {
            if (tower.killCount >= UPGRADE_THRESHOLDS[i]) {
                newLevel = i;
                break;
            }
        }

        if (newLevel > tower.level) {
            tower.level = newLevel;
            var bonus = UPGRADE_BONUSES[newLevel];

            // v2.0: æ›´æ–°å¡”çš„å±æ€§ï¼ˆåŒæ—¶åº”ç”¨å¤©èµ‹åŠ æˆï¼‰
            var talentDmg = 1 + (talentBonuses.damage || 0);
            var talentRange = 1 + (talentBonuses.range || 0);
            var talentFireRate = 1 - (talentBonuses.fireRate || 0);
            tower.damage = Math.floor(tower.baseDamage * bonus.damage * talentDmg);
            tower.range = Math.floor(tower.baseRange * bonus.range * talentRange);
            tower.fireRate = Math.max(10, Math.floor(tower.baseFireRate * bonus.fireRate * talentFireRate));

            // å‡çº§ç‰¹æ•ˆ
            for (var i = 0; i < 15; i++) {
                particles.push({
                    x: tower.x,
                    y: tower.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 25,
                    color: '#fbbf24' // é‡‘è‰²å‡çº§ç‰¹æ•ˆ
                });
            }

            // v1.2: å‡çº§éŸ³æ•ˆ
            playSound('upgrade');

            showStatus('ğŸŒŸ ' + TOWER_TYPES[tower.type].name + ' å‡çº§åˆ° ' + newLevel + ' çº§ï¼', true);
        }
    }

    // Update enemies
    function updateEnemies() {
        var currentPath = MAPS[currentMapIndex].path;

        for (var i = enemies.length - 1; i >= 0; i--) {
            var enemy = enemies[i];
            var enemyDef = ENEMY_TYPES[enemy.type];

            // Slow effect
            if (enemy.slowTimer > 0) {
                enemy.slowTimer--;
            } else {
                enemy.slowFactor = 1;
            }

            // Hit flash
            if (enemy.hitFlash > 0) enemy.hitFlash--;

            // v1.3: æ¯’ç´ ä¼¤å®³
            if (enemy.poisonTimer > 0) {
                enemy.poisonTimer--;
                if (enemy.poisonTimer % 30 === 0) { // æ¯30å¸§é€ æˆä¸€æ¬¡ä¼¤å®³
                    enemy.hp -= enemy.poisonDamage;
                    createDamageNumber(enemy.x, enemy.y - enemy.size - 5, enemy.poisonDamage, false);
                    if (enemy.hp <= 0) {
                        killEnemy(enemy, i, enemy.poisonTowerId);
                        continue;
                    }
                }
            }

            // v1.3: éšèº«æ•Œäºº - å‘¨æœŸæ€§éšèº«
            if (enemyDef && enemyDef.stealthCycle) {
                enemy.stealthTimer = (enemy.stealthTimer || 0) + 1;
                var cyclePos = enemy.stealthTimer % enemyDef.stealthCycle;
                enemy.isStealthed = cyclePos < enemyDef.stealthDuration;
            }

            // v1.3: æ²»æ„ˆæ•Œäºº - ä¸ºå‘¨å›´æ•Œäººå›è¡€
            if (enemyDef && enemyDef.healRadius) {
                enemy.healCooldownTimer = (enemy.healCooldownTimer || 0) + 1;
                if (enemy.healCooldownTimer >= enemyDef.healCooldown) {
                    enemy.healCooldownTimer = 0;
                    for (var h = 0; h < enemies.length; h++) {
                        if (h === i) continue;
                        var healTarget = enemies[h];
                        var hdx = healTarget.x - enemy.x;
                        var hdy = healTarget.y - enemy.y;
                        var hdist = Math.sqrt(hdx*hdx + hdy*hdy);
                        if (hdist <= enemyDef.healRadius && healTarget.hp < healTarget.maxHp) {
                            healTarget.hp = Math.min(healTarget.maxHp, healTarget.hp + enemyDef.healAmount * 10);
                            // æ²»æ„ˆç‰¹æ•ˆ
                            particles.push({
                                x: healTarget.x, y: healTarget.y,
                                vx: 0, vy: -1,
                                life: 15,
                                color: '#34d399'
                            });
                        }
                    }
                }
            }

            // Move along path
            var target = currentPath[enemy.pathIndex + 1];
            if (!target) {
                // Reached end
                enemies.splice(i, 1);
                lives--;
                updateUI();
                if (lives <= 0) {
                    endGame(false);
                }
                continue;
            }

            var dx = target.x - enemy.x;
            var dy = target.y - enemy.y;
            var dist = Math.sqrt(dx*dx + dy*dy);
            var speed = enemy.speed * enemy.slowFactor;

            // v2.0: æŠ€èƒ½æ•ˆæœå½±å“ç§»åŠ¨
            if (enemy.frozen && enemy.frozenTimer > 0) {
                enemy.frozenTimer--;
                speed = 0; // å®Œå…¨å†»ç»“
                if (enemy.frozenTimer <= 0) enemy.frozen = false;
            }
            if (enemy.timeSlowed && enemy.timeSlowTimer > 0) {
                enemy.timeSlowTimer--;
                speed *= enemy.timeSlowEffect;
                if (enemy.timeSlowTimer <= 0) enemy.timeSlowed = false;
            }

            if (dist < speed) {
                enemy.pathIndex++;
            } else {
                enemy.x += (dx / dist) * speed;
                enemy.y += (dy / dist) * speed;
            }
        }

        // Check wave complete
        if (waveInProgress && enemies.length === 0) {
            waveInProgress = false;
            document.getElementById('startWaveBtn').disabled = false;

            // v2.0: æ£€æµ‹å®Œç¾é˜²å®ˆæˆå°±
            if (lives === livesAtWaveStart) {
                perfectWave = true;
                // v2.0: å®Œç¾é˜²å¾¡æŒ‘æˆ˜
                updateChallengeProgress('no_damage', 1);
            }
            checkAchievements();
            perfectWave = false; // é‡ç½®

            // v2.0: æ³¢æ¬¡æ¸…ç†æŒ‘æˆ˜
            updateChallengeProgress('wave_clear', 1);

            // v1.2: æ›´æ–°æ³¢æ¬¡é¢„å‘Š
            updateWavePreview();

            // v1.3: æ— å°½æ¨¡å¼ä¸‹ä¸ç»“æŸæ¸¸æˆ
            if (!isEndlessMode && wave >= maxWave) {
                endGame(true);
            }
        }
    }

    // v1.3: å‡»æ€æ•Œäººï¼ˆåŒ…å«åˆ†è£‚é€»è¾‘ï¼‰
    function killEnemy(enemy, index, towerId) {
        var enemyDef = ENEMY_TYPES[enemy.type];
        var currentPath = MAPS[currentMapIndex].path;

        enemies.splice(index, 1);
        // v2.0: åº”ç”¨å¤©èµ‹é‡‘å¸åŠ æˆ
        var bonusGold = Math.floor(enemy.reward * (talentBonuses.goldBonus || 0));
        gold += enemy.reward + bonusGold;
        kills++;

        // v2.0: å‡»æ€è·å¾—å¤©èµ‹ç‚¹
        addTalentPoint(1);

        updateUI();
        playSound('kill');

        // v2.0: æ£€æµ‹æˆå°±
        checkAchievements();

        // v2.0: æ¯æ—¥æŒ‘æˆ˜è¿›åº¦
        updateChallengeProgress('kill_basic', 1);
        updateChallengeProgress('gold_earn', enemy.reward + bonusGold);
        if (enemy.type === 'fast') {
            updateChallengeProgress('kill_fast', 1);
        }
        if (enemy.type === 'boss' || enemy.type === 'miniboss') {
            updateChallengeProgress('kill_boss', 1);
        }

        // æ›´æ–°å¡”çš„å‡»æ€æ•°
        if (towerId) {
            for (var t = 0; t < towers.length; t++) {
                if (towers[t].id === towerId) {
                    towers[t].killCount++;
                    checkTowerUpgrade(towers[t]);
                    break;
                }
            }
        }

        // v1.3: åˆ†è£‚æ•Œäºº - æ­»äº¡æ—¶åˆ†è£‚
        if (enemyDef && enemyDef.splitCount) {
            var splitType = ENEMY_TYPES[enemyDef.splitType];
            for (var s = 0; s < enemyDef.splitCount; s++) {
                var offsetAngle = (s / enemyDef.splitCount) * Math.PI * 2;
                enemies.push({
                    id: 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2,9),
                    x: enemy.x + Math.cos(offsetAngle) * 15,
                    y: enemy.y + Math.sin(offsetAngle) * 15,
                    type: enemyDef.splitType,
                    hp: splitType.hp * 0.5,
                    maxHp: splitType.hp * 0.5,
                    speed: splitType.speed,
                    reward: Math.floor(splitType.reward * 0.5),
                    color: splitType.color,
                    size: splitType.size * 0.8,
                    label: splitType.label,
                    pathIndex: enemy.pathIndex,
                    slowTimer: 0,
                    slowFactor: 1,
                    hitFlash: 0
                });
            }
        }

        // æ­»äº¡ç²’å­æ•ˆæœ
        for (var p = 0; p < 10; p++) {
            particles.push({
                x: enemy.x,
                y: enemy.y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: 20,
                color: enemy.color
            });
        }
    }

    // Update particles
    function updateParticles() {
        for (var i = particles.length - 1; i >= 0; i--) {
            var p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;

            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }

    // End game
    function endGame(victory) {
        gameOver = true;
        var status = document.getElementById('towerStatus');
        if (victory) {
            status.textContent = 'ğŸ‰ èƒœåˆ©ï¼æˆåŠŸå®ˆæŠ¤äº†åŸºåœ°ï¼';
            status.className = 'tower-status victory';
            // v1.2: èƒœåˆ©éŸ³æ•ˆ
            playSound('victory');
        } else {
            status.textContent = 'ğŸ’€ å¤±è´¥ï¼åŸºåœ°è¢«æ”»é™·äº†ï¼';
            status.className = 'tower-status defeat';
            // v1.2: å¤±è´¥éŸ³æ•ˆ
            playSound('gameover');
        }

        // v2.0: æ˜¾ç¤ºæ¸¸æˆç»“æŸModal
        setTimeout(function() {
            showGameOverModal(victory);
        }, 500);
    }

    function showStatus(msg, success) {
        var status = document.getElementById('towerStatus');
        status.textContent = msg;
        status.className = 'tower-status ' + (success ? 'victory' : 'defeat');
        setTimeout(function() {
            if (status.textContent === msg) {
                status.textContent = '';
                status.className = 'tower-status';
            }
        }, 2000);
    }

    // Draw functions
    function draw() {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, W, H);

        // ç»˜åˆ¶åŸå¸‚åœ°å›¾èƒŒæ™¯ï¼ˆåŠé€æ˜ï¼‰
        drawMapBackground();

        drawPath();
        drawTowers();
        drawPoisonAuras(); // v1.3: æ¯’æ°”å¡”èŒƒå›´
        drawBeams(); // v1.3: æ¿€å…‰å’Œé—ªç”µ
        drawEnemies();
        drawBullets();
        drawParticles();

        // v1.1: æ‹–æ‹½é¢„è§ˆ
        drawDragPreview();

        // v1.1: é€‰ä¸­å¡”çš„å›æ”¶æŒ‰é’®
        drawSellButton();

        // v2.1: å¡”å°æ‚¬æµ®ä¿¡æ¯
        drawTowerTooltip();

        if (debugMode) {
            drawDebug();
        }
    }

    // v1.3: ç»˜åˆ¶æ¯’æ°”å¡”çš„èŒƒå›´å…‰ç¯
    function drawPoisonAuras() {
        for (var i = 0; i < towers.length; i++) {
            var tower = towers[i];
            var towerDef = TOWER_TYPES[tower.type];
            if (towerDef.isAura) {
                ctx.fillStyle = 'rgba(132, 204, 22, 0.15)';
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(132, 204, 22, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }

    // v1.1: ç»˜åˆ¶æ‹–æ‹½é¢„è§ˆ
    function drawDragPreview() {
        if (!isDragging || !dragTowerType || mouseX < 0 || mouseY < 0) return;

        var towerDef = TOWER_TYPES[dragTowerType];
        var canPlace = !isOnPath(mouseX, mouseY, 30);

        // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰å¡”é‡å 
        for (var i = 0; i < towers.length; i++) {
            var dx = towers[i].x - mouseX;
            var dy = towers[i].y - mouseY;
            if (Math.sqrt(dx*dx + dy*dy) < 40) {
                canPlace = false;
                break;
            }
        }

        // æ£€æŸ¥é‡‘å¸
        if (gold < towerDef.cost) canPlace = false;

        // æ”»å‡»èŒƒå›´åœ†åœˆ
        ctx.strokeStyle = canPlace ? 'rgba(16, 185, 129, 0.5)' : 'rgba(239, 68, 68, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(mouseX, mouseY, towerDef.range, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);

        // å¡”é¢„è§ˆ
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = canPlace ? towerDef.color : '#ef4444';
        ctx.beginPath();
        ctx.arc(mouseX, mouseY, 18, 0, Math.PI * 2);
        ctx.fill();

        // å›¾æ ‡
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(towerDef.icon, mouseX, mouseY - 25);
        ctx.globalAlpha = 1;
    }

    // v1.1: ç»˜åˆ¶å›æ”¶æŒ‰é’®
    function drawSellButton() {
        if (!selectedTower) return;

        var t = selectedTower;
        var sellPrice = Math.floor(t.cost * 0.7);

        // å›æ”¶æŒ‰é’®èƒŒæ™¯
        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
        ctx.beginPath();
        ctx.roundRect(t.x - 30, t.y - 55, 60, 22, 5);
        ctx.fill();

        // å›æ”¶æ–‡å­—
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('å– ğŸ’°' + sellPrice, t.x, t.y - 44);
    }

    // v2.1: ç»˜åˆ¶å¡”å°æ‚¬æµ®ä¿¡æ¯æç¤ºæ¡†
    function drawTowerTooltip() {
        if (!hoveredTower || isDragging) return;

        var t = hoveredTower;
        var towerDef = TOWER_TYPES[t.type];

        // è·å–å¡”çš„ç‰¹ç‚¹æè¿°
        var traits = [];
        if (towerDef.slowEffect) traits.push('å‡é€Ÿ' + Math.round((1 - towerDef.slowEffect) * 100) + '%');
        if (towerDef.splashRadius) traits.push('æº…å°„èŒƒå›´' + towerDef.splashRadius);
        if (towerDef.isBeam) traits.push('ç©¿é€å…‰æŸ');
        if (towerDef.isAura) traits.push('æŒç»­æ¯’ä¼¤');
        if (towerDef.chainCount) traits.push('é“¾å¼é—ªç”µÃ—' + towerDef.chainCount);
        if (towerDef.range >= 150) traits.push('è¶…è¿œå°„ç¨‹');
        if (traits.length === 0) traits.push('æ ‡å‡†æ”»å‡»');

        var traitText = traits.join(' | ');
        var levelStars = t.level > 0 ? ' ' + 'â˜…'.repeat(t.level) : '';

        // å‡†å¤‡æ–‡æœ¬å†…å®¹
        var lines = [
            towerDef.icon + ' ' + towerDef.name + levelStars,
            'âš”ï¸ æ”»å‡»åŠ›: ' + Math.round(t.damage),
            'ğŸ¯ å°„ç¨‹: ' + Math.round(t.range),
            'ğŸ’¡ ' + traitText
        ];

        // æµ‹é‡æœ€å¤§å®½åº¦
        ctx.font = '12px sans-serif';
        var maxWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var w = ctx.measureText(lines[i]).width;
            if (w > maxWidth) maxWidth = w;
        }

        var boxWidth = maxWidth + 20;
        var boxHeight = lines.length * 18 + 12;

        // è®¡ç®—æç¤ºæ¡†ä½ç½®ï¼ˆé¿å…è¶…å‡ºç”»å¸ƒï¼‰
        var boxX = t.x + 25;
        var boxY = t.y - boxHeight / 2;
        if (boxX + boxWidth > W) boxX = t.x - boxWidth - 25;
        if (boxY < 5) boxY = 5;
        if (boxY + boxHeight > H - 5) boxY = H - boxHeight - 5;

        // ç»˜åˆ¶æç¤ºæ¡†èƒŒæ™¯
        ctx.fillStyle = 'rgba(30, 30, 50, 0.95)';
        ctx.beginPath();
        ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 6);
        ctx.fill();

        // è¾¹æ¡†
        ctx.strokeStyle = t.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 6);
        ctx.stroke();

        // ç»˜åˆ¶æ–‡å­—
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        for (var i = 0; i < lines.length; i++) {
            ctx.fillStyle = i === 0 ? '#fbbf24' : '#fff';
            ctx.font = i === 0 ? 'bold 12px sans-serif' : '11px sans-serif';
            ctx.fillText(lines[i], boxX + 10, boxY + 8 + i * 18);
        }
    }

    function drawPath() {
        // v1.3: ä½¿ç”¨å½“å‰åœ°å›¾çš„è·¯å¾„
        var currentPath = MAPS[currentMapIndex].path;

        // å…ˆç»˜åˆ¶æ·±è‰²åº•å±‚ï¼ˆä¸é€æ˜ï¼‰ï¼Œé®æŒ¡èƒŒæ™¯å›¾ç‰‡
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 44;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (var i = 1; i < currentPath.length; i++) {
            ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        ctx.stroke();

        // è·¯å¾„ä¸»ä½“
        ctx.strokeStyle = 'rgba(102, 126, 234, 0.4)';
        ctx.lineWidth = 40;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (var i = 1; i < currentPath.length; i++) {
            ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        ctx.stroke();

        // Path border
        ctx.strokeStyle = 'rgba(102, 126, 234, 0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (var i = 1; i < currentPath.length; i++) {
            ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        ctx.stroke();

        // Start and end markers
        ctx.fillStyle = '#10b981';
        ctx.beginPath();
        ctx.arc(currentPath[0].x, currentPath[0].y, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('å…¥å£', currentPath[0].x, currentPath[0].y);

        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        var end = currentPath[currentPath.length - 1];
        ctx.arc(end.x, end.y, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.fillText('åŸºåœ°', end.x, end.y);
    }

    // v1.3: ç»˜åˆ¶å…‰æŸæ•ˆæœï¼ˆæ¿€å…‰å¡”å’Œé“¾å¼é—ªç”µï¼‰
    function drawBeams() {
        for (var i = 0; i < beams.length; i++) {
            var beam = beams[i];

            if (beam.isChain) {
                // é“¾å¼é—ªç”µæ•ˆæœ
                ctx.strokeStyle = beam.color;
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(beam.x1, beam.y1);
                ctx.lineTo(beam.x2, beam.y2);
                ctx.stroke();
                ctx.setLineDash([]);
            } else {
                // æ¿€å…‰å…‰æŸæ•ˆæœ
                ctx.strokeStyle = beam.color;
                ctx.lineWidth = 4;
                ctx.shadowColor = beam.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(beam.x1, beam.y1);
                ctx.lineTo(beam.x2, beam.y2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }
    }

    function drawTowers() {
        for (var i = 0; i < towers.length; i++) {
            var t = towers[i];
            var towerDef = TOWER_TYPES[t.type];
            var isSelected = (selectedTower && selectedTower.id === t.id);

            // Range circle (when debug or selected)
            if (debugMode || isSelected) {
                ctx.strokeStyle = isSelected ? 'rgba(251, 191, 36, 0.5)' : 'rgba(255,255,255,0.2)';
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.beginPath();
                ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
                ctx.stroke();
            }

            // v1.1: é€‰ä¸­é«˜äº®
            if (isSelected) {
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(t.x, t.y, 24, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Tower base
            ctx.fillStyle = t.color;
            ctx.shadowColor = t.color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(t.x, t.y, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Tower turret
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(t.x, t.y);
            ctx.lineTo(t.x + Math.cos(t.angle) * 15, t.y + Math.sin(t.angle) * 15);
            ctx.stroke();

            // Icon
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(towerDef.icon, t.x, t.y - 25);

            // v1.1: ç­‰çº§æ˜Ÿæ˜Ÿ
            if (t.level > 0) {
                var stars = '';
                for (var s = 0; s < t.level; s++) stars += 'â˜…';
                ctx.font = '10px sans-serif';
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(stars, t.x, t.y + 28);
            }

            // v1.2: å‡»æ€ç»Ÿè®¡ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰
            if (t.killCount > 0) {
                ctx.font = '9px sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.fillText('âš”' + t.killCount, t.x, t.y + (t.level > 0 ? 40 : 28));
            }

            // v1.1: é¢å¤–è°ƒè¯•ä¿¡æ¯
            if (debugMode) {
                ctx.font = '9px monospace';
                ctx.fillStyle = '#0f0';
                ctx.fillText('DMG:' + t.damage, t.x, t.y + 50);
            }
        }
    }

    function drawEnemies() {
        for (var i = 0; i < enemies.length; i++) {
            var e = enemies[i];

            // Slow effect visual
            if (e.slowTimer > 0) {
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size + 4, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Enemy body
            var color = e.hitFlash > 0 ? '#fff' : e.color;
            ctx.fillStyle = color;
            ctx.shadowColor = e.color;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // HP bar
            var barWidth = e.size * 2;
            var barHeight = 4;
            var barX = e.x - barWidth / 2;
            var barY = e.y - e.size - 8;

            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            var hpPercent = e.hp / e.maxHp;
            ctx.fillStyle = hpPercent > 0.5 ? '#10b981' : (hpPercent > 0.25 ? '#fbbf24' : '#ef4444');
            ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

            // Label
            if (debugMode) {
                ctx.fillStyle = '#fff';
                ctx.font = '8px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(e.label, e.x, e.y + e.size + 10);
            }
        }
    }

    function drawBullets() {
        for (var i = 0; i < bullets.length; i++) {
            var b = bullets[i];
            ctx.fillStyle = b.color;
            ctx.shadowColor = b.color;
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    function drawParticles() {
        for (var i = 0; i < particles.length; i++) {
            var p = particles[i];
            ctx.globalAlpha = p.life / 20;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    function drawDebug() {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(5, 5, 120, 60);
        ctx.fillStyle = '#0f0';
        ctx.font = '10px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('Towers: ' + towers.length, 10, 18);
        ctx.fillText('Enemies: ' + enemies.length, 10, 30);
        ctx.fillText('Bullets: ' + bullets.length, 10, 42);
        ctx.fillText('Particles: ' + particles.length, 10, 54);
    }

    // Mouse preview
    var mouseX = -100, mouseY = -100;
    function handleMouseMove(e) {
        var rect = canvas.getBoundingClientRect();
        // v2.2: ä¿®å¤åæ ‡ç¼©æ”¾é—®é¢˜ - å°†æ˜¾ç¤ºåæ ‡è½¬æ¢ä¸ºcanvaså†…éƒ¨åæ ‡
        var scaleX = canvas.width / rect.width;
        var scaleY = canvas.height / rect.height;
        mouseX = (e.clientX - rect.left) * scaleX;
        mouseY = (e.clientY - rect.top) * scaleY;

        // v2.1: æ£€æµ‹é¼ æ ‡æ˜¯å¦æ‚¬æµ®åœ¨å¡”ä¸Š
        hoveredTower = null;
        for (var i = 0; i < towers.length; i++) {
            var t = towers[i];
            var dx = t.x - mouseX;
            var dy = t.y - mouseY;
            if (Math.sqrt(dx * dx + dy * dy) < 22) {
                hoveredTower = t;
                break;
            }
        }
    }

    // Touch support
    function handleTouch(e) {
        e.preventDefault();
        var touch = e.touches[0];
        var rect = canvas.getBoundingClientRect();
        var x = touch.clientX - rect.left;
        var y = touch.clientY - rect.top;
        handleCanvasClick({ clientX: touch.clientX, clientY: touch.clientY });
    }

    // Toggle debug mode
    function toggleDebug() {
        debugMode = !debugMode;
    }

    // Game loop - optimized for performance
    var lastFrameTime = 0;
    var frameInterval = 1000 / 60; // Target 60 FPS

    function gameLoop(timestamp) {
        if (!canvas || !ctx) return;

        // Skip when game is hidden to save resources
        var towerGame = document.getElementById('towerGame');
        var isHidden = towerGame && towerGame.classList.contains('hidden');

        if (isHidden) {
            // When hidden, use much longer interval to minimize CPU
            setTimeout(function() { requestAnimationFrame(gameLoop); }, 500);
            return;
        }

        // Frame rate limiting for smoother performance
        if (timestamp - lastFrameTime < frameInterval * 0.9) {
            requestAnimationFrame(gameLoop);
            return;
        }
        lastFrameTime = timestamp;

        if (!gameOver && !isPaused) {
            // v1.2: æ ¹æ®æ¸¸æˆé€Ÿåº¦æ‰§è¡Œå¤šæ¬¡æ›´æ–°
            for (var s = 0; s < gameSpeed; s++) {
                updateTowers();
                updateBullets();
                updateEnemies();
                updateParticles();
                updateDamageNumbers();
                // v2.0: æ›´æ–°æŠ€èƒ½ç³»ç»Ÿ
                updateSkillCooldowns();
                updateMeteorEffects();
            }
        }
        draw();
        // v2.0: ç»˜åˆ¶æŠ€èƒ½æ•ˆæœ
        drawSkillEffects();
        drawMeteorEffects();
        drawDamageNumbers();

        // ç»˜åˆ¶æš‚åœæç¤º
        if (isPaused && !gameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, W, H);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â¸ æ¸¸æˆå·²æš‚åœ', W / 2, H / 2 - 20);
            ctx.font = '14px sans-serif';
            ctx.fillText('è¿”å›æœ¬é¡µé¢ç»§ç»­æ¸¸æˆ', W / 2, H / 2 + 15);
        }

        requestAnimationFrame(gameLoop);
    }

    // æš‚åœ/æ¢å¤
    function pause() {
        isPaused = true;
        updatePauseButton();
    }

    function resume() {
        isPaused = false;
        updatePauseButton();
    }

    // åˆ‡æ¢æš‚åœçŠ¶æ€
    function togglePause() {
        if (gameOver) return;
        if (isPaused) {
            resume();
            showStatus('â–¶ï¸ æ¸¸æˆç»§ç»­', true);
        } else {
            pause();
            showStatus('â¸ï¸ æ¸¸æˆæš‚åœ', true);
        }
        playSound('click');
    }

    // æ›´æ–°æš‚åœæŒ‰é’®æ˜¾ç¤º
    function updatePauseButton() {
        var btn = document.getElementById('pauseBtn');
        if (btn) {
            btn.textContent = isPaused ? 'â–¶ï¸' : 'â¸ï¸';
            btn.title = isPaused ? 'ç»§ç»­æ¸¸æˆ' : 'æš‚åœæ¸¸æˆ';
            if (isPaused) {
                btn.classList.add('paused');
            } else {
                btn.classList.remove('paused');
            }
        }
    }

    // ========== v1.2 æ–°åŠŸèƒ½ ==========

    // v1.2: å…¨å±æ¨¡å¼
    function toggleFullscreen() {
        var container = document.getElementById('towerGame');
        if (!document.fullscreenElement) {
            if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen();
            } else if (container.msRequestFullscreen) {
                container.msRequestFullscreen();
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    }

    // v1.2: é€Ÿåº¦åˆ‡æ¢
    function toggleSpeed() {
        currentSpeedIndex = (currentSpeedIndex + 1) % SPEED_OPTIONS.length;
        gameSpeed = SPEED_OPTIONS[currentSpeedIndex];

        var btn = document.getElementById('speedBtn');
        btn.textContent = gameSpeed + 'x';
        btn.classList.remove('fast', 'fastest');
        if (gameSpeed === 2) btn.classList.add('fast');
        if (gameSpeed === 4) btn.classList.add('fastest');

        playSound('click');
    }

    // v1.2: ä¿å­˜æ¸¸æˆ
    function saveGame() {
        var saveData = {
            gold: gold,
            lives: lives,
            wave: wave,
            kills: kills,
            gameSpeed: gameSpeed,
            towers: towers.map(function(t) {
                return {
                    x: t.x, y: t.y, type: t.type,
                    level: t.level, killCount: t.killCount, cost: t.cost,
                    damage: t.damage, range: t.range, fireRate: t.fireRate
                };
            }),
            timestamp: Date.now()
        };

        try {
            localStorage.setItem('trc_tower_defense_save', JSON.stringify(saveData));
            showStatus('ğŸ’¾ æ¸¸æˆå·²ä¿å­˜ï¼', true);
            playSound('upgrade');
        } catch (e) {
            showStatus('ä¿å­˜å¤±è´¥ï¼', false);
        }
    }

    // v1.2: è¯»å–æ¸¸æˆ
    function loadGame() {
        try {
            var saveStr = localStorage.getItem('trc_tower_defense_save');
            if (!saveStr) {
                showStatus('æ²¡æœ‰æ‰¾åˆ°å­˜æ¡£ï¼', false);
                return;
            }

            var saveData = JSON.parse(saveStr);

            // æ¢å¤çŠ¶æ€
            gold = saveData.gold;
            lives = saveData.lives;
            wave = saveData.wave;
            kills = saveData.kills;
            gameOver = false;
            waveInProgress = false;
            enemies = [];
            bullets = [];
            particles = [];
            damageNumbers = [];

            // æ¢å¤é€Ÿåº¦è®¾ç½®
            if (saveData.gameSpeed) {
                gameSpeed = saveData.gameSpeed;
                currentSpeedIndex = SPEED_OPTIONS.indexOf(gameSpeed);
                if (currentSpeedIndex < 0) currentSpeedIndex = 0;
                var btn = document.getElementById('speedBtn');
                btn.textContent = gameSpeed + 'x';
                btn.classList.remove('fast', 'fastest');
                if (gameSpeed === 2) btn.classList.add('fast');
                if (gameSpeed === 4) btn.classList.add('fastest');
            }

            // æ¢å¤å¡”
            towers = saveData.towers.map(function(t) {
                var towerDef = TOWER_TYPES[t.type];
                return {
                    id: 'tower_' + Date.now() + '_' + Math.random().toString(36).substr(2,9),
                    x: t.x, y: t.y, type: t.type,
                    baseRange: towerDef.range,
                    baseDamage: towerDef.damage,
                    baseFireRate: towerDef.fireRate,
                    range: t.range || towerDef.range,
                    damage: t.damage || towerDef.damage,
                    fireRate: t.fireRate || towerDef.fireRate,
                    color: towerDef.color,
                    cooldown: 0, angle: 0,
                    level: t.level || 0,
                    killCount: t.killCount || 0,
                    cost: t.cost || towerDef.cost,
                    slowEffect: towerDef.slowEffect,
                    slowDuration: towerDef.slowDuration,
                    splashRadius: towerDef.splashRadius
                };
            });

            updateUI();
            updateWavePreview();
            document.getElementById('towerStatus').textContent = '';
            document.getElementById('startWaveBtn').disabled = false;

            var saveDate = new Date(saveData.timestamp);
            showStatus('ğŸ“‚ å­˜æ¡£å·²è¯»å–ï¼(ä¿å­˜äº ' + saveDate.toLocaleString() + ')', true);
            playSound('upgrade');
        } catch (e) {
            showStatus('è¯»å–å­˜æ¡£å¤±è´¥ï¼', false);
        }
    }

    // v1.2: åˆ›å»ºä¼¤å®³æ•°å­—
    function createDamageNumber(x, y, damage, isCrit) {
        damageNumbers.push({
            x: x,
            y: y,
            text: '-' + Math.floor(damage),
            life: 40,
            color: isCrit ? '#fbbf24' : '#fff',
            scale: isCrit ? 1.3 : 1.0,
            vy: -1.5
        });
    }

    // v1.2: æ›´æ–°ä¼¤å®³æ•°å­—
    function updateDamageNumbers() {
        for (var i = damageNumbers.length - 1; i >= 0; i--) {
            var dn = damageNumbers[i];
            dn.y += dn.vy;
            dn.life--;
            if (dn.life <= 0) {
                damageNumbers.splice(i, 1);
            }
        }
    }

    // v1.2: ç»˜åˆ¶ä¼¤å®³æ•°å­—
    function drawDamageNumbers() {
        for (var i = 0; i < damageNumbers.length; i++) {
            var dn = damageNumbers[i];
            ctx.globalAlpha = Math.min(1, dn.life / 20);
            ctx.fillStyle = dn.color;
            ctx.font = 'bold ' + Math.floor(12 * dn.scale) + 'px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(dn.text, dn.x, dn.y);
        }
        ctx.globalAlpha = 1;
    }

    // v1.2: æ›´æ–°æ³¢æ¬¡é¢„å‘Š
    function updateWavePreview() {
        var previewEl = document.getElementById('wavePreviewContent');
        if (!previewEl) return;

        // v1.3: æ— å°½æ¨¡å¼ä¸‹ä¸æ˜¾ç¤º"æœ€åä¸€æ³¢å·²å®Œæˆ"
        if (!isEndlessMode && wave >= maxWave) {
            previewEl.innerHTML = 'ğŸ‰ æœ€åä¸€æ³¢å·²å®Œæˆï¼';
            return;
        }

        var nextWave = wave + 1;
        var config = getWaveConfig(nextWave);

        // ç»Ÿè®¡æ•Œäººç±»å‹
        var counts = { basic: 0, fast: 0, tank: 0, boss: 0 };
        config.enemies.forEach(function(e) {
            counts[e.type]++;
        });

        var previewHtml = '';
        if (counts.basic > 0) previewHtml += '<span class="enemy-icon">ğŸ”´ ' + counts.basic + '</span>';
        if (counts.fast > 0) previewHtml += '<span class="enemy-icon">ğŸŸ¡ ' + counts.fast + '</span>';
        if (counts.tank > 0) previewHtml += '<span class="enemy-icon">ğŸŸ£ ' + counts.tank + '</span>';
        if (counts.boss > 0) previewHtml += '<span class="enemy-icon">ğŸ‘¹ ' + counts.boss + '</span>';

        previewEl.innerHTML = 'ç¬¬' + nextWave + 'æ³¢: ' + previewHtml;
    }

    // v1.2: éŸ³æ•ˆç³»ç»Ÿ
    function initAudio() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            soundEnabled = false;
        }
    }

    function playSound(type) {
        if (!soundEnabled || !audioContext) return;

        try {
            var oscillator = audioContext.createOscillator();
            var gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // ä¸åŒéŸ³æ•ˆç±»å‹
            switch(type) {
                case 'shoot':
                    oscillator.frequency.value = 400;
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialDecayTo = 0.01;
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                case 'hit':
                    oscillator.frequency.value = 200;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.03);
                    break;
                case 'kill':
                    oscillator.frequency.value = 600;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'upgrade':
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(1200, audioContext.currentTime + 0.1);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                case 'place':
                    oscillator.frequency.value = 500;
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.08);
                    break;
                case 'click':
                    oscillator.frequency.value = 700;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.02);
                    break;
                case 'wave':
                    oscillator.frequency.value = 300;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(500, audioContext.currentTime + 0.2);
                    oscillator.stop(audioContext.currentTime + 0.25);
                    break;
                case 'gameover':
                    oscillator.frequency.value = 400;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(100, audioContext.currentTime + 0.5);
                    oscillator.stop(audioContext.currentTime + 0.6);
                    break;
                case 'victory':
                    // èƒœåˆ©éŸ³æ•ˆ - è¿ç»­ä¸Šå‡éŸ³è°ƒ
                    oscillator.frequency.value = 400;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
                    oscillator.start(audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(500, audioContext.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.3);
                    oscillator.stop(audioContext.currentTime + 0.4);
                    break;
            }
        } catch (e) {
            // éŸ³æ•ˆæ’­æ”¾å¤±è´¥ï¼Œé™é»˜å¤„ç†
        }
    }

    // ========== v1.3 æ–°åŠŸèƒ½ ==========

    // v1.3: åœ°å›¾é€‰æ‹©
    function selectMap(index) {
        if (index < 0 || index >= MAPS.length) return;
        if (waveInProgress) {
            showStatus('âš ï¸ æ— æ³•åœ¨æ³¢æ¬¡è¿›è¡Œä¸­åˆ‡æ¢åœ°å›¾ï¼', false);
            return;
        }

        currentMapIndex = index;

        // æ›´æ–°åœ°å›¾æŒ‰é’®çŠ¶æ€
        var mapBtns = document.querySelectorAll('.map-btn');
        mapBtns.forEach(function(btn, i) {
            btn.classList.toggle('active', i === index);
        });

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        restart();
        showStatus('ğŸ—ºï¸ å·²åˆ‡æ¢åˆ°åœ°å›¾: ' + MAPS[index].name, true);
        playSound('click');
    }

    // v1.3: æ— å°½æ¨¡å¼åˆ‡æ¢
    function toggleEndlessMode() {
        var checkbox = document.getElementById('endlessModeCheck');
        isEndlessMode = checkbox ? checkbox.checked : !isEndlessMode;

        if (waveInProgress) {
            showStatus('âš ï¸ æ— æ³•åœ¨æ³¢æ¬¡è¿›è¡Œä¸­åˆ‡æ¢æ¨¡å¼ï¼', false);
            // æ¢å¤checkboxçŠ¶æ€
            if (checkbox) checkbox.checked = !isEndlessMode;
            isEndlessMode = !isEndlessMode;
            return;
        }

        // æ›´æ–°maxWave
        if (isEndlessMode) {
            maxWave = 999; // æ— å°½æ¨¡å¼è®¾ç½®ä¸€ä¸ªå¾ˆå¤§çš„æ³¢æ•°
            document.getElementById('towerMaxWave').textContent = 'âˆ';
            showStatus('â™¾ï¸ æ— å°½æ¨¡å¼å·²å¼€å¯ï¼æŒ‘æˆ˜ä½ çš„æé™ï¼', true);
        } else {
            maxWave = 10; // æ¢å¤é»˜è®¤æ³¢æ•°
            document.getElementById('towerMaxWave').textContent = '10';
            showStatus('ğŸ¯ æ™®é€šæ¨¡å¼å·²å¼€å¯ï¼ç”Ÿå­˜10æ³¢å³å¯èƒœåˆ©', true);
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        restart();
        playSound('click');
    }

    // ========== v2.0 æŠ€èƒ½ç³»ç»Ÿ ==========

    // v2.0: ä½¿ç”¨æŠ€èƒ½
    function useSkill(skillId) {
        if (gameOver || !waveInProgress) {
            showStatus('âš ï¸ åªèƒ½åœ¨æ³¢æ¬¡è¿›è¡Œä¸­ä½¿ç”¨æŠ€èƒ½ï¼', false);
            return;
        }

        if (skillCooldowns[skillId] > 0) {
            showStatus('âš ï¸ æŠ€èƒ½å†·å´ä¸­ï¼', false);
            return;
        }

        var skill = SKILLS[skillId];

        // v2.0: æŠ€èƒ½ä½¿ç”¨è®¡æ•°
        skillsUsed++;
        checkAchievements();

        // v2.0: æŠ€èƒ½ä½¿ç”¨æŒ‘æˆ˜
        updateChallengeProgress('skill_use', 1);

        if (skillId === 'meteor') {
            // é™¨çŸ³é›¨éœ€è¦é€‰æ‹©ç›®æ ‡
            pendingSkill = 'meteor';
            document.getElementById('towerGame').classList.add('skill-targeting');
            showStatus('â˜„ï¸ ç‚¹å‡»åœ°å›¾é€‰æ‹©é™¨çŸ³é›¨è½ç‚¹...', true);
            playSound('click');
        } else if (skillId === 'freeze') {
            // å†°å°ï¼šç«‹å³å†»ç»“æ‰€æœ‰æ•Œäºº
            activateFreeze();
        } else if (skillId === 'slowtime') {
            // æ—¶é—´å‡é€Ÿï¼šå‡ç¼“æ‰€æœ‰æ•Œäºº
            activateSlowtime();
        }
    }

    // v2.0: æ¿€æ´»å†°å°æ•ˆæœ
    function activateFreeze() {
        var skill = SKILLS.freeze;
        // v2.0: åº”ç”¨å¤©èµ‹å†·å´å‡å°‘
        var cdReduction = 1 - (talentBonuses.skillCooldown || 0);
        skillCooldowns.freeze = Math.floor(skill.cooldown * cdReduction);
        skillEffects.freeze = skill.duration;

        // å†»ç»“æ‰€æœ‰æ•Œäºº
        enemies.forEach(function(e) {
            e.frozen = true;
            e.frozenTimer = skill.duration;
        });

        // UIåé¦ˆ
        var btn = document.querySelector('.skill-btn[data-skill="freeze"]');
        if (btn) btn.classList.add('active-skill');
        setTimeout(function() { btn && btn.classList.remove('active-skill'); }, 500);

        showStatus('ğŸ¥¶ å†°å°ï¼æ‰€æœ‰æ•Œäººè¢«å†»ç»“3ç§’ï¼', true);
        playSound('upgrade');
        updateSkillCooldownUI('freeze');
    }

    // v2.0: æ¿€æ´»æ—¶é—´å‡é€Ÿ
    function activateSlowtime() {
        var skill = SKILLS.slowtime;
        // v2.0: åº”ç”¨å¤©èµ‹å†·å´å‡å°‘
        var cdReduction = 1 - (talentBonuses.skillCooldown || 0);
        skillCooldowns.slowtime = Math.floor(skill.cooldown * cdReduction);
        skillEffects.slowtime = skill.duration;

        // å‡é€Ÿæ‰€æœ‰æ•Œäºº
        enemies.forEach(function(e) {
            e.timeSlowed = true;
            e.timeSlowTimer = skill.duration;
            e.timeSlowEffect = skill.slowEffect;
        });

        // UIåé¦ˆ
        var btn = document.querySelector('.skill-btn[data-skill="slowtime"]');
        if (btn) btn.classList.add('active-skill');
        setTimeout(function() { btn && btn.classList.remove('active-skill'); }, 500);

        showStatus('â±ï¸ æ—¶é—´å‡é€Ÿï¼æ•Œäººç§»åŠ¨é€Ÿåº¦é™ä½50%ï¼', true);
        playSound('upgrade');
        updateSkillCooldownUI('slowtime');
    }

    // v2.0: é‡Šæ”¾é™¨çŸ³é›¨
    function castMeteor(x, y) {
        var skill = SKILLS.meteor;
        // v2.0: åº”ç”¨å¤©èµ‹å†·å´å‡å°‘
        var cdReduction = 1 - (talentBonuses.skillCooldown || 0);
        skillCooldowns.meteor = Math.floor(skill.cooldown * cdReduction);
        pendingSkill = null;
        document.getElementById('towerGame').classList.remove('skill-targeting');

        // åˆ›å»ºé™¨çŸ³æ•ˆæœ
        meteorEffects.push({
            x: x,
            y: y,
            radius: skill.radius,
            damage: skill.damage,
            phase: 0, // 0=ä¸‹è½, 1=çˆ†ç‚¸, 2=æ¶ˆæ•£
            life: 60, // åŠ¨ç”»æŒç»­å¸§æ•°
            maxLife: 60
        });

        // UIåé¦ˆ
        var btn = document.querySelector('.skill-btn[data-skill="meteor"]');
        if (btn) btn.classList.add('active-skill');
        setTimeout(function() { btn && btn.classList.remove('active-skill'); }, 500);

        showStatus('â˜„ï¸ é™¨çŸ³é›¨ï¼', true);
        playSound('kill');
        updateSkillCooldownUI('meteor');
    }

    // v2.0: æ›´æ–°æŠ€èƒ½å†·å´UI
    function updateSkillCooldownUI(skillId) {
        var cooldownEl = document.getElementById(skillId + 'Cooldown');
        var btn = document.querySelector('.skill-btn[data-skill="' + skillId + '"]');

        if (skillCooldowns[skillId] > 0) {
            var remainSec = Math.ceil(skillCooldowns[skillId] / 60);
            cooldownEl.textContent = remainSec + 's';
            cooldownEl.classList.add('active');
            btn.classList.add('on-cooldown');
        } else {
            cooldownEl.textContent = '';
            cooldownEl.classList.remove('active');
            btn.classList.remove('on-cooldown');
        }
    }

    // v2.0: æ›´æ–°æ‰€æœ‰æŠ€èƒ½å†·å´
    function updateSkillCooldowns() {
        for (var skillId in skillCooldowns) {
            if (skillCooldowns[skillId] > 0) {
                skillCooldowns[skillId]--;
                updateSkillCooldownUI(skillId);
            }
        }

        // æ›´æ–°æŠ€èƒ½æ•ˆæœæŒç»­æ—¶é—´
        if (skillEffects.freeze > 0) {
            skillEffects.freeze--;
        }
        if (skillEffects.slowtime > 0) {
            skillEffects.slowtime--;
        }
    }

    // v2.0: æ›´æ–°é™¨çŸ³æ•ˆæœ
    function updateMeteorEffects() {
        for (var i = meteorEffects.length - 1; i >= 0; i--) {
            var m = meteorEffects[i];
            m.life--;

            // é™¨çŸ³ä¸‹è½åˆ°ä¸€åŠæ—¶é€ æˆä¼¤å®³
            if (m.life === Math.floor(m.maxLife / 2) && m.phase === 0) {
                m.phase = 1; // çˆ†ç‚¸é˜¶æ®µ
                // å¯¹èŒƒå›´å†…æ•Œäººé€ æˆä¼¤å®³
                enemies.forEach(function(e) {
                    var dx = e.x - m.x;
                    var dy = e.y - m.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= m.radius) {
                        // è·ç¦»ä¸­å¿ƒè¶Šè¿‘ä¼¤å®³è¶Šé«˜
                        var damageMultiplier = 1 - (dist / m.radius) * 0.5;
                        var actualDamage = m.damage * damageMultiplier;
                        e.hp -= actualDamage;
                        createDamageNumber(e.x, e.y - e.size, actualDamage, true);
                    }
                });
                playSound('kill');
            }

            if (m.life <= 0) {
                meteorEffects.splice(i, 1);
            }
        }
    }

    // v2.0: ç»˜åˆ¶é™¨çŸ³æ•ˆæœ
    function drawMeteorEffects() {
        meteorEffects.forEach(function(m) {
            var progress = 1 - m.life / m.maxLife;

            if (m.phase === 0) {
                // ä¸‹è½é˜¶æ®µï¼šç”»ä¸€ä¸ªä¸‹è½çš„ç«çƒ
                var fallY = -100 + progress * 2 * (m.y + 100);
                ctx.save();
                ctx.beginPath();
                ctx.arc(m.x, fallY, 15, 0, Math.PI * 2);
                var gradient = ctx.createRadialGradient(m.x, fallY, 0, m.x, fallY, 15);
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.3, '#fbbf24');
                gradient.addColorStop(0.7, '#f97316');
                gradient.addColorStop(1, '#dc2626');
                ctx.fillStyle = gradient;
                ctx.fill();

                // æ‹–å°¾
                ctx.beginPath();
                ctx.moveTo(m.x - 8, fallY - 10);
                ctx.lineTo(m.x, fallY - 50);
                ctx.lineTo(m.x + 8, fallY - 10);
                ctx.fillStyle = 'rgba(251, 191, 36, 0.5)';
                ctx.fill();
                ctx.restore();
            } else {
                // çˆ†ç‚¸é˜¶æ®µ
                var explodeProgress = (m.maxLife / 2 - m.life) / (m.maxLife / 2);
                var currentRadius = m.radius * (0.5 + explodeProgress * 0.5);
                var alpha = 1 - explodeProgress;

                ctx.save();
                ctx.beginPath();
                ctx.arc(m.x, m.y, currentRadius, 0, Math.PI * 2);
                var gradient = ctx.createRadialGradient(m.x, m.y, 0, m.x, m.y, currentRadius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, ' + alpha + ')');
                gradient.addColorStop(0.3, 'rgba(251, 191, 36, ' + alpha * 0.8 + ')');
                gradient.addColorStop(0.6, 'rgba(249, 115, 22, ' + alpha * 0.5 + ')');
                gradient.addColorStop(1, 'rgba(220, 38, 38, 0)');
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();

                // ç«èŠ±ç²’å­
                for (var j = 0; j < 8; j++) {
                    var angle = (j / 8) * Math.PI * 2 + explodeProgress * 2;
                    var sparkDist = currentRadius * 0.8;
                    var sparkX = m.x + Math.cos(angle) * sparkDist;
                    var sparkY = m.y + Math.sin(angle) * sparkDist;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 3 * alpha, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 200, 100, ' + alpha + ')';
                    ctx.fill();
                }
            }
        });
    }

    // v2.0: ç»˜åˆ¶æŠ€èƒ½æ•ˆæœæŒ‡ç¤ºå™¨
    function drawSkillEffects() {
        // å†°å°æ•ˆæœï¼šç”»é¢è¾¹ç¼˜è“è‰²æ•ˆæœ
        if (skillEffects.freeze > 0) {
            ctx.save();
            var alpha = Math.min(0.3, skillEffects.freeze / 60 * 0.3);
            ctx.fillStyle = 'rgba(100, 200, 255, ' + alpha + ')';
            ctx.fillRect(0, 0, W, H);

            // å†°æ™¶è¾¹æ¡†
            ctx.strokeStyle = 'rgba(150, 220, 255, ' + alpha * 2 + ')';
            ctx.lineWidth = 4;
            ctx.strokeRect(2, 2, W - 4, H - 4);
            ctx.restore();
        }

        // æ—¶é—´å‡é€Ÿæ•ˆæœï¼šç”»é¢è¾¹ç¼˜ç´«è‰²æ•ˆæœ
        if (skillEffects.slowtime > 0) {
            ctx.save();
            var alpha = Math.min(0.2, skillEffects.slowtime / 100 * 0.2);
            var gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W/2);
            gradient.addColorStop(0, 'rgba(139, 92, 246, 0)');
            gradient.addColorStop(0.7, 'rgba(139, 92, 246, 0)');
            gradient.addColorStop(1, 'rgba(139, 92, 246, ' + alpha + ')');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }

        // é™¨çŸ³é›¨ç›®æ ‡æ¨¡å¼ï¼šæ˜¾ç¤ºé¢„è§ˆåœˆ
        if (pendingSkill === 'meteor') {
            // è¿™ä¸ªç”±é¼ æ ‡ç§»åŠ¨æ—¶ç»˜åˆ¶
        }
    }

    // v2.0: é‡ç½®æŠ€èƒ½çŠ¶æ€
    function resetSkills() {
        skillCooldowns = { meteor: 0, freeze: 0, slowtime: 0 };
        skillEffects = { freeze: 0, slowtime: 0 };
        pendingSkill = null;
        meteorEffects = [];
        document.getElementById('towerGame').classList.remove('skill-targeting');

        // é‡ç½®UI
        for (var skillId in SKILLS) {
            updateSkillCooldownUI(skillId);
        }
    }

    // ========== v2.0 æˆå°±ç³»ç»Ÿ ==========

    // v2.0: åˆå§‹åŒ–æˆå°±ç³»ç»Ÿ
    function initAchievements() {
        try {
            var saved = localStorage.getItem('trc_achievements');
            if (saved) {
                allTimeAchievements = JSON.parse(saved);
            }
        } catch (e) {
            allTimeAchievements = [];
        }
    }

    // v2.0: æ£€æµ‹æˆå°±
    function checkAchievements() {
        ACHIEVEMENTS.forEach(function(ach) {
            // å¦‚æœå·²è§£é”åˆ™è·³è¿‡
            if (unlockedAchievements.indexOf(ach.id) !== -1) return;
            if (allTimeAchievements.indexOf(ach.id) !== -1) return;

            // æ£€æµ‹æ¡ä»¶
            if (ach.condition()) {
                unlockAchievement(ach);
            }
        });
    }

    // v2.0: è§£é”æˆå°±
    function unlockAchievement(ach) {
        unlockedAchievements.push(ach.id);

        // ä¿å­˜åˆ°æ°¸ä¹…è®°å½•
        if (allTimeAchievements.indexOf(ach.id) === -1) {
            allTimeAchievements.push(ach.id);
            try {
                localStorage.setItem('trc_achievements', JSON.stringify(allTimeAchievements));
            } catch (e) {}
        }

        // åŠ å…¥æ˜¾ç¤ºé˜Ÿåˆ—
        achievementQueue.push(ach);
        showNextAchievement();
    }

    // v2.0: æ˜¾ç¤ºä¸‹ä¸€ä¸ªæˆå°±
    function showNextAchievement() {
        if (showingAchievement || achievementQueue.length === 0) return;

        showingAchievement = true;
        var ach = achievementQueue.shift();

        // åˆ›å»ºæˆå°±å¼¹çª—
        var popup = document.createElement('div');
        popup.className = 'achievement-popup';
        popup.innerHTML = '<div class="achievement-icon">' + ach.icon + '</div>' +
                          '<div class="achievement-info">' +
                            '<div class="achievement-title">ğŸ† æˆå°±è§£é”ï¼</div>' +
                            '<div class="achievement-name">' + ach.name + '</div>' +
                            '<div class="achievement-desc">' + ach.desc + '</div>' +
                          '</div>';

        document.getElementById('towerGame').appendChild(popup);
        playSound('victory');

        // åŠ¨ç”»æ˜¾ç¤º
        setTimeout(function() { popup.classList.add('show'); }, 10);

        // 3ç§’åéšè—
        setTimeout(function() {
            popup.classList.remove('show');
            setTimeout(function() {
                popup.remove();
                showingAchievement = false;
                showNextAchievement();
            }, 300);
        }, 3000);
    }

    // v2.0: é‡ç½®æˆå°±çŠ¶æ€ï¼ˆæœ¬å±€ï¼‰
    function resetAchievementState() {
        unlockedAchievements = [];
        skillsUsed = 0;
        perfectWave = false;
        livesAtWaveStart = lives;
        achievementQueue = [];
    }

    // ========== v2.0 æ’è¡Œæ¦œç³»ç»Ÿ ==========

    var TOWER_LB_KEY = 'trc_tower_leaderboard';

    // v2.0: è¯»å–æ’è¡Œæ¦œ
    function getTowerLeaderboard() {
        try {
            var data = localStorage.getItem(TOWER_LB_KEY);
            return data ? JSON.parse(data) : { normal: [], endless: [] };
        } catch (e) {
            return { normal: [], endless: [] };
        }
    }

    // v2.0: ä¿å­˜æ’è¡Œæ¦œ
    function saveTowerLeaderboard(lb) {
        try {
            localStorage.setItem(TOWER_LB_KEY, JSON.stringify(lb));
        } catch (e) {}
    }

    // v2.0: æ˜¾ç¤ºæ¸¸æˆç»“æŸModal
    function showGameOverModal(victory) {
        var modal = document.getElementById('towerGameOverModal');
        var title = document.getElementById('towerModalTitle');
        var waveEl = document.getElementById('towerModalWave');
        var killsEl = document.getElementById('towerModalKills');
        var mapEl = document.getElementById('towerModalMap');
        var nameInput = document.getElementById('towerPlayerName');

        title.textContent = victory ? 'ğŸ‰ èƒœåˆ©ï¼' : 'ğŸ’€ å¤±è´¥...';
        waveEl.textContent = wave;
        killsEl.textContent = kills;
        mapEl.textContent = MAPS[currentMapIndex].name + (isEndlessMode ? ' (æ— å°½)' : '');

        // æ¢å¤ä¸Šæ¬¡è¾“å…¥çš„åå­—
        nameInput.value = localStorage.getItem('towerLastPlayerName') || '';

        modal.classList.add('show');
        nameInput.focus();
    }

    // ========== v2.0 å¤©èµ‹æ ‘ç³»ç»Ÿ ==========

    var TALENT_STORAGE_KEY = 'trc_talents';
    var TALENT_POINTS_KEY = 'trc_talent_points';
    var TOTAL_KILLS_KEY = 'trc_total_kills';

    // v2.0: åˆå§‹åŒ–å¤©èµ‹ç³»ç»Ÿ
    function initTalents() {
        try {
            var savedTalents = localStorage.getItem(TALENT_STORAGE_KEY);
            unlockedTalents = savedTalents ? JSON.parse(savedTalents) : [];

            var savedPoints = localStorage.getItem(TALENT_POINTS_KEY);
            talentPoints = savedPoints ? parseInt(savedPoints) : 0;

            var savedKills = localStorage.getItem(TOTAL_KILLS_KEY);
            totalKillsAllTime = savedKills ? parseInt(savedKills) : 0;
        } catch (e) {
            unlockedTalents = [];
            talentPoints = 0;
            totalKillsAllTime = 0;
        }
        calculateTalentBonuses();
    }

    // v2.0: ä¿å­˜å¤©èµ‹æ•°æ®
    function saveTalents() {
        try {
            localStorage.setItem(TALENT_STORAGE_KEY, JSON.stringify(unlockedTalents));
            localStorage.setItem(TALENT_POINTS_KEY, talentPoints.toString());
            localStorage.setItem(TOTAL_KILLS_KEY, totalKillsAllTime.toString());
        } catch (e) {}
    }

    // v2.0: è®¡ç®—å¤©èµ‹åŠ æˆ
    function calculateTalentBonuses() {
        // é‡ç½®åŠ æˆ
        talentBonuses = { damage: 0, range: 0, fireRate: 0, goldBonus: 0, skillCooldown: 0, bonusLives: 0, bonusGold: 0 };

        // ç´¯åŠ å·²è§£é”å¤©èµ‹çš„åŠ æˆ
        unlockedTalents.forEach(function(talentId) {
            var talent = TALENTS.find(function(t) { return t.id === talentId; });
            if (talent && talent.bonus) {
                Object.keys(talent.bonus).forEach(function(key) {
                    talentBonuses[key] = (talentBonuses[key] || 0) + talent.bonus[key];
                });
            }
        });
    }

    // v2.0: è§£é”å¤©èµ‹
    function unlockTalent(talentId) {
        var talent = TALENTS.find(function(t) { return t.id === talentId; });
        if (!talent) return false;

        // æ£€æŸ¥æ˜¯å¦å·²è§£é”
        if (unlockedTalents.indexOf(talentId) !== -1) {
            showStatus('âš ï¸ è¯¥å¤©èµ‹å·²è§£é”ï¼', false);
            return false;
        }

        // æ£€æŸ¥å‰ç½®å¤©èµ‹
        for (var i = 0; i < talent.requires.length; i++) {
            if (unlockedTalents.indexOf(talent.requires[i]) === -1) {
                showStatus('âš ï¸ éœ€è¦å…ˆè§£é”å‰ç½®å¤©èµ‹ï¼', false);
                return false;
            }
        }

        // æ£€æŸ¥å¤©èµ‹ç‚¹æ•°
        if (talentPoints < talent.cost) {
            showStatus('âš ï¸ å¤©èµ‹ç‚¹æ•°ä¸è¶³ï¼éœ€è¦ ' + talent.cost + ' ç‚¹', false);
            return false;
        }

        // è§£é”å¤©èµ‹
        talentPoints -= talent.cost;
        unlockedTalents.push(talentId);
        calculateTalentBonuses();
        saveTalents();

        showStatus('âœ¨ è§£é”å¤©èµ‹: ' + talent.name, true);
        playSound('upgrade');
        updateTalentUI();
        return true;
    }

    // v2.0: æ·»åŠ å¤©èµ‹ç‚¹ï¼ˆå‡»æ€æ•Œäººæ—¶è°ƒç”¨ï¼‰
    function addTalentPoint(amount) {
        amount = amount || 1;
        talentPoints += amount;
        totalKillsAllTime += amount;
        saveTalents();
    }

    // v2.0: é‡ç½®å¤©èµ‹ï¼ˆè¿”è¿˜æ‰€æœ‰ç‚¹æ•°ï¼‰
    function resetTalents() {
        var refund = 0;
        unlockedTalents.forEach(function(talentId) {
            var talent = TALENTS.find(function(t) { return t.id === talentId; });
            if (talent) refund += talent.cost;
        });

        unlockedTalents = [];
        talentPoints += refund;
        calculateTalentBonuses();
        saveTalents();
        updateTalentUI();

        showStatus('ğŸ”„ å¤©èµ‹å·²é‡ç½®ï¼Œè¿”è¿˜ ' + refund + ' ç‚¹', true);
    }

    // v2.0: æ˜¾ç¤ºå¤©èµ‹é¢æ¿
    function showTalentPanel() {
        var panel = document.getElementById('talentPanel');
        if (panel) {
            updateTalentUI();
            panel.classList.add('show');
        }
    }

    // v2.0: å…³é—­å¤©èµ‹é¢æ¿
    function closeTalentPanel() {
        var panel = document.getElementById('talentPanel');
        if (panel) {
            panel.classList.remove('show');
        }
    }

    // v2.0: æ›´æ–°å¤©èµ‹UI
    function updateTalentUI() {
        var container = document.getElementById('talentGrid');
        var pointsEl = document.getElementById('talentPointsDisplay');
        if (!container) return;

        // æ›´æ–°ç‚¹æ•°æ˜¾ç¤º
        if (pointsEl) {
            pointsEl.textContent = talentPoints;
        }

        // æ›´æ–°å¤©èµ‹æ ¼å­
        container.innerHTML = '';
        TALENTS.forEach(function(talent) {
            var isUnlocked = unlockedTalents.indexOf(talent.id) !== -1;
            var canUnlock = true;

            // æ£€æŸ¥å‰ç½®æ¡ä»¶
            for (var i = 0; i < talent.requires.length; i++) {
                if (unlockedTalents.indexOf(talent.requires[i]) === -1) {
                    canUnlock = false;
                    break;
                }
            }

            // æ£€æŸ¥ç‚¹æ•°
            var hasPoints = talentPoints >= talent.cost;

            var div = document.createElement('div');
            div.className = 'talent-node';
            if (isUnlocked) div.className += ' unlocked';
            else if (!canUnlock) div.className += ' locked';
            else if (!hasPoints) div.className += ' no-points';

            div.innerHTML = '<div class="talent-icon">' + talent.icon + '</div>' +
                           '<div class="talent-name">' + talent.name + '</div>' +
                           '<div class="talent-cost">' + (isUnlocked ? 'âœ“' : talent.cost + 'ç‚¹') + '</div>';

            div.title = talent.desc;

            if (!isUnlocked && canUnlock && hasPoints) {
                div.onclick = function() { unlockTalent(talent.id); };
            }

            container.appendChild(div);
        });
    }

    // v2.0: è·å–å¤©èµ‹åŠ æˆï¼ˆä¾›å…¶ä»–ç³»ç»Ÿä½¿ç”¨ï¼‰
    function getTalentBonus(type) {
        return talentBonuses[type] || 0;
    }

    // ========== v2.0 æ¯æ—¥æŒ‘æˆ˜ç³»ç»Ÿ ==========

    var DAILY_CHALLENGE_KEY = 'trc_daily_challenge';

    // v2.0: åŸºäºæ—¥æœŸçš„ä¼ªéšæœºæ•°ç”Ÿæˆå™¨
    function seededRandom(seed) {
        var x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    }

    // v2.0: è·å–ä»Šæ—¥æ—¥æœŸå­—ç¬¦ä¸²
    function getTodayString() {
        var d = new Date();
        return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();
    }

    // v2.0: ç”Ÿæˆæ¯æ—¥æŒ‘æˆ˜
    function generateDailyChallenge() {
        var today = getTodayString();

        // å¦‚æœå·²ç»æ˜¯ä»Šå¤©çš„æŒ‘æˆ˜ï¼Œç›´æ¥è¿”å›
        if (dailyChallenge && lastChallengeDate === today) {
            return dailyChallenge;
        }

        // å°è¯•ä»localStorageè¯»å–
        try {
            var saved = localStorage.getItem(DAILY_CHALLENGE_KEY);
            if (saved) {
                var data = JSON.parse(saved);
                if (data.date === today) {
                    dailyChallenge = data.challenge;
                    dailyChallengeProgress = data.progress || {};
                    dailyChallengeCompleted = data.completed || false;
                    lastChallengeDate = today;
                    return dailyChallenge;
                }
            }
        } catch (e) {}

        // ç”Ÿæˆæ–°æŒ‘æˆ˜
        var seed = 0;
        for (var i = 0; i < today.length; i++) {
            seed += today.charCodeAt(i) * (i + 1);
        }

        // éšæœºé€‰æ‹©3ä¸ªä¸åŒçš„æŒ‘æˆ˜ç±»å‹
        var challenges = [];
        var usedIndices = [];
        for (var c = 0; c < 3; c++) {
            var idx;
            do {
                idx = Math.floor(seededRandom(seed + c * 100) * CHALLENGE_TYPES.length);
            } while (usedIndices.indexOf(idx) !== -1);
            usedIndices.push(idx);

            var type = CHALLENGE_TYPES[idx];
            var difficulty = 1 + seededRandom(seed + c * 200) * 0.5; // 1.0-1.5xéš¾åº¦
            var target = Math.floor(type.base * difficulty);

            challenges.push({
                type: type.id,
                name: type.name,
                icon: type.icon,
                desc: type.desc.replace('{n}', target),
                target: target,
                reward: Math.floor(target * 3) // å¤©èµ‹ç‚¹å¥–åŠ±
            });
        }

        dailyChallenge = {
            date: today,
            challenges: challenges,
            totalReward: challenges.reduce(function(sum, c) { return sum + c.reward; }, 0)
        };
        dailyChallengeProgress = {};
        dailyChallengeCompleted = false;
        lastChallengeDate = today;

        saveDailyChallenge();
        return dailyChallenge;
    }

    // v2.0: ä¿å­˜æ¯æ—¥æŒ‘æˆ˜æ•°æ®
    function saveDailyChallenge() {
        try {
            localStorage.setItem(DAILY_CHALLENGE_KEY, JSON.stringify({
                date: lastChallengeDate,
                challenge: dailyChallenge,
                progress: dailyChallengeProgress,
                completed: dailyChallengeCompleted
            }));
        } catch (e) {}
    }

    // v2.0: æ›´æ–°æŒ‘æˆ˜è¿›åº¦
    function updateChallengeProgress(type, value) {
        if (!dailyChallenge || dailyChallengeCompleted) return;

        dailyChallengeProgress[type] = (dailyChallengeProgress[type] || 0) + value;

        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æŒ‘æˆ˜éƒ½å®Œæˆ
        var allComplete = true;
        dailyChallenge.challenges.forEach(function(c) {
            var progress = dailyChallengeProgress[c.type] || 0;
            if (progress < c.target) {
                allComplete = false;
            }
        });

        if (allComplete && !dailyChallengeCompleted) {
            completeDailyChallenge();
        }

        saveDailyChallenge();
        updateChallengeUI();
    }

    // v2.0: å®Œæˆæ¯æ—¥æŒ‘æˆ˜
    function completeDailyChallenge() {
        dailyChallengeCompleted = true;

        // ç»™äºˆå¤©èµ‹ç‚¹å¥–åŠ±
        talentPoints += dailyChallenge.totalReward;
        saveTalents();
        saveDailyChallenge();

        // æ˜¾ç¤ºå®Œæˆå¼¹çª—
        showStatus('ğŸ‰ æ¯æ—¥æŒ‘æˆ˜å®Œæˆï¼è·å¾— ' + dailyChallenge.totalReward + ' å¤©èµ‹ç‚¹ï¼', true);
        playSound('victory');
    }

    // v2.0: æ˜¾ç¤ºæ¯æ—¥æŒ‘æˆ˜é¢æ¿
    function showChallengePanel() {
        generateDailyChallenge();
        updateChallengeUI();
        var panel = document.getElementById('challengePanel');
        if (panel) {
            panel.classList.add('show');
        }
    }

    // v2.0: å…³é—­æ¯æ—¥æŒ‘æˆ˜é¢æ¿
    function closeChallengePanel() {
        var panel = document.getElementById('challengePanel');
        if (panel) {
            panel.classList.remove('show');
        }
    }

    // v2.0: æ›´æ–°æŒ‘æˆ˜UI
    function updateChallengeUI() {
        var container = document.getElementById('challengeList');
        var statusEl = document.getElementById('challengeStatus');
        if (!container || !dailyChallenge) return;

        // æ›´æ–°çŠ¶æ€
        if (statusEl) {
            statusEl.textContent = dailyChallengeCompleted ? 'å·²å®Œæˆ' : 'è¿›è¡Œä¸­';
            statusEl.className = 'challenge-status ' + (dailyChallengeCompleted ? 'completed' : 'active');
        }

        // æ›´æ–°æŒ‘æˆ˜åˆ—è¡¨
        container.innerHTML = '';
        dailyChallenge.challenges.forEach(function(c) {
            var progress = dailyChallengeProgress[c.type] || 0;
            var isComplete = progress >= c.target;
            var percent = Math.min(100, Math.floor(progress / c.target * 100));

            var div = document.createElement('div');
            div.className = 'challenge-item' + (isComplete ? ' completed' : '');
            div.innerHTML = '<div class="challenge-header">' +
                              '<span class="challenge-icon">' + c.icon + '</span>' +
                              '<span class="challenge-name">' + c.name + '</span>' +
                              '<span class="challenge-reward">+' + c.reward + 'ç‚¹</span>' +
                            '</div>' +
                            '<div class="challenge-desc">' + c.desc + '</div>' +
                            '<div class="challenge-progress-bar">' +
                              '<div class="challenge-progress-fill" style="width: ' + percent + '%"></div>' +
                            '</div>' +
                            '<div class="challenge-progress-text">' +
                              (isComplete ? 'âœ“ å®Œæˆ' : progress + ' / ' + c.target) +
                            '</div>';

            container.appendChild(div);
        });
    }

    // v2.0: åˆå§‹åŒ–æ¯æ—¥æŒ‘æˆ˜
    function initDailyChallenge() {
        generateDailyChallenge();
    }

    // Public API (å¤šäººæ¨¡å¼é¢„ç•™æ¥å£)
    return {
        init: init,
        restart: restart,
        selectTower: selectTower,
        startWave: startWave,
        toggleDebug: toggleDebug,
        pause: pause,
        resume: resume,
        togglePause: togglePause,
        // v1.2: æ–°åŠŸèƒ½API
        toggleFullscreen: toggleFullscreen,
        toggleSpeed: toggleSpeed,
        saveGame: saveGame,
        loadGame: loadGame,
        // v1.3: åœ°å›¾å’Œæ¨¡å¼API
        selectMap: selectMap,
        toggleEndlessMode: toggleEndlessMode,
        // v2.0: æŠ€èƒ½ç³»ç»ŸAPI
        useSkill: useSkill,
        // v2.0: å¤©èµ‹æ ‘API
        showTalentPanel: showTalentPanel,
        closeTalentPanel: closeTalentPanel,
        unlockTalent: unlockTalent,
        resetTalents: resetTalents,
        getTalentBonus: getTalentBonus,
        // v2.0: æ¯æ—¥æŒ‘æˆ˜API
        showChallengePanel: showChallengePanel,
        closeChallengePanel: closeChallengePanel,
        // Network sync interface (å¤šäººæ¨¡å¼é¢„ç•™)
        getState: function() {
            return {
                gold: gold, lives: lives, wave: wave, kills: kills,
                towers: towers, enemies: enemies,
                isEndlessMode: isEndlessMode,
                mapName: MAPS[currentMapIndex].name
            };
        },
        setState: function(state) {
            gold = state.gold; lives = state.lives; wave = state.wave; kills = state.kills;
            towers = state.towers; enemies = state.enemies;
            updateUI();
        },
        // Event system (å¤šäººæ¨¡å¼é¢„ç•™)
        onTowerPlaced: null,
        onEnemyKilled: null,
        onWaveComplete: null
    };
})();
window.TowerDefense = TowerDefense;

// v2.0: å¡”é˜²æ’è¡Œæ¦œå…¨å±€å‡½æ•°
var currentTowerLBMode = 'normal';

function showTowerLeaderboard(mode) {
    currentTowerLBMode = mode;

    // æ›´æ–°tabæ ·å¼
    var tabs = document.querySelectorAll('#towerLeaderboardContainer .lb-tab');
    tabs.forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.mode === mode);
    });

    // è¯»å–æ’è¡Œæ¦œæ•°æ®
    var lbData = JSON.parse(localStorage.getItem('trc_tower_leaderboard') || '{"normal":[],"endless":[]}');
    var entries = lbData[mode] || [];

    // æ¸²æŸ“æ’è¡Œæ¦œ
    var container = document.getElementById('towerLeaderboard');
    if (entries.length === 0) {
        container.innerHTML = '<div class="no-scores">æš‚æ— è®°å½•ï¼Œå¿«æ¥æŒ‘æˆ˜å§ï¼</div>';
        return;
    }

    var html = entries.map(function(entry, i) {
        var medal = i === 0 ? 'ğŸ¥‡' : (i === 1 ? 'ğŸ¥ˆ' : (i === 2 ? 'ğŸ¥‰' : (i + 1)));
        return '<div class="lb-entry">' +
            '<span class="lb-rank">' + medal + '</span>' +
            '<span class="lb-name">' + entry.name + '</span>' +
            '<span class="lb-score">ğŸŒŠ' + entry.wave + ' ğŸ’€' + entry.kills + '</span>' +
        '</div>';
    }).join('');

    container.innerHTML = html;
}
window.showTowerLeaderboard = showTowerLeaderboard;

function submitTowerScore() {
    var nameInput = document.getElementById('towerPlayerName');
    var name = nameInput.value.trim() || 'åŒ¿åç©å®¶';

    // ä¿å­˜åå­—
    localStorage.setItem('towerLastPlayerName', name);

    // è¯»å–æ’è¡Œæ¦œ
    var lbData = JSON.parse(localStorage.getItem('trc_tower_leaderboard') || '{"normal":[],"endless":[]}');
    var mode = TowerDefense.getState().isEndlessMode ? 'endless' : 'normal';

    // æ·»åŠ æ–°è®°å½•
    var state = TowerDefense.getState();
    lbData[mode].push({
        name: name,
        wave: state.wave,
        kills: state.kills,
        map: state.mapName || 'ç»å…¸',
        date: Date.now()
    });

    // æ’åºï¼ˆå…ˆæŒ‰æ³¢æ¬¡ï¼Œå†æŒ‰å‡»æ€æ•°ï¼‰
    lbData[mode].sort(function(a, b) {
        if (b.wave !== a.wave) return b.wave - a.wave;
        return b.kills - a.kills;
    });

    // åªä¿ç•™å‰10å
    lbData[mode] = lbData[mode].slice(0, 10);

    // ä¿å­˜
    localStorage.setItem('trc_tower_leaderboard', JSON.stringify(lbData));

    // å…³é—­Modalå¹¶åˆ·æ–°æ’è¡Œæ¦œ
    closeTowerModal();
    showTowerLeaderboard(mode);
}
window.submitTowerScore = submitTowerScore;

function closeTowerModal() {
    document.getElementById('towerGameOverModal').classList.remove('show');
}
window.closeTowerModal = closeTowerModal;

// é¡µé¢å¯è§æ€§å˜åŒ–ç›‘å¬ - è‡ªåŠ¨æš‚åœ/æ¢å¤æ¸¸æˆ
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        // é¡µé¢éšè—æ—¶æš‚åœ
        if (window.TowerDefense) TowerDefense.pause();
        if (window.spiderGamePause) spiderGamePause();
    } else {
        // é¡µé¢æ˜¾ç¤ºæ—¶æ¢å¤
        if (window.TowerDefense) TowerDefense.resume();
        if (window.spiderGameResume) spiderGameResume();
    }
});
</script>
{% endblock %}
