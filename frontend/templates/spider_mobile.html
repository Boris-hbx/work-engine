<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>你过来啊</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .game-wrapper {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 10px;
        }
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        .game-title {
            color: #e94560;
            font-size: 1rem;
            font-weight: 600;
        }
        .game-stats {
            display: flex;
            gap: 12px;
            font-size: 0.8rem;
            color: #fff;
        }
        .stat b { color: #feca57; }
        .stat-time b { color: #ef4444; font-family: monospace; }
        #gameCanvas {
            flex: 1;
            width: 100%;
            border-radius: 10px;
            touch-action: none;
        }
        .game-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-shrink: 0;
        }
        .ctrl-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
        }
        .btn-restart {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #fff;
        }
        .btn-diff {
            background: rgba(255,255,255,0.15);
            color: #fff;
        }
        .btn-diff.active {
            background: #10b981;
        }
        .game-status {
            text-align: center;
            padding: 10px;
            font-size: 1rem;
            font-weight: 600;
            color: #fff;
            flex-shrink: 0;
        }
        .game-status.win { color: #10b981; }
        .game-status.fail { color: #ef4444; }
        /* Touch control hint */
        .touch-hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.75rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .touch-hint.visible { opacity: 1; }
    </style>
</head>
<body>
<div class="game-wrapper">
    <div class="game-header">
        <span class="game-title">你过来啊</span>
        <div class="game-stats">
            <span class="stat">占领: <b id="capturedPercent">0</b>%</span>
            <span class="stat">目标: <b id="targetPercent">50</b>%</span>
            <span class="stat stat-time">用时: <b id="gameTimer">0.000</b>s</span>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="game-status" id="gameStatus"></div>
    <div class="game-controls">
        <button class="ctrl-btn btn-diff" data-diff="easy" onclick="setDiff('easy')">简单</button>
        <button class="ctrl-btn btn-diff active" data-diff="normal" onclick="setDiff('normal')">普通</button>
        <button class="ctrl-btn btn-diff" data-diff="hard" onclick="setDiff('hard')">困难</button>
        <button class="ctrl-btn btn-restart" onclick="initGame()">重开</button>
    </div>
</div>
<div class="touch-hint" id="touchHint">滑动屏幕控制小球</div>

<script>
(function() {
    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');
    var CELL = 8;
    var W, H, COLS, ROWS, totalInnerCells;

    var difficulties = {
        easy: { speed: 1.2, target: 30 },
        normal: { speed: 2, target: 50 },
        hard: { speed: 3, target: 70 }
    };
    var currentDiff = 'normal';

    var grid = [];
    var player = { x: 0, y: 0 };
    var enemy = { x: 0, y: 0, dx: 2, dy: 2 };
    var trail = [];
    var isDrawing = false;
    var gameOver = false;
    var gameWon = false;
    var capturedPercent = 0;
    var gameStarted = false;
    var gameStartTime = 0;
    var timerInterval = null;

    // Touch control
    var touchStartX = 0, touchStartY = 0;
    var pendingDir = { dx: 0, dy: 0 };
    var moveInterval = null;

    function resize() {
        var rect = canvas.getBoundingClientRect();
        W = Math.floor(rect.width / CELL) * CELL;
        H = Math.floor(rect.height / CELL) * CELL;
        canvas.width = W;
        canvas.height = H;
        COLS = W / CELL;
        ROWS = H / CELL;
        totalInnerCells = (COLS - 2) * (ROWS - 2);
        initGame();
    }

    function setDiff(d) {
        currentDiff = d;
        document.querySelectorAll('.btn-diff').forEach(function(b) {
            b.classList.toggle('active', b.dataset.diff === d);
        });
        document.getElementById('targetPercent').textContent = difficulties[d].target;
        initGame();
    }
    window.setDiff = setDiff;

    function initGame() {
        grid = [];
        for (var r = 0; r < ROWS; r++) {
            grid[r] = [];
            for (var c = 0; c < COLS; c++) {
                grid[r][c] = (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) ? 1 : 0;
            }
        }
        player.x = 0;
        player.y = Math.floor(ROWS / 2);
        var spd = difficulties[currentDiff].speed;
        enemy.x = W / 2;
        enemy.y = H / 2;
        enemy.dx = spd * (Math.random() > 0.5 ? 1 : -1);
        enemy.dy = spd * (Math.random() > 0.5 ? 1 : -1);
        trail = [];
        isDrawing = false;
        gameOver = false;
        gameWon = false;
        capturedPercent = 0;
        gameStarted = false;
        pendingDir = { dx: 0, dy: 0 };
        document.getElementById('capturedPercent').textContent = '0';
        document.getElementById('gameTimer').textContent = '0.000';
        document.getElementById('gameStatus').textContent = '';
        document.getElementById('gameStatus').className = 'game-status';
        if (timerInterval) clearInterval(timerInterval);
        // Show hint
        var hint = document.getElementById('touchHint');
        hint.classList.add('visible');
        setTimeout(function() { hint.classList.remove('visible'); }, 2000);
    }
    window.initGame = initGame;

    function startTimer() {
        gameStartTime = performance.now();
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(function() {
            if (!gameOver && !gameWon) {
                var elapsed = performance.now() - gameStartTime;
                document.getElementById('gameTimer').textContent = (elapsed / 1000).toFixed(3);
            }
        }, 50);
    }

    function isSafe(gx, gy) {
        if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return false;
        return grid[gy][gx] === 1;
    }

    function isOnTrail(gx, gy) {
        for (var i = 0; i < trail.length; i++) {
            if (trail[i].x === gx && trail[i].y === gy) return true;
        }
        return false;
    }

    function fillArea() {
        if (trail.length < 2) return;
        for (var i = 0; i < trail.length; i++) {
            var t = trail[i];
            if (t.x >= 0 && t.x < COLS && t.y >= 0 && t.y < ROWS) grid[t.y][t.x] = 1;
        }
        var temp = [];
        for (var r = 0; r < ROWS; r++) temp[r] = grid[r].slice();
        var egx = Math.max(1, Math.min(COLS - 2, Math.floor(enemy.x / CELL)));
        var egy = Math.max(1, Math.min(ROWS - 2, Math.floor(enemy.y / CELL)));
        var queue = [{x: egx, y: egy}];
        var visited = {};
        while (queue.length > 0) {
            var cell = queue.shift();
            var key = cell.x + ',' + cell.y;
            if (visited[key]) continue;
            if (cell.x < 0 || cell.x >= COLS || cell.y < 0 || cell.y >= ROWS) continue;
            if (temp[cell.y][cell.x] === 1) continue;
            visited[key] = true;
            temp[cell.y][cell.x] = 2;
            queue.push({x: cell.x + 1, y: cell.y});
            queue.push({x: cell.x - 1, y: cell.y});
            queue.push({x: cell.x, y: cell.y + 1});
            queue.push({x: cell.x, y: cell.y - 1});
        }
        for (var r = 0; r < ROWS; r++) {
            for (var c = 0; c < COLS; c++) {
                if (temp[r][c] === 0) grid[r][c] = 1;
            }
        }
        updateStats();
    }

    function updateStats() {
        var cap = 0;
        for (var r = 1; r < ROWS - 1; r++) {
            for (var c = 1; c < COLS - 1; c++) {
                if (grid[r][c] === 1) cap++;
            }
        }
        capturedPercent = Math.round((cap / totalInnerCells) * 100);
        document.getElementById('capturedPercent').textContent = capturedPercent;
    }

    function failGame() {
        gameOver = true;
        if (timerInterval) clearInterval(timerInterval);
        document.getElementById('gameStatus').textContent = '游戏结束！';
        document.getElementById('gameStatus').className = 'game-status fail';
    }

    function winGame() {
        gameWon = true;
        if (timerInterval) clearInterval(timerInterval);
        document.getElementById('gameStatus').textContent = '恭喜通关！';
        document.getElementById('gameStatus').className = 'game-status win';
    }

    function movePlayer() {
        if (gameOver || gameWon) return;
        var dx = pendingDir.dx, dy = pendingDir.dy;
        if (dx === 0 && dy === 0) return;
        if (!gameStarted) { gameStarted = true; startTimer(); }
        var newX = player.x + dx;
        var newY = player.y + dy;
        if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS) return;
        if (isOnTrail(newX, newY)) { failGame(); return; }
        var wasOn = isSafe(player.x, player.y);
        var willOn = isSafe(newX, newY);
        player.x = newX;
        player.y = newY;
        if (wasOn && !willOn) {
            isDrawing = true;
            trail = [{x: player.x, y: player.y}];
        } else if (isDrawing && !willOn) {
            trail.push({x: player.x, y: player.y});
        } else if (isDrawing && willOn) {
            trail.push({x: player.x, y: player.y});
            fillArea();
            trail = [];
            isDrawing = false;
            if (capturedPercent >= difficulties[currentDiff].target) { winGame(); }
        }
    }

    function updateEnemy() {
        if (gameOver || gameWon) return;
        enemy.x += enemy.dx;
        enemy.y += enemy.dy;
        var egx = Math.floor(enemy.x / CELL);
        var egy = Math.floor(enemy.y / CELL);
        // Bounce
        if (enemy.x <= CELL || enemy.x >= W - CELL) {
            enemy.dx = -enemy.dx;
            enemy.x = Math.max(CELL, Math.min(W - CELL, enemy.x));
        }
        if (enemy.y <= CELL || enemy.y >= H - CELL) {
            enemy.dy = -enemy.dy;
            enemy.y = Math.max(CELL, Math.min(H - CELL, enemy.y));
        }
        // Check inner wall
        if (egx > 0 && egx < COLS - 1 && egy > 0 && egy < ROWS - 1) {
            if (grid[egy][egx] === 1) {
                enemy.dx = -enemy.dx;
                enemy.dy = -enemy.dy;
            }
        }
        // Hit trail?
        if (isDrawing && isOnTrail(egx, egy)) { failGame(); }
    }

    function draw() {
        ctx.fillStyle = '#0a0a1a';
        ctx.fillRect(0, 0, W, H);
        // Grid
        for (var r = 0; r < ROWS; r++) {
            for (var c = 0; c < COLS; c++) {
                if (grid[r][c] === 1) {
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillRect(c * CELL, r * CELL, CELL - 1, CELL - 1);
                }
            }
        }
        // Trail
        ctx.fillStyle = '#feca57';
        for (var i = 0; i < trail.length; i++) {
            ctx.fillRect(trail[i].x * CELL, trail[i].y * CELL, CELL - 1, CELL - 1);
        }
        // Player
        ctx.fillStyle = '#10b981';
        ctx.beginPath();
        ctx.arc(player.x * CELL + CELL / 2, player.y * CELL + CELL / 2, CELL / 2, 0, Math.PI * 2);
        ctx.fill();
        // Enemy
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, CELL, 0, Math.PI * 2);
        ctx.fill();
    }

    function loop() {
        if (!gameOver && !gameWon) {
            movePlayer();
            updateEnemy();
        }
        draw();
        requestAnimationFrame(loop);
    }

    // Touch controls
    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        var t = e.touches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
    }, { passive: false });

    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        var t = e.touches[0];
        var dx = t.clientX - touchStartX;
        var dy = t.clientY - touchStartY;
        var threshold = 10;
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > threshold) pendingDir = { dx: 1, dy: 0 };
            else if (dx < -threshold) pendingDir = { dx: -1, dy: 0 };
        } else {
            if (dy > threshold) pendingDir = { dx: 0, dy: 1 };
            else if (dy < -threshold) pendingDir = { dx: 0, dy: -1 };
        }
    }, { passive: false });

    canvas.addEventListener('touchend', function(e) {
        pendingDir = { dx: 0, dy: 0 };
    });

    // Keyboard (for testing)
    document.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowUp') pendingDir = { dx: 0, dy: -1 };
        else if (e.key === 'ArrowDown') pendingDir = { dx: 0, dy: 1 };
        else if (e.key === 'ArrowLeft') pendingDir = { dx: -1, dy: 0 };
        else if (e.key === 'ArrowRight') pendingDir = { dx: 1, dy: 0 };
    });
    document.addEventListener('keyup', function(e) {
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].indexOf(e.key) >= 0) {
            pendingDir = { dx: 0, dy: 0 };
        }
    });

    window.addEventListener('resize', resize);
    resize();
    loop();
})();
</script>
</body>
</html>
